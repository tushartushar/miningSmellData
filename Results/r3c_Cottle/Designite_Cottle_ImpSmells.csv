Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The method has 208 lines of code.
Long Method,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileExpression,The method has 140 lines of code.
Long Method,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The method has 123 lines of code.
Long Method,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseValue,The method has 149 lines of code.
Long Method,Cottle.Parsers.Default,Lexer,C:\repos\r3c_Cottle\Cottle\src\Parsers\Default\Lexer.cs,NextBlock,The method has 168 lines of code.
Complex Method,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseAssignment,Cyclomatic complexity of the method is 9
Complex Method,Cottle.Parsers,PostParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\PostParser.cs,Optimize,Cyclomatic complexity of the method is 8
Long Parameter List,Cottle.Documents.Simple.Nodes,ForNode,C:\repos\r3c_Cottle\Cottle\src\Documents\Simple\Nodes\ForNode.cs,ForNode,The method has 5 parameters. Parameters: from' key' value' body' empty
Long Statement,Cottle.Documents,SimpleDocument,C:\repos\r3c_Cottle\Cottle\src\Documents\SimpleDocument.cs,CompileCommand,The length of the statement  "					return new FunctionAssignNode (command.Name' command.Arguments' this.CompileCommand (command.Body' trimmer)' command.Mode); " is 123.
Long Statement,Cottle.Documents,SimpleDocument,C:\repos\r3c_Cottle\Cottle\src\Documents\SimpleDocument.cs,CompileCommand,The length of the statement  "					return new ForNode (this.CompileExpression (command.Operand)' command.Key' command.Name' this.CompileCommand (command.Body' trimmer)' command.Next != null ? this.CompileCommand (command.Next' trimmer) : null); " is 209.
Long Statement,Cottle.Documents,SimpleDocument,C:\repos\r3c_Cottle\Cottle\src\Documents\SimpleDocument.cs,CompileCommand,The length of the statement  "						branches.Add (new KeyValuePair<IEvaluator' INode> (this.CompileExpression (command.Operand)' this.CompileCommand (command.Body' trimmer))); " is 139.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<Value' IFunction>> ((v) => v.AsFunction).GetGetMethod ()); " is 120.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<IMap' IEnumerator<KeyValuePair<Value' Value>>>> ((m) => m.GetEnumerator ())); " is 137.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<IEnumerator<KeyValuePair<Value' Value>>' bool>> ((e) => e.MoveNext ())); " is 132.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<IEnumerator<KeyValuePair<Value' Value>>' KeyValuePair<Value' Value>>> ((e) => e.Current).GetGetMethod ()); " is 168.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "						this.generator.Emit (OpCodes.Call' Resolver.Property<Func<KeyValuePair<Value' Value>' Value>> ((p) => p.Key).GetGetMethod ()); " is 126.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The length of the statement  "					this.generator.Emit (OpCodes.Call' Resolver.Property<Func<KeyValuePair<Value' Value>' Value>> ((p) => p.Value).GetGetMethod ()); " is 128.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileExpression,The length of the statement  "					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<Value' IFunction>> ((v) => v.AsFunction).GetGetMethod ()); " is 120.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileExpression,The length of the statement  "					constructor = Resolver.Constructor<Func<Value' Value' KeyValuePair<Value' Value>>> ((k' v) => new KeyValuePair<Value' Value> (k' v)); " is 133.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,EmitCallFunctionExecute,The length of the statement  "			this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<IFunction' IList<Value>' IStore' TextWriter' Value>> ((f' a' s' o) => f.Execute (a' s' o))); " is 152.
Long Statement,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,EmitStoreSetCall,The length of the statement  "			this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Action<IStore' Value' Value' StoreMode>> ((s' n' v' m) => s.Set (n' v' m))); " is 131.
Long Statement,Cottle.Documents.Dynamic,Function,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Function.cs,Save,The length of the statement  "			assembly = AppDomain.CurrentDomain.DefineDynamicAssembly (new AssemblyName (assemblyName)' AssemblyBuilderAccess.RunAndSave); " is 125.
Long Statement,Cottle.Documents.Dynamic,Function,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Function.cs,Save,The length of the statement  "			method = program.DefineMethod ("Main"' MethodAttributes.Public | MethodAttributes.Static' typeof (Value)' new [] {typeof (Storage)' typeof (IList<Value>)' typeof (IStore)' typeof (TextWriter)}); " is 194.
Long Statement,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseCommand,The length of the statement  "						if (this.lexer.Current.Type == LexemType.Symbol && DefaultParser.keywords.TryGetValue (this.lexer.Current.Content' out parse)) " is 126.
Long Statement,Cottle.Parsers.Post.Optimizers,ConstantInvokeOptimizer,C:\repos\r3c_Cottle\Cottle\src\Parsers\Post\Optimizers\ConstantInvokeOptimizer.cs,Optimize,The length of the statement  "				Value = function.Execute (expression.Arguments.Select( (a) => a.Value).ToList ()' new SimpleStore ()' new StringWriter ()) " is 122.
Complex Conditional,Cottle.Parsers.Post.Optimizers,ConstantInvokeOptimizer,C:\repos\r3c_Cottle\Cottle\src\Parsers\Post\Optimizers\ConstantInvokeOptimizer.cs,Optimize,The conditional expression  "expression.Type != ExpressionType.Invoke ||  			    !Array.TrueForAll (expression.Arguments' a => a.Type == ExpressionType.Constant) ||  			    expression.Source.Type != ExpressionType.Constant ||  			    expression.Source.Value.Type != ValueContent.Function"  is complex.
Magic Number,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The following statement contains a magic number: while (true)  			{  				operands.Push (this.ParseValue ());    				switch (this.lexer.Current.Type)  				{  					case LexemType.DoubleAmpersand:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAnd'  							Precedence = 0  						};    						break;    					case LexemType.DoublePipe:  						current = new Operator  						{  							Function = BuiltinOperators.operatorOr'  							Precedence = 0  						};    						break;    					case LexemType.Equal:  						current = new Operator  						{  							Function = BuiltinOperators.operatorEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterThan'  							Precedence = 1  						};    						break;    					case LexemType.LowerEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerEqual'  							Precedence = 1  						};    						break;    					case LexemType.LowerThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerThan'  							Precedence = 1  						};    						break;    					case LexemType.Minus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorSub'  							Precedence = 2  						};    						break;    					case LexemType.NotEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorNotEqual'  							Precedence = 1  						};    						break;    					case LexemType.Percent:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMod'  							Precedence = 3  						};    						break;    					case LexemType.Plus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAdd'  							Precedence = 2  						};    						break;    					case LexemType.Slash:  						current = new Operator  						{  							Function = BuiltinOperators.operatorDiv'  							Precedence = 3  						};    						break;    					case LexemType.Star:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMul'  							Precedence = 3  						};    						break;    					default:  						while (operators.Count > 0)  						{  							current = operators.Pop ();  							value = operands.Pop ();    							operands.Push (this.BuildOperator (current.Function' operands.Pop ()' value));  						}    						return operands.Pop ();  				}    				this.lexer.Next (LexerMode.Block);    				while (operators.Count > 0 && operators.Peek ().Precedence >= current.Precedence)  				{  					other = operators.Pop ();  					value = operands.Pop ();    					operands.Push (this.BuildOperator (other.Function' operands.Pop ()' value));  				}    				operators.Push (current);  			}
Magic Number,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The following statement contains a magic number: while (true)  			{  				operands.Push (this.ParseValue ());    				switch (this.lexer.Current.Type)  				{  					case LexemType.DoubleAmpersand:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAnd'  							Precedence = 0  						};    						break;    					case LexemType.DoublePipe:  						current = new Operator  						{  							Function = BuiltinOperators.operatorOr'  							Precedence = 0  						};    						break;    					case LexemType.Equal:  						current = new Operator  						{  							Function = BuiltinOperators.operatorEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterThan'  							Precedence = 1  						};    						break;    					case LexemType.LowerEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerEqual'  							Precedence = 1  						};    						break;    					case LexemType.LowerThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerThan'  							Precedence = 1  						};    						break;    					case LexemType.Minus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorSub'  							Precedence = 2  						};    						break;    					case LexemType.NotEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorNotEqual'  							Precedence = 1  						};    						break;    					case LexemType.Percent:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMod'  							Precedence = 3  						};    						break;    					case LexemType.Plus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAdd'  							Precedence = 2  						};    						break;    					case LexemType.Slash:  						current = new Operator  						{  							Function = BuiltinOperators.operatorDiv'  							Precedence = 3  						};    						break;    					case LexemType.Star:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMul'  							Precedence = 3  						};    						break;    					default:  						while (operators.Count > 0)  						{  							current = operators.Pop ();  							value = operands.Pop ();    							operands.Push (this.BuildOperator (current.Function' operands.Pop ()' value));  						}    						return operands.Pop ();  				}    				this.lexer.Next (LexerMode.Block);    				while (operators.Count > 0 && operators.Peek ().Precedence >= current.Precedence)  				{  					other = operators.Pop ();  					value = operands.Pop ();    					operands.Push (this.BuildOperator (other.Function' operands.Pop ()' value));  				}    				operators.Push (current);  			}
Magic Number,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The following statement contains a magic number: while (true)  			{  				operands.Push (this.ParseValue ());    				switch (this.lexer.Current.Type)  				{  					case LexemType.DoubleAmpersand:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAnd'  							Precedence = 0  						};    						break;    					case LexemType.DoublePipe:  						current = new Operator  						{  							Function = BuiltinOperators.operatorOr'  							Precedence = 0  						};    						break;    					case LexemType.Equal:  						current = new Operator  						{  							Function = BuiltinOperators.operatorEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterThan'  							Precedence = 1  						};    						break;    					case LexemType.LowerEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerEqual'  							Precedence = 1  						};    						break;    					case LexemType.LowerThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerThan'  							Precedence = 1  						};    						break;    					case LexemType.Minus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorSub'  							Precedence = 2  						};    						break;    					case LexemType.NotEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorNotEqual'  							Precedence = 1  						};    						break;    					case LexemType.Percent:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMod'  							Precedence = 3  						};    						break;    					case LexemType.Plus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAdd'  							Precedence = 2  						};    						break;    					case LexemType.Slash:  						current = new Operator  						{  							Function = BuiltinOperators.operatorDiv'  							Precedence = 3  						};    						break;    					case LexemType.Star:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMul'  							Precedence = 3  						};    						break;    					default:  						while (operators.Count > 0)  						{  							current = operators.Pop ();  							value = operands.Pop ();    							operands.Push (this.BuildOperator (current.Function' operands.Pop ()' value));  						}    						return operands.Pop ();  				}    				this.lexer.Next (LexerMode.Block);    				while (operators.Count > 0 && operators.Peek ().Precedence >= current.Precedence)  				{  					other = operators.Pop ();  					value = operands.Pop ();    					operands.Push (this.BuildOperator (other.Function' operands.Pop ()' value));  				}    				operators.Push (current);  			}
Magic Number,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The following statement contains a magic number: while (true)  			{  				operands.Push (this.ParseValue ());    				switch (this.lexer.Current.Type)  				{  					case LexemType.DoubleAmpersand:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAnd'  							Precedence = 0  						};    						break;    					case LexemType.DoublePipe:  						current = new Operator  						{  							Function = BuiltinOperators.operatorOr'  							Precedence = 0  						};    						break;    					case LexemType.Equal:  						current = new Operator  						{  							Function = BuiltinOperators.operatorEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterThan'  							Precedence = 1  						};    						break;    					case LexemType.LowerEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerEqual'  							Precedence = 1  						};    						break;    					case LexemType.LowerThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerThan'  							Precedence = 1  						};    						break;    					case LexemType.Minus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorSub'  							Precedence = 2  						};    						break;    					case LexemType.NotEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorNotEqual'  							Precedence = 1  						};    						break;    					case LexemType.Percent:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMod'  							Precedence = 3  						};    						break;    					case LexemType.Plus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAdd'  							Precedence = 2  						};    						break;    					case LexemType.Slash:  						current = new Operator  						{  							Function = BuiltinOperators.operatorDiv'  							Precedence = 3  						};    						break;    					case LexemType.Star:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMul'  							Precedence = 3  						};    						break;    					default:  						while (operators.Count > 0)  						{  							current = operators.Pop ();  							value = operands.Pop ();    							operands.Push (this.BuildOperator (current.Function' operands.Pop ()' value));  						}    						return operands.Pop ();  				}    				this.lexer.Next (LexerMode.Block);    				while (operators.Count > 0 && operators.Peek ().Precedence >= current.Precedence)  				{  					other = operators.Pop ();  					value = operands.Pop ();    					operands.Push (this.BuildOperator (other.Function' operands.Pop ()' value));  				}    				operators.Push (current);  			}
Magic Number,Cottle.Parsers,DefaultParser,C:\repos\r3c_Cottle\Cottle\src\Parsers\DefaultParser.cs,ParseExpression,The following statement contains a magic number: while (true)  			{  				operands.Push (this.ParseValue ());    				switch (this.lexer.Current.Type)  				{  					case LexemType.DoubleAmpersand:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAnd'  							Precedence = 0  						};    						break;    					case LexemType.DoublePipe:  						current = new Operator  						{  							Function = BuiltinOperators.operatorOr'  							Precedence = 0  						};    						break;    					case LexemType.Equal:  						current = new Operator  						{  							Function = BuiltinOperators.operatorEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterEqual'  							Precedence = 1  						};    						break;    					case LexemType.GreaterThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorGreaterThan'  							Precedence = 1  						};    						break;    					case LexemType.LowerEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerEqual'  							Precedence = 1  						};    						break;    					case LexemType.LowerThan:  						current = new Operator  						{  							Function = BuiltinOperators.operatorLowerThan'  							Precedence = 1  						};    						break;    					case LexemType.Minus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorSub'  							Precedence = 2  						};    						break;    					case LexemType.NotEqual:  						current = new Operator  						{  							Function = BuiltinOperators.operatorNotEqual'  							Precedence = 1  						};    						break;    					case LexemType.Percent:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMod'  							Precedence = 3  						};    						break;    					case LexemType.Plus:  						current = new Operator  						{  							Function = BuiltinOperators.operatorAdd'  							Precedence = 2  						};    						break;    					case LexemType.Slash:  						current = new Operator  						{  							Function = BuiltinOperators.operatorDiv'  							Precedence = 3  						};    						break;    					case LexemType.Star:  						current = new Operator  						{  							Function = BuiltinOperators.operatorMul'  							Precedence = 3  						};    						break;    					default:  						while (operators.Count > 0)  						{  							current = operators.Pop ();  							value = operands.Pop ();    							operands.Push (this.BuildOperator (current.Function' operands.Pop ()' value));  						}    						return operands.Pop ();  				}    				this.lexer.Next (LexerMode.Block);    				while (operators.Count > 0 && operators.Peek ().Precedence >= current.Precedence)  				{  					other = operators.Pop ();  					value = operands.Pop ();    					operands.Push (this.BuildOperator (other.Function' operands.Pop ()' value));  				}    				operators.Push (current);  			}
Magic Number,Cottle.Stores,SimpleStore,C:\repos\r3c_Cottle\Cottle\src\Stores\SimpleStore.cs,Leave,The following statement contains a magic number: foreach (Value name in this.levels.Pop ())  			{  				if (this.stacks.TryGetValue (name' out stack))  				{  					if (stack.Count < 2)  						this.stacks.Remove (name);  					else  						stack.Pop ();						  				}  			}
Missing Default,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileCommand,The following switch statement is missing a default case: switch (command.Type)  			{  				case CommandType.AssignFunction:  					this.EmitLoadStore ();  					this.EmitLoadValue (command.Name);    					this.EmitLoadValue (new FunctionValue (new Function (command.Arguments' command.Body' this.trimmer)));  					this.EmitStoreSetCall (command.Mode);    					break;    				case CommandType.AssignRender:  					// Prepare new buffer to store sub-rendering  					buffer = this.LocalReserve<TextWriter> ();    					this.generator.Emit (OpCodes.Newobj' Resolver.Constructor<Func<StringWriter>> (() => new StringWriter ()));  					this.generator.Emit (OpCodes.Stloc' buffer);    					// Load function' empty arguments array' store and text writer onto stack  					this.EmitLoadValue (new FunctionValue (new Function (Enumerable.Empty<string> ()' command.Body' this.trimmer)));    					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<Value' IFunction>> ((v) => v.AsFunction).GetGetMethod ());  					this.generator.Emit (OpCodes.Ldc_I4' 0);  					this.generator.Emit (OpCodes.Newarr' typeof (Value));    					this.EmitLoadStore ();    					this.generator.Emit (OpCodes.Ldloc' buffer);    					this.EmitCallFunctionExecute ();    					this.generator.Emit (OpCodes.Pop);    					// Convert buffer into string and set to store  					this.EmitLoadStore ();  					this.EmitLoadValue (command.Name);    					this.generator.Emit (OpCodes.Ldloc' buffer);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<StringWriter' string>> ((w) => w.ToString ()));    					this.LocalRelease<Value> (buffer);    					this.generator.Emit (OpCodes.Newobj' Resolver.Constructor<Func<string' Value>> ((s) => new StringValue (s)));    					this.EmitStoreSetCall (command.Mode);    					break;    				case CommandType.AssignValue:  					this.CompileExpression (command.Operand);    					operand = this.LocalReserve<Value> ();    					this.generator.Emit (OpCodes.Stloc' operand);    					this.EmitLoadStore ();  					this.EmitLoadValue (command.Name);    					this.generator.Emit (OpCodes.Ldloc' operand);    					this.LocalRelease<Value> (operand);  					this.EmitStoreSetCall (command.Mode);    					break;    				case CommandType.Composite:  					this.CompileCommand (command.Body' exit' depth);  					this.CompileCommand (command.Next' exit' depth);    					break;    				case CommandType.Dump:  					this.CompileExpression (command.Operand);    					operand = this.LocalReserve<Value> ();    					this.generator.Emit (OpCodes.Stloc' operand);    					this.EmitLoadOutput ();    					this.generator.Emit (OpCodes.Ldloc' operand);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Action<TextWriter' object>> ((w' v) => w.Write (v)));    					this.LocalRelease<Value> (operand);    					break;    				case CommandType.Echo:  					this.CompileExpression (command.Operand);    					operand = this.LocalReserve<Value> ();    					this.generator.Emit (OpCodes.Stloc' operand);    					this.EmitLoadOutput ();    					this.generator.Emit (OpCodes.Ldloc' operand);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<Value' string>> ((v) => v.AsString).GetGetMethod ());    					this.LocalRelease<Value> (operand);    					this.EmitCallWriteString ();    					break;    				case CommandType.For:  					empty = this.generator.DefineLabel ();  					jump = this.generator.DefineLabel ();  					skip = this.generator.DefineLabel ();    					// Evaluate operand into fields map  					this.CompileExpression (command.Operand);  					this.EmitCallValueFields ();    					fields = this.LocalReserve<IMap> ();    					this.generator.Emit (OpCodes.Stloc' fields);    					// Get number of fields  					this.generator.Emit (OpCodes.Ldloc' fields);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<IMap' int>> ((m) => m.Count).GetGetMethod ());  					this.generator.Emit (OpCodes.Brfalse' empty);    					// Evaluate command for "not empty" case  					this.generator.Emit (OpCodes.Ldloc' fields);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<IMap' IEnumerator<KeyValuePair<Value' Value>>>> ((m) => m.GetEnumerator ()));    					this.LocalRelease<IMap> (fields);    					enumerator = this.LocalReserve<IEnumerator<KeyValuePair<Value' Value>>> ();    					this.generator.Emit (OpCodes.Stloc' enumerator);    					// Fetch next enumerator element or end loop  					this.generator.MarkLabel (jump);  					this.generator.Emit (OpCodes.Ldloc' enumerator);  					this.generator.Emit (OpCodes.Callvirt' Resolver.Method<Func<IEnumerator<KeyValuePair<Value' Value>>' bool>> ((e) => e.MoveNext ()));  					this.generator.Emit (OpCodes.Brfalse' skip);  					this.generator.Emit (OpCodes.Ldloc' enumerator);    					this.LocalRelease<IEnumerator<KeyValuePair<Value' Value>>> (enumerator);    					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<IEnumerator<KeyValuePair<Value' Value>>' KeyValuePair<Value' Value>>> ((e) => e.Current).GetGetMethod ());    					pair = this.LocalReserve<KeyValuePair<Value' Value>> ();    					this.generator.Emit (OpCodes.Stloc' pair);    					// Enter loop scope  					this.EmitStoreEnter ();    					// Set current element key if required  					if (!string.IsNullOrEmpty (command.Key))  					{  						this.EmitLoadStore ();  						this.EmitLoadValue (command.Key);    						this.generator.Emit (OpCodes.Ldloca' pair);  						this.generator.Emit (OpCodes.Call' Resolver.Property<Func<KeyValuePair<Value' Value>' Value>> ((p) => p.Key).GetGetMethod ());    						this.EmitStoreSetCall (StoreMode.Local);  					}    					// Set current element value  					this.EmitLoadStore ();  					this.EmitLoadValue (command.Name);    					this.generator.Emit (OpCodes.Ldloca' pair);  					this.generator.Emit (OpCodes.Call' Resolver.Property<Func<KeyValuePair<Value' Value>' Value>> ((p) => p.Value).GetGetMethod ());    					this.LocalRelease<KeyValuePair<Value' Value>> (pair);  					this.EmitStoreSetCall (StoreMode.Local);    					// Evaluate body and restart cycle  					this.CompileCommand (command.Body' exit' depth + 1);  					this.EmitStoreLeave ();    					this.generator.Emit (OpCodes.Br' jump);    					// Evaluate command for "empty" case  					this.generator.MarkLabel (empty);    					if (command.Next != null)  					{  						this.EmitStoreEnter ();  						this.CompileCommand (command.Next' exit' depth + 1);  						this.EmitStoreLeave ();  					}    					// Mark end of statement  					this.generator.MarkLabel (skip);    					break;    				case CommandType.If:  					skip = this.generator.DefineLabel ();    					// Emit conditional branches  					for (; command != null && command.Type == CommandType.If; command = command.Next)  					{  						jump = this.generator.DefineLabel ();    						// Evaluate branch condition' jump to next if false  						this.CompileExpression (command.Operand);  						this.EmitCallValueAsBoolean ();    						this.generator.Emit (OpCodes.Brfalse' jump);    						// Execute branch command and jump sibling statements  						this.EmitStoreEnter ();  						this.CompileCommand (command.Body' exit' depth + 1);  						this.EmitStoreLeave ();    						this.generator.Emit (OpCodes.Br' skip);  						this.generator.MarkLabel (jump);  					}    					// Emit fallback branch if any  					if (command != null)  					{  						this.EmitStoreEnter ();  						this.CompileCommand (command' exit' depth + 1);  						this.EmitStoreLeave ();  					}    					// Mark end of statement  					this.generator.MarkLabel (skip);    					break;    				case CommandType.Literal:  					this.EmitLoadOutput ();    					this.generator.Emit (OpCodes.Ldstr' this.trimmer (command.Text));    					this.EmitCallWriteString ();    					break;    				case CommandType.Return:  					this.CompileExpression (command.Operand);    					// Leave all opened scopes if any  					if (depth > 0)  					{  						this.generator.Emit (OpCodes.Ldc_I4' depth);    						counter = this.LocalReserve<int> ();    						this.generator.Emit (OpCodes.Stloc' counter);    						jump = this.generator.DefineLabel ();    						this.generator.MarkLabel (jump);    						this.EmitStoreLeave ();    						this.generator.Emit (OpCodes.Ldloc' counter);  						this.generator.Emit (OpCodes.Ldc_I4_1);  						this.generator.Emit (OpCodes.Sub);  						this.generator.Emit (OpCodes.Stloc' counter);  						this.generator.Emit (OpCodes.Ldloc' counter);  						this.generator.Emit (OpCodes.Brtrue' jump);    						this.LocalRelease<int> (counter);  					}    					this.generator.Emit (OpCodes.Br' exit);    					break;    				case CommandType.While:  					jump = this.generator.DefineLabel ();  					skip = this.generator.DefineLabel ();    					// Branch to condition before first body execution  					this.generator.Emit (OpCodes.Br' skip);    					// Execute loop command  					this.generator.MarkLabel (jump);    					this.EmitStoreEnter ();  					this.CompileCommand (command.Body' exit' depth + 1);  					this.EmitStoreLeave ();    					// Evaluate loop condition' restart cycle if true  					this.generator.MarkLabel (skip);    					this.CompileExpression (command.Operand);  					this.EmitCallValueAsBoolean ();    					this.generator.Emit (OpCodes.Brtrue' jump);    					break;  			}
Missing Default,Cottle.Documents.Dynamic,Compiler,C:\repos\r3c_Cottle\Cottle\src\Documents\Dynamic\Compiler.cs,CompileExpression,The following switch statement is missing a default case: switch (expression.Type)  			{  				case ExpressionType.Access:  					success = this.generator.DefineLabel ();    					// Evaluate source expression and get fields  					this.CompileExpression (expression.Source);  					this.EmitCallValueFields ();    					fields = this.LocalReserve<IMap> ();    					this.generator.Emit (OpCodes.Stloc' fields);    					// Evaluate subscript expression  					this.CompileExpression (expression.Subscript);    					value = this.LocalReserve<Value> ();    					this.generator.Emit (OpCodes.Stloc' value);    					// Use subscript to get value from fields  					this.generator.Emit (OpCodes.Ldloc' fields);  					this.generator.Emit (OpCodes.Ldloc' value);  					this.generator.Emit (OpCodes.Ldloca' value);  					this.generator.Emit (OpCodes.Callvirt' typeof (IMap).GetMethod ("TryGet"));  					this.generator.Emit (OpCodes.Brtrue' success);    					// Emit void value on error  					this.EmitLoadVoid ();    					this.generator.Emit (OpCodes.Stloc' value);    					// Push value on stack  					this.generator.MarkLabel (success);  					this.generator.Emit (OpCodes.Ldloc' value);    					this.LocalRelease<Value> (value);    					break;    				case ExpressionType.Constant:  					this.EmitLoadValue (expression.Value);    					break;    				case ExpressionType.Invoke:  					failure = this.generator.DefineLabel ();  					success = this.generator.DefineLabel ();    					// Evaluate source expression as a function  					this.CompileExpression (expression.Source);    					this.generator.Emit (OpCodes.Callvirt' Resolver.Property<Func<Value' IFunction>> ((v) => v.AsFunction).GetGetMethod ());    					function = this.LocalReserve<IFunction> ();    					this.generator.Emit (OpCodes.Stloc' function);  					this.generator.Emit (OpCodes.Ldloc' function);  					this.generator.Emit (OpCodes.Brfalse' failure);    					// Create array to store evaluated values  					this.generator.Emit (OpCodes.Ldc_I4' expression.Arguments.Length);  					this.generator.Emit (OpCodes.Newarr' typeof (Value));    					arguments = this.LocalReserve<Value[]> ();    					this.generator.Emit (OpCodes.Stloc' arguments);    					// Evaluate arguments and store into array  					for (int i = 0; i < expression.Arguments.Length; ++i)  					{  						this.CompileExpression (expression.Arguments[i]);    						value = this.LocalReserve<Value> ();    						this.generator.Emit (OpCodes.Stloc' value);  						this.generator.Emit (OpCodes.Ldloc' arguments);  						this.generator.Emit (OpCodes.Ldc_I4' i);  						this.generator.Emit (OpCodes.Ldloc' value);  						this.generator.Emit (OpCodes.Stelem_Ref);    						this.LocalRelease<Value> (value);  					}    					// Invoke function delegate within exception block  					this.generator.Emit (OpCodes.Ldloc' function);  					this.generator.Emit (OpCodes.Ldloc' arguments);    					this.LocalRelease<Value[]> (arguments);  					this.LocalRelease<IFunction> (function);  					this.EmitLoadStore ();  					this.EmitLoadOutput ();    					value = this.LocalReserve<Value> ();    					this.EmitCallFunctionExecute ();    					this.generator.Emit (OpCodes.Stloc' value);  					this.generator.Emit (OpCodes.Br_S' success);    					// Emit void value on error  					this.generator.MarkLabel (failure);    					this.EmitLoadVoid ();    					this.generator.Emit (OpCodes.Stloc' value);    					// Value is already available on stack  					this.generator.MarkLabel (success);  					this.generator.Emit (OpCodes.Ldloc' value);    					this.LocalRelease<Value> (value);    					break;    				case ExpressionType.Map:  					// Create array to store evaluated pairs  					this.generator.Emit (OpCodes.Ldc_I4' expression.Elements.Length);  					this.generator.Emit (OpCodes.Newarr' typeof (KeyValuePair<Value' Value>));    					arguments = this.LocalReserve<KeyValuePair<Value' Value>[]> ();    					this.generator.Emit (OpCodes.Stloc' arguments);    					// Evaluate elements and store into array   					constructor = Resolver.Constructor<Func<Value' Value' KeyValuePair<Value' Value>>> ((k' v) => new KeyValuePair<Value' Value> (k' v));    					for (int i = 0; i < expression.Elements.Length; ++i)  					{  						this.CompileExpression (expression.Elements[i].Key);    						key = this.LocalReserve<Value> ();    						this.generator.Emit (OpCodes.Stloc' key);    						this.CompileExpression (expression.Elements[i].Value);    						value = this.LocalReserve<Value> ();    						this.generator.Emit (OpCodes.Stloc' value);  						this.generator.Emit (OpCodes.Ldloc' arguments);  						this.generator.Emit (OpCodes.Ldc_I4' i);  						this.generator.Emit (OpCodes.Ldelema' typeof (KeyValuePair<Value' Value>));  						this.generator.Emit (OpCodes.Ldloc' key);  						this.generator.Emit (OpCodes.Ldloc' value);  						this.generator.Emit (OpCodes.Newobj' constructor);  						this.generator.Emit (OpCodes.Stobj' typeof (KeyValuePair<Value' Value>));    						this.LocalRelease<Value> (key);  						this.LocalRelease<Value> (value);  					}    					// Create value from array  					constructor = Resolver.Constructor<Func<IEnumerable<KeyValuePair<Value' Value>>' Value>> ((f) => new MapValue (f));    					this.generator.Emit (OpCodes.Ldloc' arguments);  					this.generator.Emit (OpCodes.Newobj' constructor);    					this.LocalRelease<KeyValuePair<Value' Value>[]> (arguments);    					break;    				case ExpressionType.Symbol:  					success = this.generator.DefineLabel ();    					// Get variable from scope  					this.EmitLoadStore ();  					this.EmitLoadValue (expression.Value);    					value = this.LocalReserve<Value> ();    					this.generator.Emit (OpCodes.Ldloca' value);  					this.generator.Emit (OpCodes.Callvirt' typeof (IStore).GetMethod ("TryGet"));  					this.generator.Emit (OpCodes.Brtrue' success);    					// Emit void value on error  					this.EmitLoadVoid ();    					this.generator.Emit (OpCodes.Stloc' value);    					// Push value on stack  					this.generator.MarkLabel (success);  					this.generator.Emit (OpCodes.Ldloc' value);    					this.LocalRelease<Value> (value);    					break;    				case ExpressionType.Void:  					this.EmitLoadVoid ();    					break;  			}
Missing Default,Cottle.Stores,SimpleStore,C:\repos\r3c_Cottle\Cottle\src\Stores\SimpleStore.cs,Set,The following switch statement is missing a default case: switch (mode)  			{  				case StoreMode.Global:  					if (stack.Count > 0)  						stack.Pop ();    					break;    				case StoreMode.Local:  					if (this.levels.Count > 0 && !this.levels.Peek ().Add (symbol))  						stack.Pop ();    					break;  			}
