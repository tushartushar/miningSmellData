Implementation smell,Namespace,Class,File,Method,Description
Long Method,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileCommand,The method has 211 lines of code.
Long Method,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileExpression,The method has 141 lines of code.
Long Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseAssignment,The method has 128 lines of code.
Long Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseValue,The method has 177 lines of code.
Long Method,Cottle.Parsers.Forward,Lexer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Forward\Lexer.cs,ReadBlock,The method has 164 lines of code.
Complex Method,Cottle.Documents.Default,Compiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Default\Compiler.cs,CompileCommand,Cyclomatic complexity of the method is 16
Complex Method,Cottle.Documents.Default,Compiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Default\Compiler.cs,CompileExpression,Cyclomatic complexity of the method is 8
Complex Method,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileCommand,Cyclomatic complexity of the method is 16
Complex Method,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileExpression,Cyclomatic complexity of the method is 8
Complex Method,Cottle.Documents.Simple,Compiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Simple\Compiler.cs,CompileCommand,Cyclomatic complexity of the method is 14
Complex Method,Cottle.Documents.Simple,Compiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Simple\Compiler.cs,CompileExpression,Cyclomatic complexity of the method is 8
Complex Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseAssignment,Cyclomatic complexity of the method is 17
Complex Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseCommand,Cyclomatic complexity of the method is 10
Complex Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,Cyclomatic complexity of the method is 18
Complex Method,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseValue,Cyclomatic complexity of the method is 29
Complex Method,Cottle.Parsers.Forward,Lexer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Forward\Lexer.cs,ReadBlock,Cyclomatic complexity of the method is 33
Complex Method,Cottle.Parsers.Optimize.Optimizers,RecursiveOptimizer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Optimize\Optimizers\RecursiveOptimizer.cs,Optimize,Cyclomatic complexity of the method is 8
Complex Method,Cottle.Values,ReflectionValue,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Values\ReflectionValue.cs,Resolve,Cyclomatic complexity of the method is 9
Long Parameter List,Cottle.Documents.Default.Executors,ForExecutor,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Default\Executors\ForExecutor.cs,ForExecutor,The method has 5 parameters. Parameters: from' key' value' body' empty
Long Parameter List,Cottle.Documents.Simple.Nodes,ForNode,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Simple\Nodes\ForNode.cs,ForNode,The method has 5 parameters. Parameters: from' key' value' body' empty
Long Parameter List,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,ForwardParser,The method has 5 parameters. Parameters: blockBegin' blockContinue' blockEnd' escape' trimmer
Long Statement,Cottle.Documents.Default.Executors.Assign,NodeFunction,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Default\Executors\Assign\FunctionAssignExecutor.cs,Invoke,The length of the statement  "                    throw new InvalidOperationException($"Invalid function invoke' you seem to have injected a function declared in a {nameof(DefaultDocument)} from another type of document."); " is 173.
Long Statement,Cottle.Documents.Dynamic,DynamicFunction,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicFunction.cs,Invoke,The length of the statement  "                throw new InvalidOperationException($"Invalid function invoke' you seem to have injected a function declared in a {nameof(DynamicDocument)} from another type of document."); " is 173.
Long Statement,Cottle.Documents.Simple.Nodes.AssignNodes,FunctionAssignNode,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Simple\Nodes\AssignNodes\FunctionAssignNode.cs,Invoke,The length of the statement  "                throw new InvalidOperationException($"Invalid function invoke' you seem to have injected a function declared in a {nameof(SimpleDocument)} from another type of document."); " is 172.
Long Statement,Cottle.Functions,NativeFunction,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Functions\NativeFunction.cs,Invoke,The length of the statement  "                throw new InvalidOperationException("You're calling an instance of `NativeFunction` from an incompatible document type. Please replace all usages of `NativeFunction` by calls to `Function.Create*` static methods."); " is 215.
Magic Number,Cottle,Function,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Function.cs,Create2,The following statement contains a magic number: return new CallbackFunction(false'                  (state' arguments' output) => callback(state' arguments[0]' arguments[1]' output)' 2' 2);
Magic Number,Cottle,Function,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Function.cs,Create2,The following statement contains a magic number: return new CallbackFunction(false'                  (state' arguments' output) => callback(state' arguments[0]' arguments[1]' output)' 2' 2);
Magic Number,Cottle,Function,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Function.cs,CreatePure2,The following statement contains a magic number: return new CallbackFunction(true' (state' arguments' _) => callback(state' arguments[0]' arguments[1])' 2'                  2);
Magic Number,Cottle,Function,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Function.cs,CreatePure2,The following statement contains a magic number: return new CallbackFunction(true' (state' arguments' _) => callback(state' arguments[0]' arguments[1])' 2'                  2);
Magic Number,Cottle.Functions,CallbackFunction,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Functions\CallbackFunction.cs,GetHashCode,The following statement contains a magic number: return                      ((_callback.GetHashCode() << 8) & (int)0xFFFFFF00) |                      ((_max.GetHashCode() << 4) & 0x000000F0) |                      (_min.GetHashCode() & 0x0000000F);
Magic Number,Cottle.Functions,CallbackFunction,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Functions\CallbackFunction.cs,GetHashCode,The following statement contains a magic number: return                      ((_callback.GetHashCode() << 8) & (int)0xFFFFFF00) |                      ((_max.GetHashCode() << 4) & 0x000000F0) |                      (_min.GetHashCode() & 0x0000000F);
Magic Number,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,The following statement contains a magic number: switch (_lexer.Current.Type)                  {                      case LexemType.DoubleAmpersand:                          current = new Operator(BuiltinOperators.OperatorAnd' 0);                            break;                        case LexemType.DoublePipe:                          current = new Operator(BuiltinOperators.OperatorOr' 0);                            break;                        case LexemType.Equal:                          current = new Operator(BuiltinOperators.OperatorEqual' 1);                            break;                        case LexemType.GreaterEqual:                          current = new Operator(BuiltinOperators.OperatorGreaterEqual' 1);                            break;                        case LexemType.GreaterThan:                          current = new Operator(BuiltinOperators.OperatorGreaterThan' 1);                            break;                        case LexemType.LowerEqual:                          current = new Operator(BuiltinOperators.OperatorLowerEqual' 1);                            break;                        case LexemType.LowerThan:                          current = new Operator(BuiltinOperators.OperatorLowerThan' 1);                            break;                        case LexemType.Minus:                          current = new Operator(BuiltinOperators.OperatorSub' 2);                            break;                        case LexemType.NotEqual:                          current = new Operator(BuiltinOperators.OperatorNotEqual' 1);                            break;                        case LexemType.Percent:                          current = new Operator(BuiltinOperators.OperatorMod' 3);                            break;                        case LexemType.Plus:                          current = new Operator(BuiltinOperators.OperatorAdd' 2);                            break;                        case LexemType.Slash:                          current = new Operator(BuiltinOperators.OperatorDiv' 3);                            break;                        case LexemType.Star:                          current = new Operator(BuiltinOperators.OperatorMul' 3);                            break;                        default:                          while (operators.Count > 0)                          {                              var remaining = operators.Pop();                              var value = operands.Pop();                                operands.Push(ForwardParser.BuildInvoke(remaining.Function' operands.Pop()' value));                          }                            expression = operands.Pop();                          reports = default;                            return true;                  }
Magic Number,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,The following statement contains a magic number: switch (_lexer.Current.Type)                  {                      case LexemType.DoubleAmpersand:                          current = new Operator(BuiltinOperators.OperatorAnd' 0);                            break;                        case LexemType.DoublePipe:                          current = new Operator(BuiltinOperators.OperatorOr' 0);                            break;                        case LexemType.Equal:                          current = new Operator(BuiltinOperators.OperatorEqual' 1);                            break;                        case LexemType.GreaterEqual:                          current = new Operator(BuiltinOperators.OperatorGreaterEqual' 1);                            break;                        case LexemType.GreaterThan:                          current = new Operator(BuiltinOperators.OperatorGreaterThan' 1);                            break;                        case LexemType.LowerEqual:                          current = new Operator(BuiltinOperators.OperatorLowerEqual' 1);                            break;                        case LexemType.LowerThan:                          current = new Operator(BuiltinOperators.OperatorLowerThan' 1);                            break;                        case LexemType.Minus:                          current = new Operator(BuiltinOperators.OperatorSub' 2);                            break;                        case LexemType.NotEqual:                          current = new Operator(BuiltinOperators.OperatorNotEqual' 1);                            break;                        case LexemType.Percent:                          current = new Operator(BuiltinOperators.OperatorMod' 3);                            break;                        case LexemType.Plus:                          current = new Operator(BuiltinOperators.OperatorAdd' 2);                            break;                        case LexemType.Slash:                          current = new Operator(BuiltinOperators.OperatorDiv' 3);                            break;                        case LexemType.Star:                          current = new Operator(BuiltinOperators.OperatorMul' 3);                            break;                        default:                          while (operators.Count > 0)                          {                              var remaining = operators.Pop();                              var value = operands.Pop();                                operands.Push(ForwardParser.BuildInvoke(remaining.Function' operands.Pop()' value));                          }                            expression = operands.Pop();                          reports = default;                            return true;                  }
Magic Number,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,The following statement contains a magic number: switch (_lexer.Current.Type)                  {                      case LexemType.DoubleAmpersand:                          current = new Operator(BuiltinOperators.OperatorAnd' 0);                            break;                        case LexemType.DoublePipe:                          current = new Operator(BuiltinOperators.OperatorOr' 0);                            break;                        case LexemType.Equal:                          current = new Operator(BuiltinOperators.OperatorEqual' 1);                            break;                        case LexemType.GreaterEqual:                          current = new Operator(BuiltinOperators.OperatorGreaterEqual' 1);                            break;                        case LexemType.GreaterThan:                          current = new Operator(BuiltinOperators.OperatorGreaterThan' 1);                            break;                        case LexemType.LowerEqual:                          current = new Operator(BuiltinOperators.OperatorLowerEqual' 1);                            break;                        case LexemType.LowerThan:                          current = new Operator(BuiltinOperators.OperatorLowerThan' 1);                            break;                        case LexemType.Minus:                          current = new Operator(BuiltinOperators.OperatorSub' 2);                            break;                        case LexemType.NotEqual:                          current = new Operator(BuiltinOperators.OperatorNotEqual' 1);                            break;                        case LexemType.Percent:                          current = new Operator(BuiltinOperators.OperatorMod' 3);                            break;                        case LexemType.Plus:                          current = new Operator(BuiltinOperators.OperatorAdd' 2);                            break;                        case LexemType.Slash:                          current = new Operator(BuiltinOperators.OperatorDiv' 3);                            break;                        case LexemType.Star:                          current = new Operator(BuiltinOperators.OperatorMul' 3);                            break;                        default:                          while (operators.Count > 0)                          {                              var remaining = operators.Pop();                              var value = operands.Pop();                                operands.Push(ForwardParser.BuildInvoke(remaining.Function' operands.Pop()' value));                          }                            expression = operands.Pop();                          reports = default;                            return true;                  }
Magic Number,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,The following statement contains a magic number: switch (_lexer.Current.Type)                  {                      case LexemType.DoubleAmpersand:                          current = new Operator(BuiltinOperators.OperatorAnd' 0);                            break;                        case LexemType.DoublePipe:                          current = new Operator(BuiltinOperators.OperatorOr' 0);                            break;                        case LexemType.Equal:                          current = new Operator(BuiltinOperators.OperatorEqual' 1);                            break;                        case LexemType.GreaterEqual:                          current = new Operator(BuiltinOperators.OperatorGreaterEqual' 1);                            break;                        case LexemType.GreaterThan:                          current = new Operator(BuiltinOperators.OperatorGreaterThan' 1);                            break;                        case LexemType.LowerEqual:                          current = new Operator(BuiltinOperators.OperatorLowerEqual' 1);                            break;                        case LexemType.LowerThan:                          current = new Operator(BuiltinOperators.OperatorLowerThan' 1);                            break;                        case LexemType.Minus:                          current = new Operator(BuiltinOperators.OperatorSub' 2);                            break;                        case LexemType.NotEqual:                          current = new Operator(BuiltinOperators.OperatorNotEqual' 1);                            break;                        case LexemType.Percent:                          current = new Operator(BuiltinOperators.OperatorMod' 3);                            break;                        case LexemType.Plus:                          current = new Operator(BuiltinOperators.OperatorAdd' 2);                            break;                        case LexemType.Slash:                          current = new Operator(BuiltinOperators.OperatorDiv' 3);                            break;                        case LexemType.Star:                          current = new Operator(BuiltinOperators.OperatorMul' 3);                            break;                        default:                          while (operators.Count > 0)                          {                              var remaining = operators.Pop();                              var value = operands.Pop();                                operands.Push(ForwardParser.BuildInvoke(remaining.Function' operands.Pop()' value));                          }                            expression = operands.Pop();                          reports = default;                            return true;                  }
Magic Number,Cottle.Parsers,ForwardParser,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\ForwardParser.cs,TryParseExpression,The following statement contains a magic number: switch (_lexer.Current.Type)                  {                      case LexemType.DoubleAmpersand:                          current = new Operator(BuiltinOperators.OperatorAnd' 0);                            break;                        case LexemType.DoublePipe:                          current = new Operator(BuiltinOperators.OperatorOr' 0);                            break;                        case LexemType.Equal:                          current = new Operator(BuiltinOperators.OperatorEqual' 1);                            break;                        case LexemType.GreaterEqual:                          current = new Operator(BuiltinOperators.OperatorGreaterEqual' 1);                            break;                        case LexemType.GreaterThan:                          current = new Operator(BuiltinOperators.OperatorGreaterThan' 1);                            break;                        case LexemType.LowerEqual:                          current = new Operator(BuiltinOperators.OperatorLowerEqual' 1);                            break;                        case LexemType.LowerThan:                          current = new Operator(BuiltinOperators.OperatorLowerThan' 1);                            break;                        case LexemType.Minus:                          current = new Operator(BuiltinOperators.OperatorSub' 2);                            break;                        case LexemType.NotEqual:                          current = new Operator(BuiltinOperators.OperatorNotEqual' 1);                            break;                        case LexemType.Percent:                          current = new Operator(BuiltinOperators.OperatorMod' 3);                            break;                        case LexemType.Plus:                          current = new Operator(BuiltinOperators.OperatorAdd' 2);                            break;                        case LexemType.Slash:                          current = new Operator(BuiltinOperators.OperatorDiv' 3);                            break;                        case LexemType.Star:                          current = new Operator(BuiltinOperators.OperatorMul' 3);                            break;                        default:                          while (operators.Count > 0)                          {                              var remaining = operators.Pop();                              var value = operands.Pop();                                operands.Push(ForwardParser.BuildInvoke(remaining.Function' operands.Pop()' value));                          }                            expression = operands.Pop();                          reports = default;                            return true;                  }
Magic Number,Cottle.Parsers.Forward,Lexer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Forward\Lexer.cs,ReadBlock,The following statement contains a magic number: switch (_last)                  {                      case '\n':                      case '\r':                      case '\t':                      case ' ':                          while (_last <= ' ' && Read())                          {                          }                            break;                        case '!':                          if (Read() && _last == '=')                              return ReadChar(LexemType.NotEqual' "!=");                            return new Lexem(LexemType.Bang' offset' 2' "!");                        case '%':                          return ReadChar(LexemType.Percent' "%");                        case '&':                          if (Read() && _last == '&')                              return ReadChar(LexemType.DoubleAmpersand' "&&");                            _next = _last;                          _last = '&';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '(':                          return ReadChar(LexemType.ParenthesisBegin' "(");                        case ')':                          return ReadChar(LexemType.ParenthesisEnd' ")");                        case '*':                          return ReadChar(LexemType.Star' "*");                        case '+':                          return ReadChar(LexemType.Plus' "+");                        case ''':                          return ReadChar(LexemType.Comma' "'");                        case '-':                          return ReadChar(LexemType.Minus' "-");                        case '.':                          return ReadChar(LexemType.Dot' ".");                        case '/':                          return ReadChar(LexemType.Slash' "/");                        case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          var numberBuffer = new StringBuilder();                          var dot = false;                            do                          {                              dot |= _last == '.';                                numberBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last == '.' && !dot));                            return new Lexem(LexemType.Number' offset' numberBuffer.Length' numberBuffer.ToString());                        case ':':                          return ReadChar(LexemType.Colon' ":");                        case '<':                          if (Read() && _last == '=')                              return ReadChar(LexemType.LowerEqual' "<=");                            return new Lexem(LexemType.LowerThan' offset' 1' "<");                        case '=':                          return ReadChar(LexemType.Equal' "=");                        case '>':                          if (Read() && _last == '=')                              return ReadChar(LexemType.GreaterEqual' ">=");                            return new Lexem(LexemType.GreaterThan' offset' 1' ">");                        case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case '_':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          var symbolBuffer = new StringBuilder();                            do                          {                              symbolBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last >= 'A' && _last <= 'Z' ||                                              _last >= 'a' && _last <= 'z' ||                                              _last == '_'));                            return new Lexem(LexemType.Symbol' offset' symbolBuffer.Length' symbolBuffer.ToString());                        case '|':                          if (Read() && _last == '|')                              return ReadChar(LexemType.DoublePipe' "||");                            _next = _last;                          _last = '|';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '[':                          return ReadChar(LexemType.BracketBegin' "[");                        case ']':                          return ReadChar(LexemType.BracketEnd' "]");                        case '\'':                      case '"':                          var stringBuffer = new StringBuilder();                          var end = _last;                            while (Read() && _last != end)                          {                              if (_last != _escape || Read())                                  stringBuffer.Append(_last);                          }                            if (_eof)                              return new Lexem(LexemType.None' offset' stringBuffer.Length + 1' Lexer.UnfinishedString);                            Read();                            return new Lexem(LexemType.String' offset' stringBuffer.Length' stringBuffer.ToString());                        default:                          return new Lexem(LexemType.None' offset' 1' Lexer.UnexpectedCharacter);                  }
Magic Number,Cottle.Parsers.Forward,Lexer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Forward\Lexer.cs,ReadBlock,The following statement contains a magic number: switch (_last)                  {                      case '\n':                      case '\r':                      case '\t':                      case ' ':                          while (_last <= ' ' && Read())                          {                          }                            break;                        case '!':                          if (Read() && _last == '=')                              return ReadChar(LexemType.NotEqual' "!=");                            return new Lexem(LexemType.Bang' offset' 2' "!");                        case '%':                          return ReadChar(LexemType.Percent' "%");                        case '&':                          if (Read() && _last == '&')                              return ReadChar(LexemType.DoubleAmpersand' "&&");                            _next = _last;                          _last = '&';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '(':                          return ReadChar(LexemType.ParenthesisBegin' "(");                        case ')':                          return ReadChar(LexemType.ParenthesisEnd' ")");                        case '*':                          return ReadChar(LexemType.Star' "*");                        case '+':                          return ReadChar(LexemType.Plus' "+");                        case ''':                          return ReadChar(LexemType.Comma' "'");                        case '-':                          return ReadChar(LexemType.Minus' "-");                        case '.':                          return ReadChar(LexemType.Dot' ".");                        case '/':                          return ReadChar(LexemType.Slash' "/");                        case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          var numberBuffer = new StringBuilder();                          var dot = false;                            do                          {                              dot |= _last == '.';                                numberBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last == '.' && !dot));                            return new Lexem(LexemType.Number' offset' numberBuffer.Length' numberBuffer.ToString());                        case ':':                          return ReadChar(LexemType.Colon' ":");                        case '<':                          if (Read() && _last == '=')                              return ReadChar(LexemType.LowerEqual' "<=");                            return new Lexem(LexemType.LowerThan' offset' 1' "<");                        case '=':                          return ReadChar(LexemType.Equal' "=");                        case '>':                          if (Read() && _last == '=')                              return ReadChar(LexemType.GreaterEqual' ">=");                            return new Lexem(LexemType.GreaterThan' offset' 1' ">");                        case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case '_':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          var symbolBuffer = new StringBuilder();                            do                          {                              symbolBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last >= 'A' && _last <= 'Z' ||                                              _last >= 'a' && _last <= 'z' ||                                              _last == '_'));                            return new Lexem(LexemType.Symbol' offset' symbolBuffer.Length' symbolBuffer.ToString());                        case '|':                          if (Read() && _last == '|')                              return ReadChar(LexemType.DoublePipe' "||");                            _next = _last;                          _last = '|';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '[':                          return ReadChar(LexemType.BracketBegin' "[");                        case ']':                          return ReadChar(LexemType.BracketEnd' "]");                        case '\'':                      case '"':                          var stringBuffer = new StringBuilder();                          var end = _last;                            while (Read() && _last != end)                          {                              if (_last != _escape || Read())                                  stringBuffer.Append(_last);                          }                            if (_eof)                              return new Lexem(LexemType.None' offset' stringBuffer.Length + 1' Lexer.UnfinishedString);                            Read();                            return new Lexem(LexemType.String' offset' stringBuffer.Length' stringBuffer.ToString());                        default:                          return new Lexem(LexemType.None' offset' 1' Lexer.UnexpectedCharacter);                  }
Magic Number,Cottle.Parsers.Forward,Lexer,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Parsers\Forward\Lexer.cs,ReadBlock,The following statement contains a magic number: switch (_last)                  {                      case '\n':                      case '\r':                      case '\t':                      case ' ':                          while (_last <= ' ' && Read())                          {                          }                            break;                        case '!':                          if (Read() && _last == '=')                              return ReadChar(LexemType.NotEqual' "!=");                            return new Lexem(LexemType.Bang' offset' 2' "!");                        case '%':                          return ReadChar(LexemType.Percent' "%");                        case '&':                          if (Read() && _last == '&')                              return ReadChar(LexemType.DoubleAmpersand' "&&");                            _next = _last;                          _last = '&';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '(':                          return ReadChar(LexemType.ParenthesisBegin' "(");                        case ')':                          return ReadChar(LexemType.ParenthesisEnd' ")");                        case '*':                          return ReadChar(LexemType.Star' "*");                        case '+':                          return ReadChar(LexemType.Plus' "+");                        case ''':                          return ReadChar(LexemType.Comma' "'");                        case '-':                          return ReadChar(LexemType.Minus' "-");                        case '.':                          return ReadChar(LexemType.Dot' ".");                        case '/':                          return ReadChar(LexemType.Slash' "/");                        case '0':                      case '1':                      case '2':                      case '3':                      case '4':                      case '5':                      case '6':                      case '7':                      case '8':                      case '9':                          var numberBuffer = new StringBuilder();                          var dot = false;                            do                          {                              dot |= _last == '.';                                numberBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last == '.' && !dot));                            return new Lexem(LexemType.Number' offset' numberBuffer.Length' numberBuffer.ToString());                        case ':':                          return ReadChar(LexemType.Colon' ":");                        case '<':                          if (Read() && _last == '=')                              return ReadChar(LexemType.LowerEqual' "<=");                            return new Lexem(LexemType.LowerThan' offset' 1' "<");                        case '=':                          return ReadChar(LexemType.Equal' "=");                        case '>':                          if (Read() && _last == '=')                              return ReadChar(LexemType.GreaterEqual' ">=");                            return new Lexem(LexemType.GreaterThan' offset' 1' ">");                        case 'A':                      case 'B':                      case 'C':                      case 'D':                      case 'E':                      case 'F':                      case 'G':                      case 'H':                      case 'I':                      case 'J':                      case 'K':                      case 'L':                      case 'M':                      case 'N':                      case 'O':                      case 'P':                      case 'Q':                      case 'R':                      case 'S':                      case 'T':                      case 'U':                      case 'V':                      case 'W':                      case 'X':                      case 'Y':                      case 'Z':                      case '_':                      case 'a':                      case 'b':                      case 'c':                      case 'd':                      case 'e':                      case 'f':                      case 'g':                      case 'h':                      case 'i':                      case 'j':                      case 'k':                      case 'l':                      case 'm':                      case 'n':                      case 'o':                      case 'p':                      case 'q':                      case 'r':                      case 's':                      case 't':                      case 'u':                      case 'v':                      case 'w':                      case 'x':                      case 'y':                      case 'z':                          var symbolBuffer = new StringBuilder();                            do                          {                              symbolBuffer.Append(_last);                          } while (Read() && (_last >= '0' && _last <= '9' ||                                              _last >= 'A' && _last <= 'Z' ||                                              _last >= 'a' && _last <= 'z' ||                                              _last == '_'));                            return new Lexem(LexemType.Symbol' offset' symbolBuffer.Length' symbolBuffer.ToString());                        case '|':                          if (Read() && _last == '|')                              return ReadChar(LexemType.DoublePipe' "||");                            _next = _last;                          _last = '|';                            return new Lexem(LexemType.None' offset' 2' Lexer.UnknownOperator);                        case '[':                          return ReadChar(LexemType.BracketBegin' "[");                        case ']':                          return ReadChar(LexemType.BracketEnd' "]");                        case '\'':                      case '"':                          var stringBuffer = new StringBuilder();                          var end = _last;                            while (Read() && _last != end)                          {                              if (_last != _escape || Read())                                  stringBuffer.Append(_last);                          }                            if (_eof)                              return new Lexem(LexemType.None' offset' stringBuffer.Length + 1' Lexer.UnfinishedString);                            Read();                            return new Lexem(LexemType.String' offset' stringBuffer.Length' stringBuffer.ToString());                        default:                          return new Lexem(LexemType.None' offset' 1' Lexer.UnexpectedCharacter);                  }
Magic Number,Cottle.Stores,SimpleStore,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Stores\SimpleStore.cs,Leave,The following statement contains a magic number: stack.Count < 2
Missing Default,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileCommand,The following switch statement is missing a default case: switch (command.Type)              {                  case CommandType.AssignFunction:                      EmitLoadStore();                      EmitLoadValue(command.Name);                        EmitLoadValue(new FunctionValue(new DynamicFunction(command.Arguments' command.Body)));                      EmitStoreSetCall(command.Mode);                        break;                    case CommandType.AssignRender:                      // Prepare new buffer to store sub-rendering                      var buffer = LocalReserve<TextWriter>();                        _generator.Emit(OpCodes.Newobj' DynamicResolver.Constructor<Func<StringWriter>>(() => new StringWriter()));                      _generator.Emit(OpCodes.Stloc' buffer);                        // Load function' empty arguments array' store and text writer onto stack                      EmitLoadValue(new FunctionValue(new DynamicFunction(Array.Empty<string>()' command.Body)));                        _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Property<Func<Value' IFunction>>(v => v.AsFunction).GetGetMethod());                        EmitLoadStore();                      EmitLoadArrayEmpty<Value>();                        _generator.Emit(OpCodes.Ldloc' buffer);                        EmitCallFunctionExecute();                        _generator.Emit(OpCodes.Pop);                        // Convert buffer into string and set to store                      EmitLoadStore();                      EmitLoadValue(command.Name);                        _generator.Emit(OpCodes.Ldloc' buffer);                      _generator.Emit(OpCodes.Callvirt' DynamicResolver.Method<Func<StringWriter' string>>(w => w.ToString()));                        LocalRelease<Value>(buffer);                        _generator.Emit(OpCodes.Newobj' DynamicResolver.Constructor<Func<string' Value>>(s => new StringValue(s)));                        EmitStoreSetCall(command.Mode);                        break;                    case CommandType.AssignValue:                      CompileExpression(command.Operand);                        operand = LocalReserve<Value>();                        _generator.Emit(OpCodes.Stloc' operand);                        EmitLoadStore();                      EmitLoadValue(command.Name);                        _generator.Emit(OpCodes.Ldloc' operand);                        LocalRelease<Value>(operand);                      EmitStoreSetCall(command.Mode);                        break;                    case CommandType.Composite:                      CompileCommand(command.Body' exit' depth);                      CompileCommand(command.Next' exit' depth);                        break;                    case CommandType.Dump:                      CompileExpression(command.Operand);                        operand = LocalReserve<Value>();                        _generator.Emit(OpCodes.Stloc' operand);                        EmitLoadOutput();                        _generator.Emit(OpCodes.Ldloc' operand);                      _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Method<Action<TextWriter' object>>((w' v) => w.Write(v)));                        LocalRelease<Value>(operand);                        break;                    case CommandType.Echo:                      CompileExpression(command.Operand);                        operand = LocalReserve<Value>();                        _generator.Emit(OpCodes.Stloc' operand);                        EmitLoadOutput();                        _generator.Emit(OpCodes.Ldloc' operand);                      _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Property<Func<Value' string>>(v => v.AsString).GetGetMethod());                        LocalRelease<Value>(operand);                        EmitCallWriteString();                        break;                    case CommandType.For:                      var empty = _generator.DefineLabel();                      jump = _generator.DefineLabel();                      skip = _generator.DefineLabel();                        // Evaluate operand into fields map                      CompileExpression(command.Operand);                      EmitCallValueFields();                        var fields = LocalReserve<IMap>();                        _generator.Emit(OpCodes.Stloc' fields);                        // Get number of fields                      _generator.Emit(OpCodes.Ldloc' fields);                      _generator.Emit(OpCodes.Callvirt' DynamicResolver.Property<Func<IMap' int>>(m => m.Count).GetGetMethod());                      _generator.Emit(OpCodes.Brfalse' empty);                        // Evaluate command for "not empty" case                      _generator.Emit(OpCodes.Ldloc' fields);                      _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Method<Func<IMap' IEnumerator<KeyValuePair<Value' Value>>>>(m => m.GetEnumerator()));                        LocalRelease<IMap>(fields);                        var enumerator = LocalReserve<IEnumerator<KeyValuePair<Value' Value>>>();                        _generator.Emit(OpCodes.Stloc' enumerator);                        // Fetch next enumerator element or end loop                      _generator.MarkLabel(jump);                      _generator.Emit(OpCodes.Ldloc' enumerator);                      _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Method<Func<IEnumerator<KeyValuePair<Value' Value>>' bool>>(e => e.MoveNext()));                      _generator.Emit(OpCodes.Brfalse' skip);                      _generator.Emit(OpCodes.Ldloc' enumerator);                        LocalRelease<IEnumerator<KeyValuePair<Value' Value>>>(enumerator);                        _generator.Emit(OpCodes.Callvirt'                          DynamicResolver                              .Property<Func<IEnumerator<KeyValuePair<Value' Value>>' KeyValuePair<Value' Value>>>(e =>                                  e.Current).GetGetMethod());                        var pair = LocalReserve<KeyValuePair<Value' Value>>();                        _generator.Emit(OpCodes.Stloc' pair);                        // Enter loop scope                      EmitStoreEnter();                        // Set current element key if required                      if (!string.IsNullOrEmpty(command.Key))                      {                          EmitLoadStore();                          EmitLoadValue(command.Key);                            _generator.Emit(OpCodes.Ldloca' pair);                          _generator.Emit(OpCodes.Call'                              DynamicResolver.Property<Func<KeyValuePair<Value' Value>' Value>>(p => p.Key).GetGetMethod());                            EmitStoreSetCall(StoreMode.Local);                      }                        // Set current element value                      EmitLoadStore();                      EmitLoadValue(command.Name);                        _generator.Emit(OpCodes.Ldloca' pair);                      _generator.Emit(OpCodes.Call'                          DynamicResolver.Property<Func<KeyValuePair<Value' Value>' Value>>(p => p.Value).GetGetMethod());                        LocalRelease<KeyValuePair<Value' Value>>(pair);                      EmitStoreSetCall(StoreMode.Local);                        // Evaluate body and restart cycle                      CompileCommand(command.Body' exit' depth + 1);                      EmitStoreLeave();                        _generator.Emit(OpCodes.Br' jump);                        // Evaluate command for "empty" case                      _generator.MarkLabel(empty);                        if (command.Next != null)                      {                          EmitStoreEnter();                          CompileCommand(command.Next' exit' depth + 1);                          EmitStoreLeave();                      }                        // Mark end of statement                      _generator.MarkLabel(skip);                        break;                    case CommandType.If:                      skip = _generator.DefineLabel();                        // Emit conditional branches                      for (; command != null && command.Type == CommandType.If; command = command.Next)                      {                          jump = _generator.DefineLabel();                            // Evaluate branch condition' jump to next if false                          CompileExpression(command.Operand);                          EmitCallValueAsBoolean();                            _generator.Emit(OpCodes.Brfalse' jump);                            // Execute branch command and jump sibling statements                          EmitStoreEnter();                          CompileCommand(command.Body' exit' depth + 1);                          EmitStoreLeave();                            _generator.Emit(OpCodes.Br' skip);                          _generator.MarkLabel(jump);                      }                        // Emit fallback branch if any                      if (command != null)                      {                          EmitStoreEnter();                          CompileCommand(command' exit' depth + 1);                          EmitStoreLeave();                      }                        // Mark end of statement                      _generator.MarkLabel(skip);                        break;                    case CommandType.Literal:                      EmitLoadOutput();                        _generator.Emit(OpCodes.Ldstr' command.Text);                        EmitCallWriteString();                        break;                    case CommandType.Return:                      CompileExpression(command.Operand);                        // Leave all opened scopes if any                      if (depth > 0)                      {                          _generator.Emit(OpCodes.Ldc_I4' depth);                            var counter = LocalReserve<int>();                            _generator.Emit(OpCodes.Stloc' counter);                            jump = _generator.DefineLabel();                            _generator.MarkLabel(jump);                            EmitStoreLeave();                            _generator.Emit(OpCodes.Ldloc' counter);                          _generator.Emit(OpCodes.Ldc_I4_1);                          _generator.Emit(OpCodes.Sub);                          _generator.Emit(OpCodes.Stloc' counter);                          _generator.Emit(OpCodes.Ldloc' counter);                          _generator.Emit(OpCodes.Brtrue' jump);                            LocalRelease<int>(counter);                      }                        _generator.Emit(OpCodes.Br' exit);                        break;                    case CommandType.While:                      jump = _generator.DefineLabel();                      skip = _generator.DefineLabel();                        // Branch to condition before first body execution                      _generator.Emit(OpCodes.Br' skip);                        // Execute loop command                      _generator.MarkLabel(jump);                        EmitStoreEnter();                      CompileCommand(command.Body' exit' depth + 1);                      EmitStoreLeave();                        // Evaluate loop condition' restart cycle if true                      _generator.MarkLabel(skip);                        CompileExpression(command.Operand);                      EmitCallValueAsBoolean();                        _generator.Emit(OpCodes.Brtrue' jump);                        break;              }
Missing Default,Cottle.Documents.Dynamic,DynamicCompiler,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Documents\Dynamic\DynamicCompiler.cs,CompileExpression,The following switch statement is missing a default case: switch (expression.Type)              {                  case ExpressionType.Access:                      success = _generator.DefineLabel();                        // Evaluate source expression and get fields                      CompileExpression(expression.Source);                      EmitCallValueFields();                        var fields = LocalReserve<IMap>();                        _generator.Emit(OpCodes.Stloc' fields);                        // Evaluate subscript expression                      CompileExpression(expression.Subscript);                        value = LocalReserve<Value>();                        _generator.Emit(OpCodes.Stloc' value);                        // Use subscript to get value from fields                      var tryGetFromValue = typeof(IMap).GetMethod("TryGet") ?? throw new InvalidOperationException();                        _generator.Emit(OpCodes.Ldloc' fields);                      _generator.Emit(OpCodes.Ldloc' value);                      _generator.Emit(OpCodes.Ldloca' value);                      _generator.Emit(OpCodes.Callvirt' tryGetFromValue);                      _generator.Emit(OpCodes.Brtrue' success);                        // Emit void value on error                      EmitLoadVoid();                        _generator.Emit(OpCodes.Stloc' value);                        // Push value on stack                      _generator.MarkLabel(success);                      _generator.Emit(OpCodes.Ldloc' value);                        LocalRelease<Value>(value);                        break;                    case ExpressionType.Constant:                      EmitLoadValue(expression.Value);                        break;                    case ExpressionType.Invoke:                      var failure = _generator.DefineLabel();                      success = _generator.DefineLabel();                        // Evaluate source expression as a function                      CompileExpression(expression.Source);                        _generator.Emit(OpCodes.Callvirt'                          DynamicResolver.Property<Func<Value' IFunction>>(v => v.AsFunction).GetGetMethod());                        var function = LocalReserve<IFunction>();                        _generator.Emit(OpCodes.Stloc' function);                      _generator.Emit(OpCodes.Ldloc' function);                      _generator.Emit(OpCodes.Brfalse' failure);                        // Create array to store evaluated values                      _generator.Emit(OpCodes.Ldc_I4' expression.Arguments.Length);                      _generator.Emit(OpCodes.Newarr' typeof(Value));                        arguments = LocalReserve<Value[]>();                        _generator.Emit(OpCodes.Stloc' arguments);                        // Evaluate arguments and store into array                      for (var i = 0; i < expression.Arguments.Length; ++i)                      {                          CompileExpression(expression.Arguments[i]);                            value = LocalReserve<Value>();                            _generator.Emit(OpCodes.Stloc' value);                          _generator.Emit(OpCodes.Ldloc' arguments);                          _generator.Emit(OpCodes.Ldc_I4' i);                          _generator.Emit(OpCodes.Ldloc' value);                          _generator.Emit(OpCodes.Stelem_Ref);                            LocalRelease<Value>(value);                      }                        // Invoke function delegate within exception block                      _generator.Emit(OpCodes.Ldloc' function);                        LocalRelease<IFunction>(function);                      EmitLoadStore();                        _generator.Emit(OpCodes.Ldloc' arguments);                        LocalRelease<Value[]>(arguments);                      EmitLoadOutput();                        value = LocalReserve<Value>();                        EmitCallFunctionExecute();                        _generator.Emit(OpCodes.Stloc' value);                      _generator.Emit(OpCodes.Br_S' success);                        // Emit void value on error                      _generator.MarkLabel(failure);                        EmitLoadVoid();                        _generator.Emit(OpCodes.Stloc' value);                        // Value is already available on stack                      _generator.MarkLabel(success);                      _generator.Emit(OpCodes.Ldloc' value);                        LocalRelease<Value>(value);                        break;                    case ExpressionType.Map:                      // Create array to store evaluated pairs                      _generator.Emit(OpCodes.Ldc_I4' expression.Elements.Length);                      _generator.Emit(OpCodes.Newarr' typeof(KeyValuePair<Value' Value>));                        arguments = LocalReserve<KeyValuePair<Value' Value>[]>();                        _generator.Emit(OpCodes.Stloc' arguments);                        // Evaluate elements and store into array                      var constructor = DynamicResolver.Constructor<Func<Value' Value' KeyValuePair<Value' Value>>>((k' v) =>                          new KeyValuePair<Value' Value>(k' v));                        for (var i = 0; i < expression.Elements.Length; ++i)                      {                          CompileExpression(expression.Elements[i].Key);                            var key = LocalReserve<Value>();                            _generator.Emit(OpCodes.Stloc' key);                            CompileExpression(expression.Elements[i].Value);                            value = LocalReserve<Value>();                            _generator.Emit(OpCodes.Stloc' value);                          _generator.Emit(OpCodes.Ldloc' arguments);                          _generator.Emit(OpCodes.Ldc_I4' i);                          _generator.Emit(OpCodes.Ldelema' typeof(KeyValuePair<Value' Value>));                          _generator.Emit(OpCodes.Ldloc' key);                          _generator.Emit(OpCodes.Ldloc' value);                          _generator.Emit(OpCodes.Newobj' constructor);                          _generator.Emit(OpCodes.Stobj' typeof(KeyValuePair<Value' Value>));                            LocalRelease<Value>(key);                          LocalRelease<Value>(value);                      }                        // Create value from array                      constructor =                          DynamicResolver.Constructor<Func<IEnumerable<KeyValuePair<Value' Value>>' Value>>(f =>                              new MapValue(f));                        _generator.Emit(OpCodes.Ldloc' arguments);                      _generator.Emit(OpCodes.Newobj' constructor);                        LocalRelease<KeyValuePair<Value' Value>[]>(arguments);                        break;                    case ExpressionType.Symbol:                      success = _generator.DefineLabel();                        // Get variable from scope                      EmitLoadStore();                      EmitLoadValue(expression.Value);                        value = LocalReserve<Value>();                        var tryGetFromStore = typeof(IStore).GetMethod("TryGet") ?? throw new InvalidOperationException();                        _generator.Emit(OpCodes.Ldloca' value);                      _generator.Emit(OpCodes.Callvirt' tryGetFromStore);                      _generator.Emit(OpCodes.Brtrue' success);                        // Emit void value on error                      EmitLoadVoid();                        _generator.Emit(OpCodes.Stloc' value);                        // Push value on stack                      _generator.MarkLabel(success);                      _generator.Emit(OpCodes.Ldloc' value);                        LocalRelease<Value>(value);                        break;                    case ExpressionType.Void:                      EmitLoadVoid();                        break;              }
Missing Default,Cottle.Stores,SimpleStore,C:\research\architectureSmells\repos\r3c_Cottle\src\Cottle\Stores\SimpleStore.cs,Set,The following switch statement is missing a default case: switch (mode)              {                  case StoreMode.Global:                      if (stack.Count > 0)                          stack.Pop();                        break;                    case StoreMode.Local:                      // Lazily create stack frames to current depth                      while (_depth > _frames.Count)                          _frames.Push(new HashSet<Value>());                        // Erase symbol if it previously existed in current stack frame                      if (_frames.Count > 0 && !_frames.Peek().Add(symbol))                          stack.Pop();                        break;              }
