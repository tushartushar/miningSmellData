Implementation smell,Namespace,Class,File,Method,Description
Long Method,MiniHttpd,HttpClient,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,OnReceiveData,The method has 117 lines of code.
Long Method,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has 168 lines of code.
Long Method,MiniHttpd,HttpResponse,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The method has 107 lines of code.
Complex Method,MiniHttpd.Aspx,AspxAppDirectory,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxAppDirectory.cs,LoadWebConfig,Cyclomatic complexity of the method is 11
Complex Method,MiniHttpd.Aspx,AspxWebServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxWebServer.cs,SendFileOrIndex,Cyclomatic complexity of the method is 9
Complex Method,MiniHttpd,ByteRange,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ByteRange.cs,ByteRange,Cyclomatic complexity of the method is 10
Complex Method,MiniHttpd,HttpWebServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\HttpWebServer.cs,NavigateToUrl,Cyclomatic complexity of the method is 13
Complex Method,MiniHttpd,IndexPageEx,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,Cyclomatic complexity of the method is 8
Complex Method,MiniHttpd,ResourceEntry,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,WriteHtml,Cyclomatic complexity of the method is 14
Complex Method,MiniHttpd,HttpClient,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,OnReceiveData,Cyclomatic complexity of the method is 14
Complex Method,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,PostProcessHeaders,Cyclomatic complexity of the method is 9
Complex Method,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,Cyclomatic complexity of the method is 26
Complex Method,MiniHttpd,HttpResponse,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,Cyclomatic complexity of the method is 22
Complex Method,MiniHttpd,UriQuery,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\UriQuery.cs,UriQuery,Cyclomatic complexity of the method is 9
Long Parameter List,MiniHttpd,IndexPage,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPage.cs,PrintBody,The method has 5 parameters. Parameters: writer' request' directory' dirs' files
Long Parameter List,MiniHttpd,IndexPageEx,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,The method has 5 parameters. Parameters: writer' request' directory' dirs' files
Long Statement,MiniHttpd.Aspx,AspxAppDirectory,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxAppDirectory.cs,LoadWebConfig,The length of the statement  "								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' node.Attributes["type"].Value' validate); " is 141.
Long Statement,MiniHttpd,DriveDirectory,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\DriveDirectory.cs,GetName,The length of the statement  "			if(path[path.Length-1] == System.IO.Path.DirectorySeparatorChar || path[path.Length-1] == System.IO.Path.AltDirectorySeparatorChar) " is 131.
Long Statement,MiniHttpd,HttpWebServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\HttpWebServer.cs,IsValidFilename,The length of the statement  "			if(filename.IndexOfAny(InvalidFileChars) >= 0 || filename.IndexOfAny(Path.InvalidPathChars) >= 0 || filename.IndexOf("..") >= 0) " is 128.
Long Statement,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,PostProcessHeaders,The length of the statement  "			// Try to determine the time difference between the client and this computer; adjust ifModifiedSince and ifUnmodifiedSince accordingly " is 134.
Long Statement,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,SendResponse,The length of the statement  "				string message = response.ResponseCode + " " + (errorMessage != null ? errorMessage : StatusCodes.GetDescription(response.ResponseCode)); " is 137.
Long Statement,MiniHttpd,HttpResponse,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,BeginImmediateResponse,The length of the statement  "//					throw new HttpRequestException("500"' "The content length must be set or the transfer encoding must be set to 'chunked' prior to beginning a response."); " is 160.
Long Statement,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,GetHostUri,The length of the statement  "//						ub.Port = int.Parse(hostSplit[1]' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture); " is 136.
Long Statement,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,InitializeLog,The length of the statement  "			// Initialize the log to output to the console if it is available on the platform' otherwise initialize to null stream writer. " is 126.
Empty Catch Block,MiniHttpd,ContentTypes,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ContentTypes.cs,GetExtensionType,The method has an empty catch block.
Empty Catch Block,MiniHttpd,ContentTypes,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ContentTypes.cs,GetExtensionType,The method has an empty catch block.
Empty Catch Block,MiniHttpd,IndexPageEx,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,The method has an empty catch block.
Empty Catch Block,MiniHttpd,ResourceEntry,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,WriteHtml,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,Stop,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,Stop,The method has an empty catch block.
Magic Number,MiniHttpd.Aspx,WorkerRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\WorkerRequest.cs,SendResponseFromFile,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,MiniHttpd.Aspx,WorkerRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\WorkerRequest.cs,SendResponseFromFile,The following statement contains a magic number: SendResponseFromFile(new FileStream(handle' FileAccess.Read' false' 1024)' offset' length);
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,BytesToHex,The following statement contains a magic number: System.Text.StringBuilder sb = new StringBuilder(bytes.Length*2);
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: hex.Length % 2 != 0
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: byte[] bytes = new byte[hex.Length/2];
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: byte b = (byte)(GetNibble(hex[i*2]) << 4);
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: byte b = (byte)(GetNibble(hex[i*2]) << 4);
Magic Number,MiniHttpd,BasicAuthenticator,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: b &= GetNibble(hex[i*2+1]);
Magic Number,MiniHttpd,ByteRange,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ByteRange.cs,ByteRange,The following statement contains a magic number: ranges.Length != 2
Magic Number,MiniHttpd,ChunkedStream,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,ChunkedStream,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,ChunkedStream,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,DriveDirectory,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\DriveDirectory.cs,GetName,The following statement contains a magic number: path.Length == 2 && path[1] == ':'
Magic Number,MiniHttpd,IndexPageEx,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,MakeLinkPath,The following statement contains a magic number: request.Uri.Port != 80
Magic Number,MiniHttpd,HttpClient,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,OnReceiveData,The following statement contains a magic number: int len = FindByte(buffer' bufPos' dataLen' 10);
Magic Number,MiniHttpd,HttpClient,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,server_OneHertzTick,The following statement contains a magic number: idleTime += 1000;
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,SendResponse,The following statement contains a magic number: MemoryStream stream = new MemoryStream(512);
Magic Number,MiniHttpd,HttpResponse,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: responseContent.Length < 1024*4
Magic Number,MiniHttpd,HttpResponse,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: responseContent.Length < 1024*4
Magic Number,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The following statement contains a magic number: ServerUri = new Uri("http://" +  				Dns.GetHostName() +  				(port != 80 ? ":" + port.ToString(System.Globalization.CultureInfo.InvariantCulture) : "")  				);
Magic Number,MiniHttpd,HttpServer,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The following statement contains a magic number: idleTimer = new Timer(new TimerCallback(TimerCallback)' null' 0' 1000);
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)1024).ToString("0.00"' CultureInfo.InvariantCulture) + " KB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*0.96
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,UrlEncoding,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,InitUrlStrings,The following statement contains a magic number: string[] urlEncStrings = new string[256];
Magic Number,MiniHttpd,UrlEncoding,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,InitUrlStrings,The following statement contains a magic number: i < 255
Magic Number,MiniHttpd,UrlEncoding,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,IsSafe,The following statement contains a magic number: ch > 255
Missing Default,MiniHttpd.Aspx,AspxAppDirectory,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxAppDirectory.cs,LoadWebConfig,The following switch statement is missing a default case: switch(node.Name)  						{  							case "add":  							{  								if(node.Attributes["verb"] == null)  									break;  								if(node.Attributes["path"] == null)  									break;  								if(node.Attributes["type"] == null)  									break;    								bool validate = false;  								  								try  								{  									if(node.Attributes["validate"] != null)  										validate = bool.Parse(node.Attributes["validate"].Value);  								}  								catch(FormatException)  								{  									validate = false;  								}    								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' node.Attributes["type"].Value' validate);  								httpHandlers.Remove(handler);  								httpHandlers.Add(handler);    								break;  							}  							case "remove":  							{  								if(node.Attributes["verb"] == null)  									break;  								if(node.Attributes["path"] == null)  									break;    								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' null' false);  								httpHandlers.Remove(handler);    								break;  							}  							case "clear":  							{  								httpHandlers.Clear();    								break;  							}  						}
Missing Default,MiniHttpd,ResourceEntry,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,WriteHtml,The following switch statement is missing a default case: switch(column)  					{  						case ResourceColumn.Created:  							if(path != null)  								if(Created != DateTime.MinValue)  									writer.Write(Created.ToString());  							break;  						case ResourceColumn.Modified:  							if(path != null)  								if(Modified != DateTime.MinValue)  									writer.Write(Modified.ToString());  							break;  						case ResourceColumn.Size:  							if(!isDir)  								if(path != null)  									if(Size != -1)  										writer.Write(ReadableDataLength.Calculate(Size));  							break;  						case ResourceColumn.Name:  							writer.WriteLine("<a href=\"" + UrlEncoding.Encode(resource.Name) +  								(isDir ? "/\">[" : "\">") + resource.Name + (isDir ? "]" : "") +"</a>");  							break;  					}
Missing Default,MiniHttpd,UrlEncoding,D:\research\architectureSmells\repos1\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,IsSafe,The following switch statement is missing a default case: switch(ch)  			{  				case '\'':  				case '(':  				case ')':  				case'[':  				case']':  				case '*':  				case '-':  				case '.':  				case '!':  				case '_':  					return true;  			}
