Implementation smell,Namespace,Class,File,Method,Description
Long Method,MiniHttpd,HttpClient,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,OnReceiveData,The method has 117 lines of code.
Long Method,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has 168 lines of code.
Long Method,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The method has 107 lines of code.
Complex Method,MiniHttpd,HttpWebServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\HttpWebServer.cs,NavigateToUrl,Cyclomatic complexity of the method is 12
Complex Method,MiniHttpd,IndexPageEx,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,Cyclomatic complexity of the method is 8
Complex Method,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,PostProcessHeaders,Cyclomatic complexity of the method is 9
Complex Method,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,Cyclomatic complexity of the method is 20
Complex Method,MiniHttpd,UriQuery,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\UriQuery.cs,UriQuery,Cyclomatic complexity of the method is 8
Long Parameter List,MiniHttpd,IndexPage,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPage.cs,PrintBody,The method has 5 parameters. Parameters: writer' request' directory' dirs' files
Long Parameter List,MiniHttpd,IndexPageEx,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,The method has 5 parameters. Parameters: writer' request' directory' dirs' files
Long Statement,MiniHttpd.Aspx,AspxAppDirectory,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxAppDirectory.cs,LoadWebConfig,The length of the statement  "								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' node.Attributes["type"].Value' validate); " is 141.
Long Statement,MiniHttpd,DriveDirectory,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\DriveDirectory.cs,GetName,The length of the statement  "			if(path[path.Length-1] == System.IO.Path.DirectorySeparatorChar || path[path.Length-1] == System.IO.Path.AltDirectorySeparatorChar) " is 131.
Long Statement,MiniHttpd,HttpWebServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\HttpWebServer.cs,IsValidFilename,The length of the statement  "			if(filename.IndexOfAny(InvalidFileChars) >= 0 || filename.IndexOfAny(Path.InvalidPathChars) >= 0 || filename.IndexOf("..") >= 0) " is 128.
Long Statement,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,PostProcessHeaders,The length of the statement  "			// Try to determine the time difference between the client and this computer; adjust ifModifiedSince and ifUnmodifiedSince accordingly " is 134.
Long Statement,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,SendResponse,The length of the statement  "				string message = response.ResponseCode + " " + (errorMessage != null ? errorMessage : StatusCodes.GetDescription(response.ResponseCode)); " is 137.
Long Statement,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,BeginImmediateResponse,The length of the statement  "//					throw new HttpRequestException("500"' "The content length must be set or the transfer encoding must be set to 'chunked' prior to beginning a response."); " is 160.
Long Statement,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,GetHostUri,The length of the statement  "//						ub.Port = int.Parse(hostSplit[1]' System.Globalization.NumberStyles.Integer' System.Globalization.CultureInfo.InvariantCulture); " is 136.
Long Statement,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,InitializeLog,The length of the statement  "			// Initialize the log to output to the console if it is available on the platform' otherwise initialize to null stream writer. " is 126.
Empty Catch Block,MiniHttpd,ContentTypes,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ContentTypes.cs,GetExtensionType,The method has an empty catch block.
Empty Catch Block,MiniHttpd,ContentTypes,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ContentTypes.cs,GetExtensionType,The method has an empty catch block.
Empty Catch Block,MiniHttpd,IndexPageEx,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,PrintBody,The method has an empty catch block.
Empty Catch Block,MiniHttpd,ResourceEntry,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,WriteHtml,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,Stop,The method has an empty catch block.
Empty Catch Block,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,Stop,The method has an empty catch block.
Magic Number,MiniHttpd.Aspx,WorkerRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\WorkerRequest.cs,SendResponseFromFile,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,MiniHttpd.Aspx,WorkerRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\WorkerRequest.cs,SendResponseFromFile,The following statement contains a magic number: SendResponseFromFile(new FileStream(handle' FileAccess.Read' false' 1024)' offset' length);
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,BytesToHex,The following statement contains a magic number: System.Text.StringBuilder sb = new StringBuilder(bytes.Length*2);
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: if(hex.Length % 2 != 0)  				throw new ArgumentException("String must have an even length"' "hex");
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: byte[] bytes = new byte[hex.Length/2];
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: for(int i = 0; i < bytes.Length; i++)  			{  				byte b = (byte)(GetNibble(hex[i*2]) << 4);  				b &= GetNibble(hex[i*2+1]);  			}
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: for(int i = 0; i < bytes.Length; i++)  			{  				byte b = (byte)(GetNibble(hex[i*2]) << 4);  				b &= GetNibble(hex[i*2+1]);  			}
Magic Number,MiniHttpd,BasicAuthenticator,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\BasicAuthenticator.cs,HexToBytes,The following statement contains a magic number: for(int i = 0; i < bytes.Length; i++)  			{  				byte b = (byte)(GetNibble(hex[i*2]) << 4);  				b &= GetNibble(hex[i*2+1]);  			}
Magic Number,MiniHttpd,ByteRange,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ByteRange.cs,ByteRange,The following statement contains a magic number: if(ranges.Length != 2)  				throw new FormatException();
Magic Number,MiniHttpd,ChunkedStream,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,ChunkedStream,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,ChunkedStream,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ChunkedStream.cs,Write,The following statement contains a magic number: base.outputStream.Write(new byte[] {13' 10}' 0' 2);
Magic Number,MiniHttpd,DriveDirectory,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\DriveDirectory.cs,GetName,The following statement contains a magic number: if(path.Length == 2 && path[1] == ':')  				path = path + '\\';
Magic Number,MiniHttpd,IndexPageEx,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,MakeLinkPath,The following statement contains a magic number: if(request.Uri.Port != 80)  				sb.Append(":" + request.Uri.Port);
Magic Number,MiniHttpd,HttpClient,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,OnReceiveData,The following statement contains a magic number: lock(socket)  			{  				try  				{  					idleTime = 0;  					if(!isConnected)  						return;    					int dataLen = stream.EndRead(ar);    #if DUMP  					System.Diagnostics.Debug.Write(Encoding.Default.GetString(buffer' 0' dataLen));  					System.Diagnostics.Debug.WriteLine("+++++++++++++++++++++++");  #endif    					if(dataLen < 1)  					{  						Disconnect();  						return;  					}    					if(textBuf != null)  						if(textBuf.Length > 0x8000)  						{  							Disconnect();  							return;  						}    					for(int bufPos = 0; bufPos < dataLen; bufPos++)  					{  						if(request == null)  						{  							request = new HttpRequest(this);  							textBuf = new StringBuilder(buffer.Length);  						}    						if(request.Mode == HttpRequest.DataMode.Text)  						{  							int len = FindByte(buffer' bufPos' dataLen' 10);  							if(len != -1)  							{  								textBuf.Append(Encoding.Default.GetString(buffer' bufPos' len+1-bufPos));  								request.ProcessLine(textBuf.ToString().Trim('\r'' '\n'));  								textBuf.Length = 0;  								bufPos = len;  							}  							else  							{  								textBuf.Append(Encoding.Default.GetString(buffer' bufPos' dataLen - bufPos));  								bufPos = dataLen;  							}  						}    						if(request.Mode == HttpRequest.DataMode.Binary)  						{  							request.ProcessData(buffer' bufPos' dataLen - bufPos);  							bufPos = dataLen;  						}    						if(request.IsRequestFinished)  						{  							preventTimeout = true;  							bool forceDisconnect = false;  							try  							{  								server.OnRequestReceived(this' request);  							}  							catch(HttpRequestException e)  							{  								request.Response.ResponseCode = e.ResponseCode;  								//TODO: custom error messages' fix forceDisconnect prior to implementing HTTPS  								if(e.ResponseCode == "500")  									server.Log.WriteLine(e.ToString());  								forceDisconnect = true;  							}  							request.SendResponse();  							ConnectionMode modeTemp = request.ConnectionMode;    							string requestVer = request.HttpVersion;    							request.Dispose();  							request = null;  							idleTime = 0;  							preventTimeout = false;    							//TODO: don't disconnect 1.0... wget is being sending weird headers' do this workaround for now  							if(modeTemp == ConnectionMode.Close || forceDisconnect || requestVer == "1.0")  							{  								Disconnect();  								return;  							}  						}  					}    					if(isConnected)  						stream.BeginRead(buffer' 0' buffer.Length' new AsyncCallback(OnReceiveData)' this);  				}  				catch(SocketException)  				{  					Disconnect();  				}  				catch(IOException e)  				{  					Disconnect();  					if(!(e.InnerException is SocketException))  					{  #if !DEBUG  						server.Log.WriteLine("Error: " + e.ToString());  #else  						throw;  #endif  					}  				}  				catch(System.Threading.ThreadAbortException)  				{  					Disconnect();  				}  #if !DEBUG  				catch(Exception e)  				{  					server.Log.WriteLine("Error: " + e.ToString());  					Disconnect();  				}  #endif  			}
Magic Number,MiniHttpd,HttpClient,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpClient.cs,server_OneHertzTick,The following statement contains a magic number: idleTime += 1000;
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,ProcessLine,The following statement contains a magic number: switch(state)  			{  				case ProcessingState.RequestLine:  				{  					string[] protocol = line.Split(' ');  					if(protocol.Length != 3)  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					switch(protocol[0])  					{  						case "GET":  						case "POST":  						case "HEAD":  							method = protocol[0];  							break;  						case "PUT":  						case "DELETE":  						case "OPTIONS":  						case "TRACE":  						default:  							RequestError("501"' StatusCodes.GetDescription("501"));  							return;  					}    					if(protocol[1].Length > 2500)  					{  						RequestError("414"' StatusCodes.GetDescription("414"));  						return;  					}  					requestUri = protocol[1];    					if(!protocol[2].StartsWith("HTTP/") || !(protocol[2].Length > "HTTP/".Length))  					{  						RequestError("400"' "Invalid protocol string");  						return;  					}    					httpVersion = protocol[2].Substring("HTTP/".Length);    					date = DateTime.Now;    					connMode = httpVersion == "1.0" ? ConnectionMode.Close : ConnectionMode.KeepAlive;    					state = ProcessingState.Headers;  					break;  				}  				case ProcessingState.Headers:  				{  					if(headers.Count > maxHeaderLines)  					{  						RequestError("400"' "Maximum header line count exceeded");  						return;  					}    					if(line.Length == 0)  					{  						PostProcessHeaders();  						return;  					}    					int colonIndex = line.IndexOf(":");  					if(colonIndex <= 1)  						return;  					string val = line.Substring(colonIndex + 1).Trim();  					string name = line.Substring(0' colonIndex);    					try  					{  						headers.Add(name' val);  					}  					catch  					{  					}    					switch(name.ToLower(CultureInfo.InvariantCulture))  					{  						case "host":  							host = val;  							break;  						case "authorization":  						{  							if(val.Length < 6)  								break;    							string encoded = val.Substring(6' val.Length - 6);  							byte[] byteAuth;  							try  							{  								byteAuth = Convert.FromBase64String(encoded);  							}  							catch(FormatException)  							{  								break;  							}    							string[] strings = Encoding.UTF8.GetString(byteAuth).Split(':');  							if(strings.Length != 2)  								break;    							username = strings[0];  							password = strings[1];    							break;  						}  						case "content-type":  							contentType = val;  							break;  						case "content-length":  							try  							{  								contentLength = long.Parse(val' NumberStyles.Integer' CultureInfo.InvariantCulture);  							}  							catch(FormatException)  							{  							}  							if(contentLength > client.server.MaxPostLength)  							{  								RequestError("413"' StatusCodes.GetDescription("413"));  								return;  							}  							else if(contentLength < 0)  							{  								RequestError("400"' StatusCodes.GetDescription("400"));  								return;  							}  							break;  						case "accept":  							accept = val;  							break;  						case "accept-language":  							acceptLanguage = val;  							break;  						case "user-agent":  							userAgent = val;  							break;  						case "connection":  							if(string.Compare(val' "close"' true' CultureInfo.InvariantCulture) == 0)  								connMode = ConnectionMode.Close;  							else  								connMode = ConnectionMode.KeepAlive;  							break;  						case "if-modified-since":  							try  							{  								ifModifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "if-unmodified-since":  							try  							{  								ifUnmodifiedSince = ParseHttpTime(val);  							}  							catch(FormatException)  							{  							}  							break;  						case "range":  							try  							{  								string[] rangeStrings = val.Split(''');  								this.ranges = new ByteRange[rangeStrings.Length];  								for(int i = 0; i < rangeStrings.Length; i++)  									ranges[i] = new ByteRange(rangeStrings[i]);  							}  							catch(FormatException)  							{  								this.ranges = null;  							}  							break;  						default:  							break;  					}  					break;  				}  			}
Magic Number,MiniHttpd,HttpRequest,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpRequest.cs,SendResponse,The following statement contains a magic number: if(response.ResponseContent == null)  			{  				//Default page  				MemoryStream stream = new MemoryStream(512);  				StreamWriter writer = new StreamWriter(stream);    				//string message = response.ResponseCode + " " + StatusCodes.GetDescription(response.ResponseCode);  				string message = response.ResponseCode + " " + (errorMessage != null ? errorMessage : StatusCodes.GetDescription(response.ResponseCode));  				writer.WriteLine("<html><head><title>" + message + "</title></head>");  				writer.WriteLine("<body><h2>" + message + "</h2>");  				if(errorMessage != null)  					writer.WriteLine(errorMessage);  				writer.WriteLine("<hr>" + this.client.server.ServerName);  				writer.WriteLine("</body></html>");    				writer.Flush();  				response.ContentType = ContentTypes.GetExtensionType(".html");  				response.ResponseContent = stream;  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpResponse,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpResponse.cs,WriteOutput,The following statement contains a magic number: if(responseContent != null)  			{  				try  				{  					byte[] buffer;  					if(responseContent.CanSeek)  					{  						if(responseContent.Length < 1024*4)  							buffer = new byte[responseContent.Length];  						else  							buffer = new byte[1024*4];  					}  					else  						buffer = new byte[1024*4];    					if(rangesValid)  					{  						foreach(ByteRange range in request.Ranges)  						{  							long len = GetRangeLen(range' responseContent);  							if(len == -1)  								continue;    							if(range.Last == -1)  								responseContent.Seek(range.First' SeekOrigin.Begin);  							else if(range.First == -1)  								responseContent.Seek(-range.Last' SeekOrigin.End);  							else  								responseContent.Seek(range.First' SeekOrigin.Begin);    							int bufLen = (int)len;  							while((bufLen = responseContent.Read(buffer' 0' (int)len < buffer.Length ? (int)len : buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' bufLen);  								len -= bufLen;  							}  						}  					}  					else  					{  						int len;  						responseContent.Seek(0' SeekOrigin.Begin);  						try  						{  							while((len = responseContent.Read(buffer' 0' buffer.Length)) != 0)  							{  								outputStream.Write(buffer' 0' len);  								bytesSent += len;  							}  						}  						catch(IOException)  						{  							Request.Client.Disconnect();  						}  					}  				}  				finally  				{  					if(SentResponse != null)  						SentResponse(this' new MiniHttpd.ResponseEventArgs(this.Request.Client' this));  					responseContent.Close();  				}  			}
Magic Number,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The following statement contains a magic number: ServerUri = new Uri("http://" +  				Dns.GetHostName() +  				(port != 80 ? ":" + port.ToString(System.Globalization.CultureInfo.InvariantCulture) : "")  				);
Magic Number,MiniHttpd,HttpServer,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\HttpServer.cs,HttpServer,The following statement contains a magic number: idleTimer = new Timer(new TimerCallback(TimerCallback)' null' 0' 1000);
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*0.96)  				return bytes.ToString(CultureInfo.InvariantCulture) + " bytes";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*0.96)  				return bytes.ToString(CultureInfo.InvariantCulture) + " bytes";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*0.96)  				return (bytes/(decimal)1024).ToString("0.00"' CultureInfo.InvariantCulture) + " KB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*0.96)  				return (bytes/(decimal)1024).ToString("0.00"' CultureInfo.InvariantCulture) + " KB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*0.96)  				return (bytes/(decimal)1024).ToString("0.00"' CultureInfo.InvariantCulture) + " KB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*0.96)  				return (bytes/(decimal)1024).ToString("0.00"' CultureInfo.InvariantCulture) + " KB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*0.96)  				return (bytes/(decimal)(1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " MB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: if(bytes < 1024*1024*1024*(decimal)1024*(decimal)0.5)  				return (bytes/(decimal)(1024*1024*1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " GB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,ReadableDataLength,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\ReadableDataLength.cs,Calculate,The following statement contains a magic number: return (bytes/(decimal)(1024*1024*1024*(decimal)1024)).ToString("0.00"' CultureInfo.InvariantCulture) + " TB";
Magic Number,MiniHttpd,UrlEncoding,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,InitUrlStrings,The following statement contains a magic number: string[] urlEncStrings = new string[256];
Magic Number,MiniHttpd,UrlEncoding,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,InitUrlStrings,The following statement contains a magic number: for(int i = 0; i < 255; i++)  				urlEncStrings[i] = "%" + i.ToString("X2");
Magic Number,MiniHttpd,UrlEncoding,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,IsSafe,The following statement contains a magic number: if(ch > 255)  				return true;
Missing Default,MiniHttpd.Aspx,AspxAppDirectory,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\Aspx\AspxAppDirectory.cs,LoadWebConfig,The following switch statement is missing a default case: switch(node.Name)  						{  							case "add":  							{  								if(node.Attributes["verb"] == null)  									break;  								if(node.Attributes["path"] == null)  									break;  								if(node.Attributes["type"] == null)  									break;    								bool validate = false;  								  								try  								{  									if(node.Attributes["validate"] != null)  										validate = bool.Parse(node.Attributes["validate"].Value);  								}  								catch(FormatException)  								{  									validate = false;  								}    								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' node.Attributes["type"].Value' validate);  								httpHandlers.Remove(handler);  								httpHandlers.Add(handler);    								break;  							}  							case "remove":  							{  								if(node.Attributes["verb"] == null)  									break;  								if(node.Attributes["path"] == null)  									break;    								HttpHandler handler = new HttpHandler(node.Attributes["verb"].Value' node.Attributes["path"].Value' null' false);  								httpHandlers.Remove(handler);    								break;  							}  							case "clear":  							{  								httpHandlers.Clear();    								break;  							}  						}
Missing Default,MiniHttpd,ResourceEntry,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\FileSystem\IndexPageEx.cs,WriteHtml,The following switch statement is missing a default case: switch(column)  					{  						case ResourceColumn.Created:  							if(path != null)  								if(Created != DateTime.MinValue)  									writer.Write(Created.ToString());  							break;  						case ResourceColumn.Modified:  							if(path != null)  								if(Modified != DateTime.MinValue)  									writer.Write(Modified.ToString());  							break;  						case ResourceColumn.Size:  							if(!isDir)  								if(path != null)  									if(Size != -1)  										writer.Write(ReadableDataLength.Calculate(Size));  							break;  						case ResourceColumn.Name:  							writer.WriteLine("<a href=\"" + UrlEncoding.Encode(resource.Name) +  								(isDir ? "/\">[" : "\">") + resource.Name + (isDir ? "]" : "") +"</a>");  							break;  					}
Missing Default,MiniHttpd,UrlEncoding,C:\repos\todbot_blink1\windows\Blink1Control\MiniHttpd\UrlEncoding.cs,IsSafe,The following switch statement is missing a default case: switch(ch)  			{  				case '\'':  				case '(':  				case ')':  				case'[':  				case']':  				case '*':  				case '-':  				case '.':  				case '!':  				case '_':  					return true;  			}
