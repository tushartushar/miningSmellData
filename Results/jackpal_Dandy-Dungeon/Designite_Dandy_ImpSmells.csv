Implementation smell,Namespace,Class,File,Method,Description
Long Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The method has 69 lines of code.
Long Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The method has 64 lines of code.
Long Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The method has 64 lines of code.
Long Method,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The method has 76 lines of code.
Complex Method,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,OpenLock,Cyclomatic complexity of the method is 7
Complex Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,Cyclomatic complexity of the method is 14
Complex Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,Cyclomatic complexity of the method is 9
Complex Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,Cyclomatic complexity of the method is 33
Complex Method,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,Cyclomatic complexity of the method is 31
Complex Method,Dandy,Game,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,MovePlayers,Cyclomatic complexity of the method is 8
Long Parameter List,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetActive,The method has 6 parameters.
Long Parameter List,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetActive1,The method has 5 parameters.
Long Parameter List,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Render,The method has 4 parameters.
Long Parameter List,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The method has 4 parameters.
Long Statement,Dandy,Dandy,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,OnCreateDevice,The length of the statement  "	vertexBuffer = new VertexBuffer (typeof(CustomVertex.TransformedTextured)' (int)View.kNumVerts' dev' Usage.WriteOnly' CustomVertex.TransformedTextured.Format' Pool.Default); " is 173.
Complex Conditional,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Get,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height"  is complex.
Complex Conditional,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Get,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height"  is complex.
Complex Conditional,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Set,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height && v <= MapData.kPlayer3"  is complex.
Complex Conditional,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The conditional expression  "y == 0 || y == Height - 1 || x == 0 || x == Width - 1"  is complex.
Complex Conditional,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoSmartBomb,The conditional expression  "d >= MapData.kGhost && d <= MapData.kBig || d >= MapData.kGen1 && d <= MapData.kGen3"  is complex.
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint y = 0; y < Height; y++) {  	for (uint x = 0; x < Width; x++) {  		MapData b = MapData.kSpace;  		if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  			b = MapData.kWall;  		} else if (x == 2 && y == 2) {  			b = MapData.kUp;  		} else if (x == 10 && y == 10) {  			b = MapData.kDown;  		}  		Cell [y * Width + x] = b;  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint y = 0; y < Height; y++) {  	for (uint x = 0; x < Width; x++) {  		MapData b = MapData.kSpace;  		if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  			b = MapData.kWall;  		} else if (x == 2 && y == 2) {  			b = MapData.kUp;  		} else if (x == 10 && y == 10) {  			b = MapData.kDown;  		}  		Cell [y * Width + x] = b;  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint y = 0; y < Height; y++) {  	for (uint x = 0; x < Width; x++) {  		MapData b = MapData.kSpace;  		if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  			b = MapData.kWall;  		} else if (x == 2 && y == 2) {  			b = MapData.kUp;  		} else if (x == 10 && y == 10) {  			b = MapData.kDown;  		}  		Cell [y * Width + x] = b;  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint y = 0; y < Height; y++) {  	for (uint x = 0; x < Width; x++) {  		MapData b = MapData.kSpace;  		if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  			b = MapData.kWall;  		} else if (x == 2 && y == 2) {  			b = MapData.kUp;  		} else if (x == 10 && y == 10) {  			b = MapData.kDown;  		}  		Cell [y * Width + x] = b;  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint x = 0; x < Width; x++) {  	MapData b = MapData.kSpace;  	if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  		b = MapData.kWall;  	} else if (x == 2 && y == 2) {  		b = MapData.kUp;  	} else if (x == 10 && y == 10) {  		b = MapData.kDown;  	}  	Cell [y * Width + x] = b;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint x = 0; x < Width; x++) {  	MapData b = MapData.kSpace;  	if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  		b = MapData.kWall;  	} else if (x == 2 && y == 2) {  		b = MapData.kUp;  	} else if (x == 10 && y == 10) {  		b = MapData.kDown;  	}  	Cell [y * Width + x] = b;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint x = 0; x < Width; x++) {  	MapData b = MapData.kSpace;  	if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  		b = MapData.kWall;  	} else if (x == 2 && y == 2) {  		b = MapData.kUp;  	} else if (x == 10 && y == 10) {  		b = MapData.kDown;  	}  	Cell [y * Width + x] = b;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for (uint x = 0; x < Width; x++) {  	MapData b = MapData.kSpace;  	if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  		b = MapData.kWall;  	} else if (x == 2 && y == 2) {  		b = MapData.kUp;  	} else if (x == 10 && y == 10) {  		b = MapData.kDown;  	}  	Cell [y * Width + x] = b;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  	b = MapData.kWall;  } else if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  	b = MapData.kWall;  } else if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  	b = MapData.kWall;  } else if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (y == 0 || y == Height - 1 || x == 0 || x == Width - 1) {  	b = MapData.kWall;  } else if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 2 && y == 2) {  	b = MapData.kUp;  } else if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: if (x == 10 && y == 10) {  	b = MapData.kDown;  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: using (FileStream s = new FileStream (fileName' FileMode.Open)) {  	for (int y = 0; y < Height; y++) {  		for (int x = 0; x < Width; x += 2) {  			int inb = s.ReadByte ();  			if (inb < 0) {  				throw new System.Exception ("Unexpected EOF");  			}  			Cell [y * Width + x] = (MapData)(inb & 0xf);  			Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  		}  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: using (FileStream s = new FileStream (fileName' FileMode.Open)) {  	for (int y = 0; y < Height; y++) {  		for (int x = 0; x < Width; x += 2) {  			int inb = s.ReadByte ();  			if (inb < 0) {  				throw new System.Exception ("Unexpected EOF");  			}  			Cell [y * Width + x] = (MapData)(inb & 0xf);  			Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  		}  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: for (int y = 0; y < Height; y++) {  	for (int x = 0; x < Width; x += 2) {  		int inb = s.ReadByte ();  		if (inb < 0) {  			throw new System.Exception ("Unexpected EOF");  		}  		Cell [y * Width + x] = (MapData)(inb & 0xf);  		Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: for (int y = 0; y < Height; y++) {  	for (int x = 0; x < Width; x += 2) {  		int inb = s.ReadByte ();  		if (inb < 0) {  			throw new System.Exception ("Unexpected EOF");  		}  		Cell [y * Width + x] = (MapData)(inb & 0xf);  		Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  	}  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: for (int x = 0; x < Width; x += 2) {  	int inb = s.ReadByte ();  	if (inb < 0) {  		throw new System.Exception ("Unexpected EOF");  	}  	Cell [y * Width + x] = (MapData)(inb & 0xf);  	Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: for (int x = 0; x < Width; x += 2) {  	int inb = s.ReadByte ();  	if (inb < 0) {  		throw new System.Exception ("Unexpected EOF");  	}  	Cell [y * Width + x] = (MapData)(inb & 0xf);  	Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  }  
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: x += 2
Magic Number,Dandy,Map,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: Cell [y * Width + x + 1] = (MapData)((inb >> 4) & 0xf);  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: numPlayers = 2;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint y = startY + gridYOffset; y < endY; y += 3) {  	for (uint x = startX + gridXOffset; x < endX; x += 3) {  		MapData d = map.Get (x' y);  		if (d >= MapData.kGhost && d <= MapData.kBig) {  			// Move towards nearest player  			Direction dir = GetDirectionOfNearestPlayer (x' y);  			if (dir != Direction.kDirNone) {  				byte mx = 0;  				byte my = 0;  				bool canMove = false;  				MapData d2 = MapData.kSpace;  				for (int test = 0; test < 3; test++) {  					mx = (byte)x;  					my = (byte)y;  					MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  					d2 = map.Get (mx' my);  					if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						canMove = true;  						break;  					}  				}  				if (canMove) {  					map.Set (x' y' MapData.kSpace);  					if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  						Player p = player [d2 - MapData.kPlayer0];  						int monsterHit = d - MapData.kGhost + 1;  						if (p.health > monsterHit) {  							p.health = (byte)(p.health - monsterHit);  						} else {  							p.health = 0;  							MapData remains = MapData.kSpace;  							if (p.keys > 0) {  								--p.keys;  								remains = MapData.kKey;  							}  							map.Set (p.x' p.y' remains);  						}  					} else {  						map.Set (mx' my' d);  					}  				}  			}  		} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  			// Random generator  			if (getRandom (10) < 3) {  				byte gx = (byte)x;  				byte gy = (byte)y;  				MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  				if (map.Get (gx' gy) == MapData.kSpace) {  					map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  				}  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: y += 3
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (uint x = startX + gridXOffset; x < endX; x += 3) {  	MapData d = map.Get (x' y);  	if (d >= MapData.kGhost && d <= MapData.kBig) {  		// Move towards nearest player  		Direction dir = GetDirectionOfNearestPlayer (x' y);  		if (dir != Direction.kDirNone) {  			byte mx = 0;  			byte my = 0;  			bool canMove = false;  			MapData d2 = MapData.kSpace;  			for (int test = 0; test < 3; test++) {  				mx = (byte)x;  				my = (byte)y;  				MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  				d2 = map.Get (mx' my);  				if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					canMove = true;  					break;  				}  			}  			if (canMove) {  				map.Set (x' y' MapData.kSpace);  				if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  					Player p = player [d2 - MapData.kPlayer0];  					int monsterHit = d - MapData.kGhost + 1;  					if (p.health > monsterHit) {  						p.health = (byte)(p.health - monsterHit);  					} else {  						p.health = 0;  						MapData remains = MapData.kSpace;  						if (p.keys > 0) {  							--p.keys;  							remains = MapData.kKey;  						}  						map.Set (p.x' p.y' remains);  					}  				} else {  					map.Set (mx' my' d);  				}  			}  		}  	} else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  		// Random generator  		if (getRandom (10) < 3) {  			byte gx = (byte)x;  			byte gy = (byte)y;  			MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  			if (map.Get (gx' gy) == MapData.kSpace) {  				map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  			}  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: x += 3
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGhost && d <= MapData.kBig) {  	// Move towards nearest player  	Direction dir = GetDirectionOfNearestPlayer (x' y);  	if (dir != Direction.kDirNone) {  		byte mx = 0;  		byte my = 0;  		bool canMove = false;  		MapData d2 = MapData.kSpace;  		for (int test = 0; test < 3; test++) {  			mx = (byte)x;  			my = (byte)y;  			MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  			d2 = map.Get (mx' my);  			if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				canMove = true;  				break;  			}  		}  		if (canMove) {  			map.Set (x' y' MapData.kSpace);  			if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  				Player p = player [d2 - MapData.kPlayer0];  				int monsterHit = d - MapData.kGhost + 1;  				if (p.health > monsterHit) {  					p.health = (byte)(p.health - monsterHit);  				} else {  					p.health = 0;  					MapData remains = MapData.kSpace;  					if (p.keys > 0) {  						--p.keys;  						remains = MapData.kKey;  					}  					map.Set (p.x' p.y' remains);  				}  			} else {  				map.Set (mx' my' d);  			}  		}  	}  } else if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (dir != Direction.kDirNone) {  	byte mx = 0;  	byte my = 0;  	bool canMove = false;  	MapData d2 = MapData.kSpace;  	for (int test = 0; test < 3; test++) {  		mx = (byte)x;  		my = (byte)y;  		MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  		d2 = map.Get (mx' my);  		if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  			canMove = true;  			break;  		}  	}  	if (canMove) {  		map.Set (x' y' MapData.kSpace);  		if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  			Player p = player [d2 - MapData.kPlayer0];  			int monsterHit = d - MapData.kGhost + 1;  			if (p.health > monsterHit) {  				p.health = (byte)(p.health - monsterHit);  			} else {  				p.health = 0;  				MapData remains = MapData.kSpace;  				if (p.keys > 0) {  					--p.keys;  					remains = MapData.kKey;  				}  				map.Set (p.x' p.y' remains);  			}  		} else {  			map.Set (mx' my' d);  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (dir != Direction.kDirNone) {  	byte mx = 0;  	byte my = 0;  	bool canMove = false;  	MapData d2 = MapData.kSpace;  	for (int test = 0; test < 3; test++) {  		mx = (byte)x;  		my = (byte)y;  		MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  		d2 = map.Get (mx' my);  		if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  			canMove = true;  			break;  		}  	}  	if (canMove) {  		map.Set (x' y' MapData.kSpace);  		if (d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  			Player p = player [d2 - MapData.kPlayer0];  			int monsterHit = d - MapData.kGhost + 1;  			if (p.health > monsterHit) {  				p.health = (byte)(p.health - monsterHit);  			} else {  				p.health = 0;  				MapData remains = MapData.kSpace;  				if (p.keys > 0) {  					--p.keys;  					remains = MapData.kKey;  				}  				map.Set (p.x' p.y' remains);  			}  		} else {  			map.Set (mx' my' d);  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (int test = 0; test < 3; test++) {  	mx = (byte)x;  	my = (byte)y;  	MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  	d2 = map.Get (mx' my);  	if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  		canMove = true;  		break;  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for (int test = 0; test < 3; test++) {  	mx = (byte)x;  	my = (byte)y;  	MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  	d2 = map.Get (mx' my);  	if (d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3) {  		canMove = true;  		break;  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: MoveCoords (ref mx' ref my' (Direction)(((int)dir + kTestDelta [test]) & 7));  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (d >= MapData.kGen1 && d <= MapData.kGen3) {  	// Random generator  	if (getRandom (10) < 3) {  		byte gx = (byte)x;  		byte gy = (byte)y;  		MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  		if (map.Get (gx' gy) == MapData.kSpace) {  			map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (getRandom (10) < 3) {  	byte gx = (byte)x;  	byte gy = (byte)y;  	MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  	if (map.Get (gx' gy) == MapData.kSpace) {  		map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (getRandom (10) < 3) {  	byte gx = (byte)x;  	byte gy = (byte)y;  	MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  	if (map.Get (gx' gy) == MapData.kSpace) {  		map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (getRandom (10) < 3) {  	byte gx = (byte)x;  	byte gy = (byte)y;  	MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  	if (map.Get (gx' gy) == MapData.kSpace) {  		map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: if (getRandom (10) < 3) {  	byte gx = (byte)x;  	byte gy = (byte)y;  	MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  	if (map.Get (gx' gy) == MapData.kSpace) {  		map.Set (gx' gy' (MapData)MapData.kGhost + (d - MapData.kGen1));  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: MoveCoords (ref gx' ref gy' (Direction)(getRandom (4) * 2));  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if (bestDistance == 10000) {  	return Direction.kDirNone;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if (dy > 0)  	bitField |= 8;  else if (dy < 0)  	bitField |= 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if (dy > 0)  	bitField |= 8;  else if (dy < 0)  	bitField |= 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: bitField |= 8;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if (dy < 0)  	bitField |= 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: bitField |= 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if (dx > 0)  	bitField |= 2;  else if (dx < 0)  	bitField |= 1;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: bitField |= 2;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: if (!map.Find (ref x' ref y' MapData.kUp)) {  	Debug.MyDebugBreak ();  	x = 4;  	y = 4;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: if (!map.Find (ref x' ref y' MapData.kUp)) {  	Debug.MyDebugBreak ();  	x = 4;  	y = 4;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: x = 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: y = 4;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: for (uint i = 0; i < numPlayers; i++) {  	Player p = player [i];  	if (p.IsAlive ()) {  		byte px = x;  		byte py = y;  		MoveCoords (ref px' ref py' (Direction)(i * 2));  		PlaceInWorld (i' px' py);  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: if (p.IsAlive ()) {  	byte px = x;  	byte py = y;  	MoveCoords (ref px' ref py' (Direction)(i * 2));  	PlaceInWorld (i' px' py);  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: MoveCoords (ref px' ref py' (Direction)(i * 2));  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,PlaceInWorld,The following statement contains a magic number: p.dir = (Direction)(index * 2);  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if (stick < 4 && dir < (Direction)8) {  	if (stick < numPlayers) {  		Player p = player [stick];  		p.dir = dir;  		TimeSpan delta = time - p.lastMoveTime;  		if (p.IsVisible () && delta.Milliseconds >= kMsPerMove) {  			p.lastMoveTime = time;  			byte x = p.x;  			byte y = p.y;  			MoveCoords (ref x' ref y' dir);  			MapData d = map.Get (x' y);  			bool bMove = false;  			switch (d) {  			case MapData.kSpace:  				bMove = true;  				break;  			case MapData.kLock:  				if (p.keys > 0) {  					--p.keys;  					map.OpenLock (x' y);  					bMove = true;  				}  				break;  			case MapData.kKey:  				++p.keys;  				bMove = true;  				break;  			case MapData.kFood:  				++p.food;  				bMove = true;  				break;  			case MapData.kMoney:  				p.score += 10;  				bMove = true;  				break;  			case MapData.kBomb:  				++p.bombs;  				bMove = true;  				break;  			case MapData.kDown:  				{  					p.state = PlayerState.kInWarp;  					map.Set (p.x' p.y' MapData.kSpace);  					if (IsPartyInWarp ()) {  						ChangeLevel (1);  					}  				}  				break;  			default:  				break;  			}  			if (bMove) {  				map.Set (p.x' p.y' MapData.kSpace);  				map.Set (x' y' (MapData)((int)MapData.kPlayer0 + stick));  				p.x = x;  				p.y = y;  			}  		}  	}  } else {  	Debug.MyDebugBreak ();  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if (stick < 4 && dir < (Direction)8) {  	if (stick < numPlayers) {  		Player p = player [stick];  		p.dir = dir;  		TimeSpan delta = time - p.lastMoveTime;  		if (p.IsVisible () && delta.Milliseconds >= kMsPerMove) {  			p.lastMoveTime = time;  			byte x = p.x;  			byte y = p.y;  			MoveCoords (ref x' ref y' dir);  			MapData d = map.Get (x' y);  			bool bMove = false;  			switch (d) {  			case MapData.kSpace:  				bMove = true;  				break;  			case MapData.kLock:  				if (p.keys > 0) {  					--p.keys;  					map.OpenLock (x' y);  					bMove = true;  				}  				break;  			case MapData.kKey:  				++p.keys;  				bMove = true;  				break;  			case MapData.kFood:  				++p.food;  				bMove = true;  				break;  			case MapData.kMoney:  				p.score += 10;  				bMove = true;  				break;  			case MapData.kBomb:  				++p.bombs;  				bMove = true;  				break;  			case MapData.kDown:  				{  					p.state = PlayerState.kInWarp;  					map.Set (p.x' p.y' MapData.kSpace);  					if (IsPartyInWarp ()) {  						ChangeLevel (1);  					}  				}  				break;  			default:  				break;  			}  			if (bMove) {  				map.Set (p.x' p.y' MapData.kSpace);  				map.Set (x' y' (MapData)((int)MapData.kPlayer0 + stick));  				p.x = x;  				p.y = y;  			}  		}  	}  } else {  	Debug.MyDebugBreak ();  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if (stick < 4 && dir < (Direction)8) {  	if (stick < numPlayers) {  		Player p = player [stick];  		p.dir = dir;  		TimeSpan delta = time - p.lastMoveTime;  		if (p.IsVisible () && delta.Milliseconds >= kMsPerMove) {  			p.lastMoveTime = time;  			byte x = p.x;  			byte y = p.y;  			MoveCoords (ref x' ref y' dir);  			MapData d = map.Get (x' y);  			bool bMove = false;  			switch (d) {  			case MapData.kSpace:  				bMove = true;  				break;  			case MapData.kLock:  				if (p.keys > 0) {  					--p.keys;  					map.OpenLock (x' y);  					bMove = true;  				}  				break;  			case MapData.kKey:  				++p.keys;  				bMove = true;  				break;  			case MapData.kFood:  				++p.food;  				bMove = true;  				break;  			case MapData.kMoney:  				p.score += 10;  				bMove = true;  				break;  			case MapData.kBomb:  				++p.bombs;  				bMove = true;  				break;  			case MapData.kDown:  				{  					p.state = PlayerState.kInWarp;  					map.Set (p.x' p.y' MapData.kSpace);  					if (IsPartyInWarp ()) {  						ChangeLevel (1);  					}  				}  				break;  			default:  				break;  			}  			if (bMove) {  				map.Set (p.x' p.y' MapData.kSpace);  				map.Set (x' y' (MapData)((int)MapData.kPlayer0 + stick));  				p.x = x;  				p.y = y;  			}  		}  	}  } else {  	Debug.MyDebugBreak ();  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if (stick < numPlayers) {  	Player p = player [stick];  	p.dir = dir;  	TimeSpan delta = time - p.lastMoveTime;  	if (p.IsVisible () && delta.Milliseconds >= kMsPerMove) {  		p.lastMoveTime = time;  		byte x = p.x;  		byte y = p.y;  		MoveCoords (ref x' ref y' dir);  		MapData d = map.Get (x' y);  		bool bMove = false;  		switch (d) {  		case MapData.kSpace:  			bMove = true;  			break;  		case MapData.kLock:  			if (p.keys > 0) {  				--p.keys;  				map.OpenLock (x' y);  				bMove = true;  			}  			break;  		case MapData.kKey:  			++p.keys;  			bMove = true;  			break;  		case MapData.kFood:  			++p.food;  			bMove = true;  			break;  		case MapData.kMoney:  			p.score += 10;  			bMove = true;  			break;  		case MapData.kBomb:  			++p.bombs;  			bMove = true;  			break;  		case MapData.kDown:  			{  				p.state = PlayerState.kInWarp;  				map.Set (p.x' p.y' MapData.kSpace);  				if (IsPartyInWarp ()) {  					ChangeLevel (1);  				}  			}  			break;  		default:  			break;  		}  		if (bMove) {  			map.Set (p.x' p.y' MapData.kSpace);  			map.Set (x' y' (MapData)((int)MapData.kPlayer0 + stick));  			p.x = x;  			p.y = y;  		}  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if (p.IsVisible () && delta.Milliseconds >= kMsPerMove) {  	p.lastMoveTime = time;  	byte x = p.x;  	byte y = p.y;  	MoveCoords (ref x' ref y' dir);  	MapData d = map.Get (x' y);  	bool bMove = false;  	switch (d) {  	case MapData.kSpace:  		bMove = true;  		break;  	case MapData.kLock:  		if (p.keys > 0) {  			--p.keys;  			map.OpenLock (x' y);  			bMove = true;  		}  		break;  	case MapData.kKey:  		++p.keys;  		bMove = true;  		break;  	case MapData.kFood:  		++p.food;  		bMove = true;  		break;  	case MapData.kMoney:  		p.score += 10;  		bMove = true;  		break;  	case MapData.kBomb:  		++p.bombs;  		bMove = true;  		break;  	case MapData.kDown:  		{  			p.state = PlayerState.kInWarp;  			map.Set (p.x' p.y' MapData.kSpace);  			if (IsPartyInWarp ()) {  				ChangeLevel (1);  			}  		}  		break;  	default:  		break;  	}  	if (bMove) {  		map.Set (p.x' p.y' MapData.kSpace);  		map.Set (x' y' (MapData)((int)MapData.kPlayer0 + stick));  		p.x = x;  		p.y = y;  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: switch (d) {  case MapData.kSpace:  	bMove = true;  	break;  case MapData.kLock:  	if (p.keys > 0) {  		--p.keys;  		map.OpenLock (x' y);  		bMove = true;  	}  	break;  case MapData.kKey:  	++p.keys;  	bMove = true;  	break;  case MapData.kFood:  	++p.food;  	bMove = true;  	break;  case MapData.kMoney:  	p.score += 10;  	bMove = true;  	break;  case MapData.kBomb:  	++p.bombs;  	bMove = true;  	break;  case MapData.kDown:  	{  		p.state = PlayerState.kInWarp;  		map.Set (p.x' p.y' MapData.kSpace);  		if (IsPartyInWarp ()) {  			ChangeLevel (1);  		}  	}  	break;  default:  	break;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: p.score += 10;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (Arrow.CanHit (d)) {  	switch (d) {  	case MapData.kBomb:  		DoSmartBomb ();  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kGhost:  		goto common;  	case MapData.kSmiley:  		goto common;  	case MapData.kBig:  		goto common;  	case MapData.kGen1:  		goto common;  	case MapData.kGen2:  		goto common;  	case MapData.kGen3:  		common:  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kHeart:  		{  			bool foundPlayer = false;  			for (uint i = 0; i < numPlayers; i++) {  				Player p2 = player [i];  				if (!p2.IsAlive ()) {  					p2.health = 9;  					p2.state = PlayerState.kNormal;  					PlaceInWorld (i' x' y);  					foundPlayer = true;  					break;  				}  			}  			if (!foundPlayer) {  				map.Set (x' y' MapData.kBig);  			}  		}  		break;  	default:  		Debug.MyDebugBreak ();  		break;  	}  	p.arrow.alive = false;  } else if (Arrow.CanGo (d)) {  	p.arrow.x = x;  	p.arrow.y = y;  	int rotatedDir = ((int)(p.arrow.dir + 3) & 7);  	// Because font is screwed up  	map.Set (x' y' (MapData)(MapData.kArrow0 + rotatedDir));  } else {  	p.arrow.alive = false;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (Arrow.CanHit (d)) {  	switch (d) {  	case MapData.kBomb:  		DoSmartBomb ();  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kGhost:  		goto common;  	case MapData.kSmiley:  		goto common;  	case MapData.kBig:  		goto common;  	case MapData.kGen1:  		goto common;  	case MapData.kGen2:  		goto common;  	case MapData.kGen3:  		common:  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kHeart:  		{  			bool foundPlayer = false;  			for (uint i = 0; i < numPlayers; i++) {  				Player p2 = player [i];  				if (!p2.IsAlive ()) {  					p2.health = 9;  					p2.state = PlayerState.kNormal;  					PlaceInWorld (i' x' y);  					foundPlayer = true;  					break;  				}  			}  			if (!foundPlayer) {  				map.Set (x' y' MapData.kBig);  			}  		}  		break;  	default:  		Debug.MyDebugBreak ();  		break;  	}  	p.arrow.alive = false;  } else if (Arrow.CanGo (d)) {  	p.arrow.x = x;  	p.arrow.y = y;  	int rotatedDir = ((int)(p.arrow.dir + 3) & 7);  	// Because font is screwed up  	map.Set (x' y' (MapData)(MapData.kArrow0 + rotatedDir));  } else {  	p.arrow.alive = false;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (Arrow.CanHit (d)) {  	switch (d) {  	case MapData.kBomb:  		DoSmartBomb ();  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kGhost:  		goto common;  	case MapData.kSmiley:  		goto common;  	case MapData.kBig:  		goto common;  	case MapData.kGen1:  		goto common;  	case MapData.kGen2:  		goto common;  	case MapData.kGen3:  		common:  		map.Set (x' y' MapData.kSpace);  		break;  	case MapData.kHeart:  		{  			bool foundPlayer = false;  			for (uint i = 0; i < numPlayers; i++) {  				Player p2 = player [i];  				if (!p2.IsAlive ()) {  					p2.health = 9;  					p2.state = PlayerState.kNormal;  					PlaceInWorld (i' x' y);  					foundPlayer = true;  					break;  				}  			}  			if (!foundPlayer) {  				map.Set (x' y' MapData.kBig);  			}  		}  		break;  	default:  		Debug.MyDebugBreak ();  		break;  	}  	p.arrow.alive = false;  } else if (Arrow.CanGo (d)) {  	p.arrow.x = x;  	p.arrow.y = y;  	int rotatedDir = ((int)(p.arrow.dir + 3) & 7);  	// Because font is screwed up  	map.Set (x' y' (MapData)(MapData.kArrow0 + rotatedDir));  } else {  	p.arrow.alive = false;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: switch (d) {  case MapData.kBomb:  	DoSmartBomb ();  	map.Set (x' y' MapData.kSpace);  	break;  case MapData.kGhost:  	goto common;  case MapData.kSmiley:  	goto common;  case MapData.kBig:  	goto common;  case MapData.kGen1:  	goto common;  case MapData.kGen2:  	goto common;  case MapData.kGen3:  	common:  	map.Set (x' y' MapData.kSpace);  	break;  case MapData.kHeart:  	{  		bool foundPlayer = false;  		for (uint i = 0; i < numPlayers; i++) {  			Player p2 = player [i];  			if (!p2.IsAlive ()) {  				p2.health = 9;  				p2.state = PlayerState.kNormal;  				PlaceInWorld (i' x' y);  				foundPlayer = true;  				break;  			}  		}  		if (!foundPlayer) {  			map.Set (x' y' MapData.kBig);  		}  	}  	break;  default:  	Debug.MyDebugBreak ();  	break;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: for (uint i = 0; i < numPlayers; i++) {  	Player p2 = player [i];  	if (!p2.IsAlive ()) {  		p2.health = 9;  		p2.state = PlayerState.kNormal;  		PlaceInWorld (i' x' y);  		foundPlayer = true;  		break;  	}  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (!p2.IsAlive ()) {  	p2.health = 9;  	p2.state = PlayerState.kNormal;  	PlaceInWorld (i' x' y);  	foundPlayer = true;  	break;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: p2.health = 9;  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (Arrow.CanGo (d)) {  	p.arrow.x = x;  	p.arrow.y = y;  	int rotatedDir = ((int)(p.arrow.dir + 3) & 7);  	// Because font is screwed up  	map.Set (x' y' (MapData)(MapData.kArrow0 + rotatedDir));  } else {  	p.arrow.alive = false;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if (Arrow.CanGo (d)) {  	p.arrow.x = x;  	p.arrow.y = y;  	int rotatedDir = ((int)(p.arrow.dir + 3) & 7);  	// Because font is screwed up  	map.Set (x' y' (MapData)(MapData.kArrow0 + rotatedDir));  } else {  	p.arrow.alive = false;  }  
Magic Number,Dandy,World,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,MoveCoords,The following statement contains a magic number: if ((int)direction < 8) {  	// Up is zero' clockwise  	x = (byte)(x + kOffsets [(int)direction] [0]);  	y = (byte)(y + kOffsets [(int)direction] [1]);  } else {  	Debug.MyDebugBreak ();  }  
Magic Number,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: for (uint x = startX; x < endX; x++) {  	for (uint y = startY; y < endY; y++) {  		byte b = (byte)map.Get (x' y);  		float uLow = (b % uChars) * uScale;  		float uHigh = uLow + uScale;  		float vLow = (b / uChars) * vScale;  		float vHigh = vLow + vScale;  		float xLow = xBase + x * CellSize;  		float xHigh = xLow + CellSize;  		float yLow = yBase + y * CellSize;  		float yHigh = yLow + CellSize;  		// Set the two triangles  		// First triangle  		pV [index].X = xLow;  		pV [index].Y = yLow;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uLow;  		pV [index].Tv = vLow;  		index++;  		pV [index].X = xHigh;  		pV [index].Y = yLow;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uHigh;  		pV [index].Tv = vLow;  		index++;  		pV [index].X = xLow;  		pV [index].Y = yHigh;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uLow;  		pV [index].Tv = vHigh;  		// Second triangle  		index++;  		pV [index].X = xLow;  		pV [index].Y = yHigh;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uLow;  		pV [index].Tv = vHigh;  		index++;  		pV [index].X = xHigh;  		pV [index].Y = yLow;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uHigh;  		pV [index].Tv = vLow;  		index++;  		pV [index].X = xHigh;  		pV [index].Y = yHigh;  		pV [index].Z = 0.0f;  		pV [index].Rhw = 1.0f;  		pV [index].Tu = uHigh;  		pV [index].Tv = vHigh;  		index++;  		dwNumTris += 2;  	}  }  
Magic Number,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: for (uint y = startY; y < endY; y++) {  	byte b = (byte)map.Get (x' y);  	float uLow = (b % uChars) * uScale;  	float uHigh = uLow + uScale;  	float vLow = (b / uChars) * vScale;  	float vHigh = vLow + vScale;  	float xLow = xBase + x * CellSize;  	float xHigh = xLow + CellSize;  	float yLow = yBase + y * CellSize;  	float yHigh = yLow + CellSize;  	// Set the two triangles  	// First triangle  	pV [index].X = xLow;  	pV [index].Y = yLow;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uLow;  	pV [index].Tv = vLow;  	index++;  	pV [index].X = xHigh;  	pV [index].Y = yLow;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uHigh;  	pV [index].Tv = vLow;  	index++;  	pV [index].X = xLow;  	pV [index].Y = yHigh;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uLow;  	pV [index].Tv = vHigh;  	// Second triangle  	index++;  	pV [index].X = xLow;  	pV [index].Y = yHigh;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uLow;  	pV [index].Tv = vHigh;  	index++;  	pV [index].X = xHigh;  	pV [index].Y = yLow;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uHigh;  	pV [index].Tv = vLow;  	index++;  	pV [index].X = xHigh;  	pV [index].Y = yHigh;  	pV [index].Z = 0.0f;  	pV [index].Rhw = 1.0f;  	pV [index].Tu = uHigh;  	pV [index].Tv = vHigh;  	index++;  	dwNumTris += 2;  }  
Magic Number,Dandy,View,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: dwNumTris += 2;  
Magic Number,Dandy,Dandy,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (16 * 20' 16 * 10);  
Magic Number,Dandy,Dandy,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (16 * 20' 16 * 10);  
Magic Number,Dandy,Dandy,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (16 * 20' 16 * 10);  
Magic Number,Dandy,Dandy,D:\newReposJune17\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size (16 * 20' 16 * 10);  
