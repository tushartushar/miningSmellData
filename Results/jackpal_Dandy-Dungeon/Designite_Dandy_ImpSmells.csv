Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,Cyclomatic complexity of the method is 10
Complex Method,Dandy,Game,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,MovePlayers,Cyclomatic complexity of the method is 8
Long Parameter List,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetActive,The method has 6 parameters. Parameters: x' y' left' top' right' bottom
Long Parameter List,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetActive1,The method has 5 parameters. Parameters: x' left' right' width' viewWidth
Long Statement,Dandy,View,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Render,The length of the statement  "		CustomVertex.TransformedTextured[] verts = (CustomVertex.TransformedTextured[])vb.Lock(0'0); // Lock the buffer (which will return our structs) " is 143.
Long Statement,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,InitializeGraphics,The length of the statement  "				device = new Device(0' DeviceType.Hardware' this' CreateFlags.SoftwareVertexProcessing' presentParams); //Create a device " is 121.
Long Statement,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,OnCreateDevice,The length of the statement  "			vertexBuffer = new VertexBuffer(typeof(CustomVertex.TransformedTextured)' (int) View.kNumVerts' dev' Usage.WriteOnly' CustomVertex.TransformedTextured.Format' Pool.Default); " is 173.
Complex Conditional,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Get,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height"  is complex.
Complex Conditional,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Get,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height"  is complex.
Complex Conditional,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Set,The conditional expression  "x >= 0 && x < Width && y >= 0 && y < Height && v <= MapData.kPlayer3"  is complex.
Complex Conditional,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The conditional expression  "y == 0 || y == Height-1 || x == 0 || x == Width - 1"  is complex.
Complex Conditional,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoSmartBomb,The conditional expression  "d >= MapData.kGhost && d <= MapData.kBig || d >= MapData.kGen1 && d <= MapData.kGen3"  is complex.
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for(uint y = 0; y < Height; y++)  			{  				for(uint x = 0; x < Width; x++)  				{  					MapData b = MapData.kSpace;  					if(y == 0 || y == Height-1 || x == 0 || x == Width - 1)  					{  						b = MapData.kWall;  					}  					else if ( x == 2 && y == 2)  					{  						b = MapData.kUp;  					}  					else if ( x == 10 && y == 10 )  					{  						b = MapData.kDown;  					}  					Cell[y*Width+x] = b;  				}  			}
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for(uint y = 0; y < Height; y++)  			{  				for(uint x = 0; x < Width; x++)  				{  					MapData b = MapData.kSpace;  					if(y == 0 || y == Height-1 || x == 0 || x == Width - 1)  					{  						b = MapData.kWall;  					}  					else if ( x == 2 && y == 2)  					{  						b = MapData.kUp;  					}  					else if ( x == 10 && y == 10 )  					{  						b = MapData.kDown;  					}  					Cell[y*Width+x] = b;  				}  			}
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for(uint y = 0; y < Height; y++)  			{  				for(uint x = 0; x < Width; x++)  				{  					MapData b = MapData.kSpace;  					if(y == 0 || y == Height-1 || x == 0 || x == Width - 1)  					{  						b = MapData.kWall;  					}  					else if ( x == 2 && y == 2)  					{  						b = MapData.kUp;  					}  					else if ( x == 10 && y == 10 )  					{  						b = MapData.kDown;  					}  					Cell[y*Width+x] = b;  				}  			}
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: for(uint y = 0; y < Height; y++)  			{  				for(uint x = 0; x < Width; x++)  				{  					MapData b = MapData.kSpace;  					if(y == 0 || y == Height-1 || x == 0 || x == Width - 1)  					{  						b = MapData.kWall;  					}  					else if ( x == 2 && y == 2)  					{  						b = MapData.kUp;  					}  					else if ( x == 10 && y == 10 )  					{  						b = MapData.kDown;  					}  					Cell[y*Width+x] = b;  				}  			}
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: using(FileStream s = new FileStream(fileName' FileMode.Open))  			{  				for(int y = 0; y < Height; y++)  				{  					for(int x = 0; x < Width; x += 2)  					{  						int inb = s.ReadByte();  						if(inb < 0)  						{  							throw new System.Exception("Unexpected EOF");  						}  						Cell[y*Width+x] = (MapData) (inb & 0xf);  						Cell[y*Width+x+1] = (MapData) ((inb >> 4) & 0xf);  					}  				}  			}
Magic Number,Dandy,Map,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,LoadLevel2,The following statement contains a magic number: using(FileStream s = new FileStream(fileName' FileMode.Open))  			{  				for(int y = 0; y < Height; y++)  				{  					for(int x = 0; x < Width; x += 2)  					{  						int inb = s.ReadByte();  						if(inb < 0)  						{  							throw new System.Exception("Unexpected EOF");  						}  						Cell[y*Width+x] = (MapData) (inb & 0xf);  						Cell[y*Width+x+1] = (MapData) ((inb >> 4) & 0xf);  					}  				}  			}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Init,The following statement contains a magic number: numPlayers = 2;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: uint gridXOffset = gridStep % 3;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: uint gridYOffset = (gridStep / 3) % 3;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: uint gridYOffset = (gridStep / 3) % 3;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoMonsters,The following statement contains a magic number: for(uint y = startY + gridYOffset; y < endY; y += 3)  		{  			for(uint x = startX + gridXOffset; x < endX; x += 3)  			{  				MapData d = map.Get(x' y);  				if(d >= MapData.kGhost && d <= MapData.kBig)  				{  					// Move towards nearest player  					Direction dir = GetDirectionOfNearestPlayer(x' y);  					if(dir != Direction.kDirNone)  					{  						byte mx = 0;  						byte my = 0;  						bool canMove = false;  						MapData d2 = MapData.kSpace;  						for(int test = 0; test < 3; test++)  						{  							mx = (byte) x;  							my = (byte) y;  							MoveCoords(ref mx' ref my' (Direction) (((int) dir + kTestDelta[test]) & 7));  							d2 = map.Get(mx' my);  							if(d2 == MapData.kSpace || d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								canMove = true;  								break;  							}  						}  						if(canMove)  						{  							map.Set(x' y' MapData.kSpace);  							if(d2 >= MapData.kPlayer0 && d2 <= MapData.kPlayer3)  							{  								Player p = player[d2 - MapData.kPlayer0];  								int monsterHit = d - MapData.kGhost + 1;  								if(p.health > monsterHit)  								{  									p.health = (byte) (p.health - monsterHit);  								}  								else  								{  									p.health = 0;  									MapData remains = MapData.kSpace;  									if(p.keys > 0)  									{  										--p.keys;  										remains = MapData.kKey;  									}  									map.Set(p.x' p.y' remains);  								}  							}  							else  							{  								map.Set(mx' my' d);  							}  						}  					}  				}  				else if(d >= MapData.kGen1 && d <= MapData.kGen3)  				{  					// Random generator  					if(getRandom(10) < 3)  					{  						byte gx = (byte) x;  						byte gy = (byte) y;  						MoveCoords(ref gx' ref gy' (Direction)( getRandom(4) * 2));  						if(map.Get(gx'gy) == MapData.kSpace)  						{  							map.Set(gx' gy' (MapData) MapData.kGhost + (d - MapData.kGen1));  						}  					}  				}  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: uint bestDistance = 10000;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if(bestDistance == 10000)  		{  			return Direction.kDirNone;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if(dy > 0) bitField |= 8;  		else if(dy < 0) bitField |= 4;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if(dy > 0) bitField |= 8;  		else if(dy < 0) bitField |= 4;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,GetDirectionOfNearestPlayer,The following statement contains a magic number: if(dx > 0) bitField |= 2;  		else if(dx < 0) bitField |= 1;
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,ChangeLevel,The following statement contains a magic number: uint newLevel = (uint) Math.Min(26' level + delta);
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: if(!map.Find(ref x' ref y' MapData.kUp))  		{  			Debug.MyDebugBreak();  			x = 4;  			y = 4;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: if(!map.Find(ref x' ref y' MapData.kUp))  		{  			Debug.MyDebugBreak();  			x = 4;  			y = 4;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,SetPlayerPositions,The following statement contains a magic number: for(uint i = 0; i < numPlayers; i++)  		{  			Player p = player[i];  			if(p.IsAlive())  			{  				byte px = x;  				byte py = y;  				MoveCoords(ref px' ref py' (Direction)(i * 2));  				PlaceInWorld(i' px' py);  			}  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,PlaceInWorld,The following statement contains a magic number: p.dir = (Direction) (index * 2);
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if(stick < 4 && dir < (Direction) 8)  		{  			if(stick < numPlayers)  			{  				Player p = player[stick];  				p.dir = dir;  				TimeSpan delta = time - p.lastMoveTime;  				if(p.IsVisible() && delta.Milliseconds >= kMsPerMove)  				{  					p.lastMoveTime = time;  					byte x = p.x;  					byte y = p.y;  					MoveCoords(ref x' ref y' dir);  					MapData d = map.Get(x'y);  					bool bMove = false;  					switch(d)  					{  					case MapData.kSpace:  						bMove = true;  						break;  					case MapData.kLock:  						if(p.keys > 0)  						{  							--p.keys;  							map.OpenLock(x' y);  							bMove = true;  						}  						break;  					case MapData.kKey:  						++p.keys;  						bMove = true;  						break;  					case MapData.kFood:  						++p.food;  						bMove = true;  						break;  					case MapData.kMoney:  						p.score += 10;  						bMove = true;  						break;  					case MapData.kBomb:  						++p.bombs;  						bMove = true;  						break;  					case MapData.kDown:  						{  							p.state = PlayerState.kInWarp;  							map.Set(p.x' p.y' MapData.kSpace);  							if(IsPartyInWarp())  							{  								ChangeLevel(1);  							}  						}  						break;  					default:  						break;  					}  					if(bMove)  					{  						map.Set(p.x' p.y' MapData.kSpace);  						map.Set(x' y' (MapData) ((int) MapData.kPlayer0 + stick));  						p.x = x;  						p.y = y;  					}  				}    			}  		}  		else  		{  			Debug.MyDebugBreak();  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if(stick < 4 && dir < (Direction) 8)  		{  			if(stick < numPlayers)  			{  				Player p = player[stick];  				p.dir = dir;  				TimeSpan delta = time - p.lastMoveTime;  				if(p.IsVisible() && delta.Milliseconds >= kMsPerMove)  				{  					p.lastMoveTime = time;  					byte x = p.x;  					byte y = p.y;  					MoveCoords(ref x' ref y' dir);  					MapData d = map.Get(x'y);  					bool bMove = false;  					switch(d)  					{  					case MapData.kSpace:  						bMove = true;  						break;  					case MapData.kLock:  						if(p.keys > 0)  						{  							--p.keys;  							map.OpenLock(x' y);  							bMove = true;  						}  						break;  					case MapData.kKey:  						++p.keys;  						bMove = true;  						break;  					case MapData.kFood:  						++p.food;  						bMove = true;  						break;  					case MapData.kMoney:  						p.score += 10;  						bMove = true;  						break;  					case MapData.kBomb:  						++p.bombs;  						bMove = true;  						break;  					case MapData.kDown:  						{  							p.state = PlayerState.kInWarp;  							map.Set(p.x' p.y' MapData.kSpace);  							if(IsPartyInWarp())  							{  								ChangeLevel(1);  							}  						}  						break;  					default:  						break;  					}  					if(bMove)  					{  						map.Set(p.x' p.y' MapData.kSpace);  						map.Set(x' y' (MapData) ((int) MapData.kPlayer0 + stick));  						p.x = x;  						p.y = y;  					}  				}    			}  		}  		else  		{  			Debug.MyDebugBreak();  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Move,The following statement contains a magic number: if(stick < 4 && dir < (Direction) 8)  		{  			if(stick < numPlayers)  			{  				Player p = player[stick];  				p.dir = dir;  				TimeSpan delta = time - p.lastMoveTime;  				if(p.IsVisible() && delta.Milliseconds >= kMsPerMove)  				{  					p.lastMoveTime = time;  					byte x = p.x;  					byte y = p.y;  					MoveCoords(ref x' ref y' dir);  					MapData d = map.Get(x'y);  					bool bMove = false;  					switch(d)  					{  					case MapData.kSpace:  						bMove = true;  						break;  					case MapData.kLock:  						if(p.keys > 0)  						{  							--p.keys;  							map.OpenLock(x' y);  							bMove = true;  						}  						break;  					case MapData.kKey:  						++p.keys;  						bMove = true;  						break;  					case MapData.kFood:  						++p.food;  						bMove = true;  						break;  					case MapData.kMoney:  						p.score += 10;  						bMove = true;  						break;  					case MapData.kBomb:  						++p.bombs;  						bMove = true;  						break;  					case MapData.kDown:  						{  							p.state = PlayerState.kInWarp;  							map.Set(p.x' p.y' MapData.kSpace);  							if(IsPartyInWarp())  							{  								ChangeLevel(1);  							}  						}  						break;  					default:  						break;  					}  					if(bMove)  					{  						map.Set(p.x' p.y' MapData.kSpace);  						map.Set(x' y' (MapData) ((int) MapData.kPlayer0 + stick));  						p.x = x;  						p.y = y;  					}  				}    			}  		}  		else  		{  			Debug.MyDebugBreak();  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if(Arrow.CanHit(d))  		{  			switch(d)  			{  			case MapData.kBomb:  				DoSmartBomb();  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kGhost: goto common;  			case MapData.kSmiley: goto common;  			case MapData.kBig: goto common;  			case MapData.kGen1: goto common;  			case MapData.kGen2: goto common;  			case MapData.kGen3:  					common:  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kHeart:  				{  					bool foundPlayer = false;  					for(uint i = 0; i < numPlayers; i++)  					{  						Player p2 = player[i];  						if(!p2.IsAlive())  						{  							p2.health = 9;  							p2.state = PlayerState.kNormal;  							PlaceInWorld(i' x' y);  							foundPlayer = true;  							break;  						}  					}  					if(!foundPlayer)  					{  						map.Set(x' y' MapData.kBig);  					}  				}  				break;  			default:  				Debug.MyDebugBreak();  				break;  			}  			p.arrow.alive = false;  		}  		else if(Arrow.CanGo(d))  		{  			p.arrow.x = x;  			p.arrow.y = y;  			int rotatedDir = ((int)(p.arrow.dir + 3) & 7); // Because font is screwed up  			map.Set(x' y' (MapData) (MapData.kArrow0 + rotatedDir));  		}  		else  		{  			p.arrow.alive = false;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if(Arrow.CanHit(d))  		{  			switch(d)  			{  			case MapData.kBomb:  				DoSmartBomb();  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kGhost: goto common;  			case MapData.kSmiley: goto common;  			case MapData.kBig: goto common;  			case MapData.kGen1: goto common;  			case MapData.kGen2: goto common;  			case MapData.kGen3:  					common:  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kHeart:  				{  					bool foundPlayer = false;  					for(uint i = 0; i < numPlayers; i++)  					{  						Player p2 = player[i];  						if(!p2.IsAlive())  						{  							p2.health = 9;  							p2.state = PlayerState.kNormal;  							PlaceInWorld(i' x' y);  							foundPlayer = true;  							break;  						}  					}  					if(!foundPlayer)  					{  						map.Set(x' y' MapData.kBig);  					}  				}  				break;  			default:  				Debug.MyDebugBreak();  				break;  			}  			p.arrow.alive = false;  		}  		else if(Arrow.CanGo(d))  		{  			p.arrow.x = x;  			p.arrow.y = y;  			int rotatedDir = ((int)(p.arrow.dir + 3) & 7); // Because font is screwed up  			map.Set(x' y' (MapData) (MapData.kArrow0 + rotatedDir));  		}  		else  		{  			p.arrow.alive = false;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DoArrowMove,The following statement contains a magic number: if(Arrow.CanHit(d))  		{  			switch(d)  			{  			case MapData.kBomb:  				DoSmartBomb();  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kGhost: goto common;  			case MapData.kSmiley: goto common;  			case MapData.kBig: goto common;  			case MapData.kGen1: goto common;  			case MapData.kGen2: goto common;  			case MapData.kGen3:  					common:  				map.Set(x' y' MapData.kSpace);  				break;  			case MapData.kHeart:  				{  					bool foundPlayer = false;  					for(uint i = 0; i < numPlayers; i++)  					{  						Player p2 = player[i];  						if(!p2.IsAlive())  						{  							p2.health = 9;  							p2.state = PlayerState.kNormal;  							PlaceInWorld(i' x' y);  							foundPlayer = true;  							break;  						}  					}  					if(!foundPlayer)  					{  						map.Set(x' y' MapData.kBig);  					}  				}  				break;  			default:  				Debug.MyDebugBreak();  				break;  			}  			p.arrow.alive = false;  		}  		else if(Arrow.CanGo(d))  		{  			p.arrow.x = x;  			p.arrow.y = y;  			int rotatedDir = ((int)(p.arrow.dir + 3) & 7); // Because font is screwed up  			map.Set(x' y' (MapData) (MapData.kArrow0 + rotatedDir));  		}  		else  		{  			p.arrow.alive = false;  		}
Magic Number,Dandy,World,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,MoveCoords,The following statement contains a magic number: if((int) direction < 8)  		{  			// Up is zero' clockwise  			x = (byte) (x + kOffsets[(int) direction][0]);  			y = (byte) (y + kOffsets[(int) direction][1]);  		}  		else  		{  			Debug.MyDebugBreak();  		}
Magic Number,Dandy,View,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: const uint uChars = 16;
Magic Number,Dandy,View,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: const uint vChars = 2;
Magic Number,Dandy,View,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,DrawToTexture,The following statement contains a magic number: for(uint x = startX; x < endX; x++)  		{  			for(uint y = startY; y < endY; y ++)  			{  				byte b = (byte) map.Get(x' y);  				float uLow = (b % uChars) * uScale;  				float uHigh = uLow + uScale;  				float vLow = (b / uChars) * vScale;  				float vHigh = vLow + vScale;    				float xLow = xBase + x * CellSize;  				float xHigh = xLow + CellSize;  				float yLow = yBase + y * CellSize;  				float yHigh = yLow + CellSize;    				// Set the two triangles    				// First triangle  				pV[index].X = xLow;  				pV[index].Y = yLow;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uLow;  				pV[index].Tv = vLow;    				index++;    				pV[index].X = xHigh;  				pV[index].Y = yLow;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uHigh;  				pV[index].Tv = vLow;    				index++;    				pV[index].X = xLow;  				pV[index].Y = yHigh;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uLow;  				pV[index].Tv = vHigh;    				// Second triangle  				index++;    				pV[index].X = xLow;  				pV[index].Y = yHigh;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uLow;  				pV[index].Tv = vHigh;    				index++;    				pV[index].X = xHigh;  				pV[index].Y = yLow;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uHigh;  				pV[index].Tv = vLow;    				index++;    				pV[index].X = xHigh;  				pV[index].Y = yHigh;  				pV[index].Z = 0.0f;  				pV[index].Rhw = 1.0f;  				pV[index].Tu = uHigh;  				pV[index].Tv = vHigh;    				index++;    				dwNumTris += 2;  			}  		}
Magic Number,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(16*20' 16*10);
Magic Number,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(16*20' 16*10);
Magic Number,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(16*20' 16*10);
Magic Number,Dandy,Dandy,C:\repos\jackpal_Dandy-Dungeon\dandy-csharp20\Dandy.cs,Dandy,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(16*20' 16*10);
