Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenPop.Mime.Decode,Rfc2231Decoder,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2231Decoder.cs,DecodePairs,The method has 103 lines of code.
Long Method,OpenPop.Mime.Header,MessageHeader,C:\repos\foens_hpop\OpenPop\Mime\Header\MessageHeader.cs,ParseHeader,The method has 128 lines of code.
Complex Method,OpenPop.Mime.Header,RfcMailAddress,C:\repos\foens_hpop\OpenPop\Mime\Header\RfcMailAddress.cs,ParseMailAddress,Cyclomatic complexity of the method is 8
Complex Method,OpenPop.Mime,Message,C:\repos\foens_hpop\OpenPop\Mime\Message.cs,ToMailMessage,Cyclomatic complexity of the method is 15
Complex Method,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Connect,Cyclomatic complexity of the method is 9
Long Parameter List,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Connect,The method has 6 parameters. Parameters: hostname' port' useSsl' receiveTimeout' sendTimeout' certificateValidator
Long Identifier,OpenPop.Mime,MessagePart,C:\repos\foens_hpop\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the parameter lastMultipartBoundaryEncountered is 32.
Long Statement,OpenPop.Mime.Decode,Rfc2231Decoder,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The length of the statement  "					throw new ArgumentException("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported"); " is 145.
Long Statement,OpenPop.Mime.Decode,Rfc2231Decoder,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2231Decoder.cs,DecodeSingleValue,The length of the statement  "				DefaultLogger.Log.LogDebug("Rfc2231Decoder: Someone asked me to decode a string which was not encoded - returning raw string. Input: " + toDecode); " is 147.
Long Statement,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The length of the statement  "						strDate = strDate.Substring(0' strDate.Length - parts[parts.Length - 1].Length).Trim(); //Use the length of the old last part " is 125.
Long Statement,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The length of the statement  "					DefaultLogger.Log.LogDebug(String.Format("Successfully parsed date input \"{0}\" using a custom format. Converted to date: {1}"' dateInput' dateTime.ToString())); " is 162.
Long Statement,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The length of the statement  "					DefaultLogger.Log.LogError("The given date appeared to be in a valid format' but could not be converted to a DateTime object: " + dateInput); " is 141.
Long Statement,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,FixSpecialCases,The length of the statement  "			string incorrectFormat = String.Format(@"{0} +{1} +{2} +{3} +{4} +\({5}\)"' weekDayPattern' monthPattern' dayPattern' timePattern' yearPattern' timeZonePattern); " is 161.
Long Statement,OpenPop.Mime.Decode,Base64,C:\repos\foens_hpop\OpenPop\Mime\Decode\Base64.cs,Decode,The length of the statement  "			// According to http://www.tribridge.com/blog/crm/blogs/brandon-kelly/2011-04-29/Solving-OutOfMemoryException-errors-when-attempting-to-attach-large-Base64-encoded-content-into-CRM-annotations.aspx " is 197.
Long Statement,OpenPop.Mime.Header,RfcMailAddress,C:\repos\foens_hpop\OpenPop\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "			//Find the index of the first angle bracket in this series of angle brackets' e.g "a>b" <<blah@email.com>> wouldn't find the angle bracket in the display name " is 158.
Long Statement,OpenPop.Mime.Header,RfcMailAddress,C:\repos\foens_hpop\OpenPop\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "				input[firstOpenAngleBracketIdx - 1] == '<' && //The character before the last open angle bracket is another open angle bracket " is 126.
Long Statement,OpenPop.Mime.Header,RfcMailAddress,C:\repos\foens_hpop\OpenPop\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "				input[firstCloseAngleBracketIdx - 1] == '>') //The character before the last close angle bracket is another close angle bracket " is 127.
Long Statement,OpenPop.Mime.Header,RfcMailAddress,C:\repos\foens_hpop\OpenPop\Mime\Header\RfcMailAddress.cs,ParseMailAddress,The length of the statement  "					input.Substring(lastOpenAngleBracketIdx' firstCloseAngleBracketIdx - lastOpenAngleBracketIdx + 1); //actual email address' including one angle bracket either side " is 162.
Long Statement,OpenPop.Mime.Header,HeaderFieldParser,C:\repos\foens_hpop\OpenPop\Mime\Header\HeaderFieldParser.cs,ParseImportance,The length of the statement  "					DefaultLogger.Log.LogDebug("HeaderFieldParser: Unknown importance value: \"" + headerValue + "\". Using default of normal importance."); " is 136.
Long Statement,OpenPop.Mime,Message,C:\repos\foens_hpop\OpenPop\Mime\Message.cs,ToMailMessage,The length of the statement  "				attachment.ContentDisposition.FileName = String.IsNullOrEmpty(attachment.ContentDisposition.FileName) ? attachmentMessagePart.FileName : attachment.ContentDisposition.FileName; " is 176.
Long Statement,OpenPop.Mime,MessagePart,C:\repos\foens_hpop\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the statement  "				int startLocation = FindPositionOfNextMultiPartBoundary(stream' multipPartBoundary' out lastMultipartBoundaryEncountered) + ("--" + multipPartBoundary + "\r\n").Length; " is 168.
Long Statement,OpenPop.Mime,MessagePart,C:\repos\foens_hpop\OpenPop\Mime\MessagePart.cs,GetMultiPartParts,The length of the statement  "					int stopLocation = FindPositionOfNextMultiPartBoundary(stream' multipPartBoundary' out lastMultipartBoundaryEncountered) - "\r\n".Length; " is 137.
Long Statement,OpenPop.Pop3,Disposable,C:\repos\foens_hpop\OpenPop\Pop3\Disposable.cs,AssertDisposed,The length of the statement  "				throw new ObjectDisposedException(typeName' String.Format(System.Globalization.CultureInfo.InvariantCulture' "Cannot access a disposed {0}."' typeName)); " is 153.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Connect,The length of the statement  "				throw new InvalidUseException("You cannot ask to connect to a POP3 server' when we are already connected to one. Disconnect first."); " is 133.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Connect,The length of the statement  "				throw new InvalidUseException("You cannot ask to connect to a POP3 server' when we are already connected to one. Disconnect first."); " is 133.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Authenticate,The length of the statement  "				DefaultLogger.Log.LogError("Problem logging in using method " + authenticationMethod + ". Server response was: " + LastServerResponse); " is 135.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,GetMessageCount,The length of the statement  "				throw new InvalidUseException("You cannot get the message count without authenticating yourself towards the server first"); " is 123.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,DeleteMessage,The length of the statement  "				throw new InvalidUseException("You cannot delete any messages without authenticating yourself towards the server first"); " is 121.
Long Statement,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,ValidateMessageNumber,The length of the statement  "				throw new InvalidUseException("The messageNumber argument cannot have a value of zero or less. Valid messageNumber is in the range [1' messageCount]"); " is 151.
Complex Conditional,OpenPop.Mime.Decode,EncodingFinder,C:\repos\foens_hpop\OpenPop\Mime\Decode\EncodingFinder.cs,FindEncoding,The conditional expression  "charSetUpper.Length > 3 && charSetUpper.StartsWith("ISO") && charSetUpper[3] >= '0' && charSetUpper[3] <= '9'"  is complex.
Complex Conditional,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The conditional expression  "(dateTime.DayOfWeek == DayOfWeek.Monday		&& !dayName.Equals("Mon")) ||  					(dateTime.DayOfWeek == DayOfWeek.Tuesday	&& !dayName.Equals("Tue")) ||  					(dateTime.DayOfWeek == DayOfWeek.Wednesday	&& !dayName.Equals("Wed")) ||  					(dateTime.DayOfWeek == DayOfWeek.Thursday	&& !dayName.Equals("Thu")) ||  					(dateTime.DayOfWeek == DayOfWeek.Friday		&& !dayName.Equals("Fri")) ||  					(dateTime.DayOfWeek == DayOfWeek.Saturday	&& !dayName.Equals("Sat")) ||  					(dateTime.DayOfWeek == DayOfWeek.Sunday		&& !dayName.Equals("Sun"))"  is complex.
Empty Catch Block,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ExtractDateTime,The method has an empty catch block.
Empty Catch Block,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Dispose,The method has an empty catch block.
Magic Number,OpenPop.Mime.Decode,EncodingFinder,C:\repos\foens_hpop\OpenPop\Mime\Decode\EncodingFinder.cs,FindEncoding,The following statement contains a magic number: try  			{  				if (charSetUpper.Contains("WINDOWS") || charSetUpper.Contains("CP"))  				{  					// It seems the characterSet contains an codepage value' which we should use to parse the encoding  					charSetUpper = charSetUpper.Replace("CP"' ""); // Remove cp  					charSetUpper = charSetUpper.Replace("WINDOWS"' ""); // Remove windows  					charSetUpper = charSetUpper.Replace("-"' ""); // Remove - which could be used as cp-1554    					// Now we hope the only thing left in the characterSet is numbers.  					int codepageNumber = int.Parse(charSetUpper' CultureInfo.InvariantCulture);    					return Encoding.GetEncoding(codepageNumber);  				}    				// It seems there is no codepage value in the characterSet. It must be a named encoding    				//Handle missing hyphen after ISO' e.g. ISO8859-15 (#36)  				if (charSetUpper.Length > 3 && charSetUpper.StartsWith("ISO") && charSetUpper[3] >= '0' && charSetUpper[3] <= '9')  				{  					return Encoding.GetEncoding("iso-" + characterSet.Substring(3));  				}    				return Encoding.GetEncoding(characterSet);  			}  			catch (ArgumentException)  			{  				// The encoding could not be found generally.   				// Try to use the FallbackDecoder if it is defined.    				// Check if it is defined  				if (FallbackDecoder == null)  					throw; // It was not defined - throw catched exception    				// Use the FallbackDecoder  				Encoding fallbackDecoderResult = FallbackDecoder(characterSet);    				// Check if the FallbackDecoder had a solution  				if (fallbackDecoderResult != null)  					return fallbackDecoderResult;    				// If no solution was found' throw catched exception  				throw;  			}
Magic Number,OpenPop.Mime.Decode,EncodingFinder,C:\repos\foens_hpop\OpenPop\Mime\Decode\EncodingFinder.cs,FindEncoding,The following statement contains a magic number: try  			{  				if (charSetUpper.Contains("WINDOWS") || charSetUpper.Contains("CP"))  				{  					// It seems the characterSet contains an codepage value' which we should use to parse the encoding  					charSetUpper = charSetUpper.Replace("CP"' ""); // Remove cp  					charSetUpper = charSetUpper.Replace("WINDOWS"' ""); // Remove windows  					charSetUpper = charSetUpper.Replace("-"' ""); // Remove - which could be used as cp-1554    					// Now we hope the only thing left in the characterSet is numbers.  					int codepageNumber = int.Parse(charSetUpper' CultureInfo.InvariantCulture);    					return Encoding.GetEncoding(codepageNumber);  				}    				// It seems there is no codepage value in the characterSet. It must be a named encoding    				//Handle missing hyphen after ISO' e.g. ISO8859-15 (#36)  				if (charSetUpper.Length > 3 && charSetUpper.StartsWith("ISO") && charSetUpper[3] >= '0' && charSetUpper[3] <= '9')  				{  					return Encoding.GetEncoding("iso-" + characterSet.Substring(3));  				}    				return Encoding.GetEncoding(characterSet);  			}  			catch (ArgumentException)  			{  				// The encoding could not be found generally.   				// Try to use the FallbackDecoder if it is defined.    				// Check if it is defined  				if (FallbackDecoder == null)  					throw; // It was not defined - throw catched exception    				// Use the FallbackDecoder  				Encoding fallbackDecoderResult = FallbackDecoder(characterSet);    				// Check if the FallbackDecoder had a solution  				if (fallbackDecoderResult != null)  					return fallbackDecoderResult;    				// If no solution was found' throw catched exception  				throw;  			}
Magic Number,OpenPop.Mime.Decode,EncodingFinder,C:\repos\foens_hpop\OpenPop\Mime\Decode\EncodingFinder.cs,FindEncoding,The following statement contains a magic number: try  			{  				if (charSetUpper.Contains("WINDOWS") || charSetUpper.Contains("CP"))  				{  					// It seems the characterSet contains an codepage value' which we should use to parse the encoding  					charSetUpper = charSetUpper.Replace("CP"' ""); // Remove cp  					charSetUpper = charSetUpper.Replace("WINDOWS"' ""); // Remove windows  					charSetUpper = charSetUpper.Replace("-"' ""); // Remove - which could be used as cp-1554    					// Now we hope the only thing left in the characterSet is numbers.  					int codepageNumber = int.Parse(charSetUpper' CultureInfo.InvariantCulture);    					return Encoding.GetEncoding(codepageNumber);  				}    				// It seems there is no codepage value in the characterSet. It must be a named encoding    				//Handle missing hyphen after ISO' e.g. ISO8859-15 (#36)  				if (charSetUpper.Length > 3 && charSetUpper.StartsWith("ISO") && charSetUpper[3] >= '0' && charSetUpper[3] <= '9')  				{  					return Encoding.GetEncoding("iso-" + characterSet.Substring(3));  				}    				return Encoding.GetEncoding(characterSet);  			}  			catch (ArgumentException)  			{  				// The encoding could not be found generally.   				// Try to use the FallbackDecoder if it is defined.    				// Check if it is defined  				if (FallbackDecoder == null)  					throw; // It was not defined - throw catched exception    				// Use the FallbackDecoder  				Encoding fallbackDecoderResult = FallbackDecoder(characterSet);    				// Check if the FallbackDecoder had a solution  				if (fallbackDecoderResult != null)  					return fallbackDecoderResult;    				// If no solution was found' throw catched exception  				throw;  			}
Magic Number,OpenPop.Mime.Decode,EncodingFinder,C:\repos\foens_hpop\OpenPop\Mime\Decode\EncodingFinder.cs,FindEncoding,The following statement contains a magic number: try  			{  				if (charSetUpper.Contains("WINDOWS") || charSetUpper.Contains("CP"))  				{  					// It seems the characterSet contains an codepage value' which we should use to parse the encoding  					charSetUpper = charSetUpper.Replace("CP"' ""); // Remove cp  					charSetUpper = charSetUpper.Replace("WINDOWS"' ""); // Remove windows  					charSetUpper = charSetUpper.Replace("-"' ""); // Remove - which could be used as cp-1554    					// Now we hope the only thing left in the characterSet is numbers.  					int codepageNumber = int.Parse(charSetUpper' CultureInfo.InvariantCulture);    					return Encoding.GetEncoding(codepageNumber);  				}    				// It seems there is no codepage value in the characterSet. It must be a named encoding    				//Handle missing hyphen after ISO' e.g. ISO8859-15 (#36)  				if (charSetUpper.Length > 3 && charSetUpper.StartsWith("ISO") && charSetUpper[3] >= '0' && charSetUpper[3] <= '9')  				{  					return Encoding.GetEncoding("iso-" + characterSet.Substring(3));  				}    				return Encoding.GetEncoding(characterSet);  			}  			catch (ArgumentException)  			{  				// The encoding could not be found generally.   				// Try to use the FallbackDecoder if it is defined.    				// Check if it is defined  				if (FallbackDecoder == null)  					throw; // It was not defined - throw catched exception    				// Use the FallbackDecoder  				Encoding fallbackDecoderResult = FallbackDecoder(characterSet);    				// Check if the FallbackDecoder had a solution  				if (fallbackDecoderResult != null)  					return fallbackDecoderResult;    				// If no solution was found' throw catched exception  				throw;  			}
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (string part in splitted)  			{  				// Empty strings should not be processed  				if (part.Trim().Length == 0)  					continue;    				string[] keyValue = part.Trim().Split(new [] {'='}' 2);  				if(keyValue.Length == 1)  				{  					collection.Add(new KeyValuePair<string' string>(""' keyValue[0]));  				} else if (keyValue.Length == 2)  				{  					collection.Add(new KeyValuePair<string' string>(keyValue[0]' keyValue[1]));  				} else  				{  					throw new ArgumentException("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  				}  			}
Magic Number,OpenPop.Mime.Decode,Rfc2231Decoder,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2231Decoder.cs,Decode,The following statement contains a magic number: foreach (string part in splitted)  			{  				// Empty strings should not be processed  				if (part.Trim().Length == 0)  					continue;    				string[] keyValue = part.Trim().Split(new [] {'='}' 2);  				if(keyValue.Length == 1)  				{  					collection.Add(new KeyValuePair<string' string>(""' keyValue[0]));  				} else if (keyValue.Length == 2)  				{  					collection.Add(new KeyValuePair<string' string>(keyValue[0]' keyValue[1]));  				} else  				{  					throw new ArgumentException("When splitting the part \"" + part + "\" by = there was " + keyValue.Length + " parts. Only 1 and 2 are supported");  				}  			}
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput[3] == ''')  			{  				string dayName = dateInput.Substring(0' 3);    				// If a dayName was specified. Check that the dateTime and the dayName  				// agrees on which day it is  				// This is just a failure-check and could be left out  				if ((dateTime.DayOfWeek == DayOfWeek.Monday		&& !dayName.Equals("Mon")) ||  					(dateTime.DayOfWeek == DayOfWeek.Tuesday	&& !dayName.Equals("Tue")) ||  					(dateTime.DayOfWeek == DayOfWeek.Wednesday	&& !dayName.Equals("Wed")) ||  					(dateTime.DayOfWeek == DayOfWeek.Thursday	&& !dayName.Equals("Thu")) ||  					(dateTime.DayOfWeek == DayOfWeek.Friday		&& !dayName.Equals("Fri")) ||  					(dateTime.DayOfWeek == DayOfWeek.Saturday	&& !dayName.Equals("Sat")) ||  					(dateTime.DayOfWeek == DayOfWeek.Sunday		&& !dayName.Equals("Sun")))  				{  					DefaultLogger.Log.LogDebug("Day-name does not correspond to the weekday of the date: " + dateInput);					  				}  			}
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput[3] == ''')  			{  				string dayName = dateInput.Substring(0' 3);    				// If a dayName was specified. Check that the dateTime and the dayName  				// agrees on which day it is  				// This is just a failure-check and could be left out  				if ((dateTime.DayOfWeek == DayOfWeek.Monday		&& !dayName.Equals("Mon")) ||  					(dateTime.DayOfWeek == DayOfWeek.Tuesday	&& !dayName.Equals("Tue")) ||  					(dateTime.DayOfWeek == DayOfWeek.Wednesday	&& !dayName.Equals("Wed")) ||  					(dateTime.DayOfWeek == DayOfWeek.Thursday	&& !dayName.Equals("Thu")) ||  					(dateTime.DayOfWeek == DayOfWeek.Friday		&& !dayName.Equals("Fri")) ||  					(dateTime.DayOfWeek == DayOfWeek.Saturday	&& !dayName.Equals("Sat")) ||  					(dateTime.DayOfWeek == DayOfWeek.Sunday		&& !dayName.Equals("Sun")))  				{  					DefaultLogger.Log.LogDebug("Day-name does not correspond to the weekday of the date: " + dateInput);					  				}  			}
Magic Number,OpenPop.Mime.Decode,Rfc2822DateTime,C:\repos\foens_hpop\OpenPop\Mime\Decode\Rfc2822DateTime.cs,ValidateDayNameIfAny,The following statement contains a magic number: if (dateInput.Length >= 4 && dateInput[3] == ''')  			{  				string dayName = dateInput.Substring(0' 3);    				// If a dayName was specified. Check that the dateTime and the dayName  				// agrees on which day it is  				// This is just a failure-check and could be left out  				if ((dateTime.DayOfWeek == DayOfWeek.Monday		&& !dayName.Equals("Mon")) ||  					(dateTime.DayOfWeek == DayOfWeek.Tuesday	&& !dayName.Equals("Tue")) ||  					(dateTime.DayOfWeek == DayOfWeek.Wednesday	&& !dayName.Equals("Wed")) ||  					(dateTime.DayOfWeek == DayOfWeek.Thursday	&& !dayName.Equals("Thu")) ||  					(dateTime.DayOfWeek == DayOfWeek.Friday		&& !dayName.Equals("Fri")) ||  					(dateTime.DayOfWeek == DayOfWeek.Saturday	&& !dayName.Equals("Sat")) ||  					(dateTime.DayOfWeek == DayOfWeek.Sunday		&& !dayName.Equals("Sun")))  				{  					DefaultLogger.Log.LogDebug("Day-name does not correspond to the weekday of the date: " + dateInput);					  				}  			}
Magic Number,OpenPop.Mime.Decode,Utility,C:\repos\foens_hpop\OpenPop\Mime\Decode\Utility.cs,RemoveQuotesIfAny,The following statement contains a magic number: if(text.Length > 1 && text[0] == '"' && text[text.Length-1] == '"')  			{  				// Remove quotes at both ends  				return text.Substring(1' text.Length - 2);  			}
Magic Number,OpenPop.Mime.Decode,Base64,C:\repos\foens_hpop\OpenPop\Mime\Decode\Base64.cs,Decode,The following statement contains a magic number: try  			{  				using (MemoryStream memoryStream = new MemoryStream())  				{  					base64Encoded = base64Encoded.Replace("\r\n"' "");  					base64Encoded = base64Encoded.Replace("\t"' "");  					base64Encoded = base64Encoded.Replace(" "' "");    					byte[] inputBytes = Encoding.ASCII.GetBytes(base64Encoded);    					using (FromBase64Transform transform = new FromBase64Transform(FromBase64TransformMode.DoNotIgnoreWhiteSpaces))  					{  						byte[] outputBytes = new byte[transform.OutputBlockSize];    						// Transform the data in chunks the size of InputBlockSize.  						const int inputBlockSize = 4;  						int currentOffset = 0;  						while (inputBytes.Length - currentOffset > inputBlockSize)  						{  							transform.TransformBlock(inputBytes' currentOffset' inputBlockSize' outputBytes' 0);  							currentOffset += inputBlockSize;  							memoryStream.Write(outputBytes' 0' transform.OutputBlockSize);  						}    						// Transform the final block of data.  						outputBytes = transform.TransformFinalBlock(inputBytes' currentOffset' inputBytes.Length - currentOffset);  						memoryStream.Write(outputBytes' 0' outputBytes.Length);  					}    					return memoryStream.ToArray();  				}  			} catch (FormatException e)  			{  				DefaultLogger.Log.LogError("Base64: (FormatException) " + e.Message + "\r\nOn string: " + base64Encoded);  				throw;  			}
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream())  			{  				// Remove illegal control characters  				toDecode = RemoveIllegalControlCharacters(toDecode);    				// Run through the whole string that needs to be decoded  				for (int i = 0; i < toDecode.Length; i++)  				{  					char currentChar = toDecode[i];  					if (currentChar == '=')  					{  						// Check that there is at least two characters behind the equal sign  						if (toDecode.Length - i < 3)  						{  							// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  							WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    							// Since it was the last part' we should stop parsing anymore  							break;  						}    						// Decode the Quoted-Printable part  						string quotedPrintablePart = toDecode.Substring(i' 3);  						WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    						// We now consumed two extra characters. Go forward two extra characters  						i += 2;  					} else  					{  						// This character is not quoted printable hex encoded.    						// Could it be the _ character' which represents space  						// and are we using the encoded word variant of QuotedPrintable  						if (currentChar == '_' && encodedWordVariant)  						{  							// The RFC specifies that the "_" always represents hexadecimal 20 even if the  							// SPACE character occupies a different code position in the character set in use.  							byteArrayBuilder.WriteByte(0x20);  						}  						else  						{  							// This is not encoded at all. This is a literal which should just be included into the output.  							byteArrayBuilder.WriteByte((byte)currentChar);  						}  					}  				}    				return byteArrayBuilder.ToArray();  			}
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream())  			{  				// Remove illegal control characters  				toDecode = RemoveIllegalControlCharacters(toDecode);    				// Run through the whole string that needs to be decoded  				for (int i = 0; i < toDecode.Length; i++)  				{  					char currentChar = toDecode[i];  					if (currentChar == '=')  					{  						// Check that there is at least two characters behind the equal sign  						if (toDecode.Length - i < 3)  						{  							// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  							WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    							// Since it was the last part' we should stop parsing anymore  							break;  						}    						// Decode the Quoted-Printable part  						string quotedPrintablePart = toDecode.Substring(i' 3);  						WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    						// We now consumed two extra characters. Go forward two extra characters  						i += 2;  					} else  					{  						// This character is not quoted printable hex encoded.    						// Could it be the _ character' which represents space  						// and are we using the encoded word variant of QuotedPrintable  						if (currentChar == '_' && encodedWordVariant)  						{  							// The RFC specifies that the "_" always represents hexadecimal 20 even if the  							// SPACE character occupies a different code position in the character set in use.  							byteArrayBuilder.WriteByte(0x20);  						}  						else  						{  							// This is not encoded at all. This is a literal which should just be included into the output.  							byteArrayBuilder.WriteByte((byte)currentChar);  						}  					}  				}    				return byteArrayBuilder.ToArray();  			}
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,Rfc2047QuotedPrintableDecode,The following statement contains a magic number: using (MemoryStream byteArrayBuilder = new MemoryStream())  			{  				// Remove illegal control characters  				toDecode = RemoveIllegalControlCharacters(toDecode);    				// Run through the whole string that needs to be decoded  				for (int i = 0; i < toDecode.Length; i++)  				{  					char currentChar = toDecode[i];  					if (currentChar == '=')  					{  						// Check that there is at least two characters behind the equal sign  						if (toDecode.Length - i < 3)  						{  							// We are at the end of the toDecode string' but something is missing. Handle it the way RFC 2045 states  							WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSignNotLongEnough(toDecode.Substring(i)));    							// Since it was the last part' we should stop parsing anymore  							break;  						}    						// Decode the Quoted-Printable part  						string quotedPrintablePart = toDecode.Substring(i' 3);  						WriteAllBytesToStream(byteArrayBuilder' DecodeEqualSign(quotedPrintablePart));    						// We now consumed two extra characters. Go forward two extra characters  						i += 2;  					} else  					{  						// This character is not quoted printable hex encoded.    						// Could it be the _ character' which represents space  						// and are we using the encoded word variant of QuotedPrintable  						if (currentChar == '_' && encodedWordVariant)  						{  							// The RFC specifies that the "_" always represents hexadecimal 20 even if the  							// SPACE character occupies a different code position in the character set in use.  							byteArrayBuilder.WriteByte(0x20);  						}  						else  						{  							// This is not encoded at all. This is a literal which should just be included into the output.  							byteArrayBuilder.WriteByte((byte)currentChar);  						}  					}  				}    				return byteArrayBuilder.ToArray();  			}
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSignNotLongEnough,The following statement contains a magic number: if (decode.Length >= 3)  				throw new ArgumentException("decode must have length lower than 3"' "decode");
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: if (decode.Length != 3)  				throw new ArgumentException("decode must have length 3"' "decode");
Magic Number,OpenPop.Mime.Decode,QuotedPrintable,C:\repos\foens_hpop\OpenPop\Mime\Decode\QuotedPrintable.cs,DecodeEqualSign,The following statement contains a magic number: try  			{  				// The number part of the string is the last two digits. Here we simply remove the equal sign  				string numberString = decode.Substring(1);    				// Now we create a byte array with the converted number encoded in the string as a hex value (base 16)  				// This will also handle illegal encodings like =3d where the hex digits are not uppercase'  				// which is a robustness requirement from RFC 2045.  				byte[] oneByte = new[] { Convert.ToByte(numberString' 16) };    				// Simply return our one byte byte array  				return oneByte;  			} catch (FormatException)  			{  				// RFC 2045 says about robust implementation:  				// An "=" followed by a character that is neither a  				// hexadecimal digit (including "abcdef") nor the CR  				// character of a CRLF pair is illegal.  This case can be  				// the result of US-ASCII text having been included in a  				// quoted-printable part of a message without itself  				// having been subjected to quoted-printable encoding.  A  				// reasonable approach by a robust implementation might be  				// to include the "=" character and the following  				// character in the decoded data without any  				// transformation and' if possible' indicate to the user  				// that proper decoding was not possible at this point in  				// the data.    				// So we choose to believe this is actually an un-encoded string  				// Therefore it must be in US-ASCII and we will return the bytes it corrosponds to  				return Encoding.ASCII.GetBytes(decode);  			}
Magic Number,OpenPop.Mime.Header,HeaderFieldParser,C:\repos\foens_hpop\OpenPop\Mime\Header\HeaderFieldParser.cs,stripRfc822Ctls,The following statement contains a magic number: for(int i = 0; i <= 31; i++)  			{  				char c = (char)i;  				s = s.Replace(c.ToString()' "");  			}
Magic Number,OpenPop.Mime.Header,HeaderFieldParser,C:\repos\foens_hpop\OpenPop\Mime\Header\HeaderFieldParser.cs,stripRfc822Ctls,The following statement contains a magic number: s = s.Replace(((char)127).ToString()' "");
Magic Number,OpenPop.Mime,Message,C:\repos\foens_hpop\OpenPop\Mime\Message.cs,Load,The following statement contains a magic number: using (MemoryStream outStream = new MemoryStream())  			{  #if DOTNET4  				// TODO: Enable using native v4 framework methods when support is formally added.  				messageStream.CopyTo(outStream);  #else  				int bytesRead;  				byte[] buffer = new byte[4096];    				while ((bytesRead = messageStream.Read(buffer' 0' 4096)) > 0)  				{  					outStream.Write(buffer' 0' bytesRead);  				}  #endif  				byte[] content = outStream.ToArray();    				return new Message(content' parsingErrorHandler);  			}
Magic Number,OpenPop.Mime,Message,C:\repos\foens_hpop\OpenPop\Mime\Message.cs,Load,The following statement contains a magic number: using (MemoryStream outStream = new MemoryStream())  			{  #if DOTNET4  				// TODO: Enable using native v4 framework methods when support is formally added.  				messageStream.CopyTo(outStream);  #else  				int bytesRead;  				byte[] buffer = new byte[4096];    				while ((bytesRead = messageStream.Read(buffer' 0' 4096)) > 0)  				{  					outStream.Write(buffer' 0' bytesRead);  				}  #endif  				byte[] content = outStream.ToArray();    				return new Message(content' parsingErrorHandler);  			}
Magic Number,OpenPop.Pop3,CramMd5,C:\repos\foens_hpop\OpenPop\Pop3\CramMd5.cs,CramMd5,The following statement contains a magic number: ipad = new byte[64];
Magic Number,OpenPop.Pop3,CramMd5,C:\repos\foens_hpop\OpenPop\Pop3\CramMd5.cs,CramMd5,The following statement contains a magic number: opad = new byte[64];
Magic Number,OpenPop.Pop3,CramMd5,C:\repos\foens_hpop\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if (passwordBytes.Length > 64)  			{  				passwordBytes = new MD5CryptoServiceProvider().ComputeHash(passwordBytes);  			}
Magic Number,OpenPop.Pop3,CramMd5,C:\repos\foens_hpop\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if(passwordBytes.Length != 64)  			{  				byte[] returner = new byte[64];  				for(int i = 0; i<passwordBytes.Length; i++)  				{  					returner[i] = passwordBytes[i];  				}  				return returner;  			}
Magic Number,OpenPop.Pop3,CramMd5,C:\repos\foens_hpop\OpenPop\Pop3\CramMd5.cs,GetSharedSecretInBytes,The following statement contains a magic number: if(passwordBytes.Length != 64)  			{  				byte[] returner = new byte[64];  				for(int i = 0; i<passwordBytes.Length; i++)  				{  					returner[i] = passwordBytes[i];  				}  				return returner;  			}
Magic Number,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Connect,The following statement contains a magic number: const int defaultTimeOut = 60000;
Magic Number,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,AuthenticateUsingCramMd5,The following statement contains a magic number: string challenge = LastServerResponse.Substring(2);
Magic Number,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,GetMessageUid,The following statement contains a magic number: return LastServerResponse.Split(' ')[2];
Magic Number,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,GetMessageSize,The following statement contains a magic number: return SendCommandIntResponse("LIST " + messageNumber' 2);
Missing Default,OpenPop.Pop3,Pop3Client,C:\repos\foens_hpop\OpenPop\Pop3\Pop3Client.cs,Authenticate,The following switch statement is missing a default case: switch (authenticationMethod)  				{  					case AuthenticationMethod.UsernameAndPassword:  						AuthenticateUsingUserAndPassword(username' password);  						break;    					case AuthenticationMethod.Apop:  						AuthenticateUsingApop(username' password);  						break;    					case AuthenticationMethod.Auto:  						if (ApopSupported)  							AuthenticateUsingApop(username' password);  						else  							AuthenticateUsingUserAndPassword(username' password);  						break;    					case AuthenticationMethod.CramMd5:  						AuthenticateUsingCramMd5(username' password);  						break;  				}
