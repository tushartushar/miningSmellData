Implementation smell,Namespace,Class,File,Method,Description
Long Method,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The method has 217 lines of code.
Long Method,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The method has 115 lines of code.
Complex Method,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,Cyclomatic complexity of the method is 9
Complex Method,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,Cyclomatic complexity of the method is 31
Long Parameter List,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,GenerateDigestAuthorization,The method has 6 parameters. Parameters: username' password' realm' nonce' url' command
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The length of the statement  "                uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]); " is 148.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The length of the statement  "                uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]); " is 145.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The length of the statement  "                    rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0); " is 123.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The length of the statement  "                    rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes " is 167.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The length of the statement  "                    List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame " is 140.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The length of the statement  "                    } else if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==true)) { " is 125.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The length of the statement  "                                    Interleaved = new PortCouple(video_data_channel' video_rtcp_channel)' // Channel 0 for video. Channel 1 for RTCP status reports " is 127.
Long Statement,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The length of the statement  "                                    ClientPort = new PortCouple(video_data_channel' video_rtcp_channel)' // a Channel for video. a Channel for RTCP status reports " is 126.
Long Statement,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Packet,The length of the statement  "            temporary_rtp_payloads.Add(rtp_payload); // Todo Could optimise this and go direct to Process Frame if just 1 packet in frame " is 125.
Long Statement,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The length of the statement  "            List<byte[]> nal_units = new List<byte[]>(); // Stores the NAL units for a Video Frame. May be more than one NAL unit in a video frame. " is 135.
Long Statement,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The length of the statement  "            Console.WriteLine("Norm=" + norm + " ST-A=" + stap_a + " ST-B=" + stap_b + " M16=" + mtap16 + " M24=" + mtap24 + " FU-A=" + fu_a + " FU-B=" + fu_b); " is 148.
Empty Catch Block,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,DoWorkerJob,The method has an empty catch block.
Empty Catch Block,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,DoWorkerJob,The method has an empty catch block.
Empty Catch Block,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The method has an empty catch block.
Magic Number,RtspClientExample,Program,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Main,The following statement contains a magic number: while (readline == null) {                  readline = Console.ReadLine();                    // Avoid maxing out CPU on systems that instantly return null for ReadLine                  if (readline == null) Thread.Sleep(500);              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,RTSPClient,The following statement contains a magic number: if (rtp_transport == RTP_TRANSPORT.UDP)              {                  udp_pair = new UDPSocket(50000' 50020); // give a range of 10 pairs (20 addresses) to try incase some address are in use                  udp_pair.DataReceived += Rtp_DataReceived;                  udp_pair.Start(); // start listening for data on the UDP ports              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,RTSPClient,The following statement contains a magic number: if (rtp_transport == RTP_TRANSPORT.UDP)              {                  udp_pair = new UDPSocket(50000' 50020); // give a range of 10 pairs (20 addresses) to try incase some address are in use                  udp_pair.DataReceived += Rtp_DataReceived;                  udp_pair.Start(); // start listening for data on the UDP ports              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtp_DataReceived,The following statement contains a magic number: if (data_received.Channel == video_data_channel)              {                  // Received some Video Data on the correct channel.                    // RTP Packet Header                  // 0 - Version' P' X' CC' M' PT and Sequence Number                  //32 - Timestamp                  //64 - SSRC                  //96 - CSRCs (optional)                  //nn - Extension ID and Length                  //nn - Extension header                    int rtp_version = (e.Message.Data[0] >> 6);                  int rtp_padding = (e.Message.Data[0] >> 5) & 0x01;                  int rtp_extension = (e.Message.Data[0] >> 4) & 0x01;                  int rtp_csrc_count = (e.Message.Data[0] >> 0) & 0x0F;                  int rtp_marker = (e.Message.Data[1] >> 7) & 0x01;                  int rtp_payload_type = (e.Message.Data[1] >> 0) & 0x7F;                  uint rtp_sequence_number = ((uint)e.Message.Data[2] << 8) + (uint)(e.Message.Data[3]);                  uint rtp_timestamp = ((uint)e.Message.Data[4] << 24) + (uint)(e.Message.Data[5] << 16) + (uint)(e.Message.Data[6] << 8) + (uint)(e.Message.Data[7]);                  uint rtp_ssrc = ((uint)e.Message.Data[8] << 24) + (uint)(e.Message.Data[9] << 16) + (uint)(e.Message.Data[10] << 8) + (uint)(e.Message.Data[11]);                    int rtp_payload_start = 4 // V'P'M'SEQ                                      + 4 // time stamp                                      + 4 // ssrc                                      + (4 * rtp_csrc_count); // zero or more csrcs                    uint rtp_extension_id = 0;                  uint rtp_extension_size = 0;                  if (rtp_extension == 1)                  {                      rtp_extension_id = ((uint)e.Message.Data[rtp_payload_start + 0] << 8) + (uint)(e.Message.Data[rtp_payload_start + 1] << 0);                      rtp_extension_size = ((uint)e.Message.Data[rtp_payload_start + 2] << 8) + (uint)(e.Message.Data[rtp_payload_start + 3] << 0) * 4; // units of extension_size is 4-bytes  	                rtp_payload_start += 4 + (int)rtp_extension_size;  // extension header and extension payload                  }                    Console.WriteLine("RTP Data"                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     + " Seq=" + rtp_sequence_number                                     + " Time (MS)=" + rtp_timestamp / 90 // convert from 90kHZ clock to ms                                     + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length);                    String msg = "RTP Data " + rtp_count++                                     + " V=" + rtp_version                                     + " P=" + rtp_padding                                     + " X=" + rtp_extension                                     + " CC=" + rtp_csrc_count                                     + " M=" + rtp_marker                                     + " PT=" + rtp_payload_type                                     //             + " Seq=" + rtp_sequence_number                                     //             + " Time=" + rtp_timestamp                                     //             + " SSRC=" + rtp_ssrc                                     + " Size=" + e.Message.Data.Length;                  if (fs2 != null) fs2.WriteLine(msg);                  if (fs2 != null) fs2.Flush();                      // Check the payload type in the RTP packet matches the Payload Type value from the SDP                  if (rtp_payload_type != video_payload)                  {                      Console.WriteLine("Ignoring this RTP payload");                      return; // ignore this data                  }                    if (rtp_payload_type >= 96 && rtp_payload_type <= 127 && video_codec.Equals("H264")) {                      // H264 RTP Packet                        // If rtp_marker is '1' then this is the final transmission for this packet.                      // If rtp_marker is '0' we need to accumulate data with the same timestamp                        // ToDo - Check Timestamp                      // Add the RTP packet to the tempoary_rtp list until we have a complete 'Frame'                        byte[] rtp_payload = new byte[e.Message.Data.Length - rtp_payload_start]; // payload with RTP header removed                      System.Array.Copy(e.Message.Data' rtp_payload_start' rtp_payload' 0' rtp_payload.Length); // copy payload                        List<byte[]> nal_units = h264Payload.Process_H264_RTP_Packet(rtp_payload' rtp_marker); // this will cache the Packets until there is a Frame                        if (nal_units == null) {                          // we have not passed in enough RTP packets to make a Frame of video                      } else {                          // we have a frame of NAL Units. Write them to the file                          Output_NAL(nal_units);                      }                  }                    else if (rtp_payload_type == 26) {                      Console.WriteLine("No parser for JPEG RTP packets");                    } else {                      Console.WriteLine("No parser for this RTP payload");                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.Headers.ContainsKey(RtspHeaderNames.WWWAuthenticate)) {                  String www_authenticate = message.Headers[RtspHeaderNames.WWWAuthenticate];                    // Parse www_authenticate                  // EG:   Digest realm="AXIS_WS_ACCC8E3A0A8F"' nonce="000057c3Y810622bff50b36005eb5efeae118626a161bf"' stale=FALSE                  string[] items = www_authenticate.Split(new char[] { ''' ' ' ' });                  foreach (string item in items) {                      // Split on the = symbol and load in                      string[] parts = item.Split(new char[] { '=' });                      if (parts.Count() >= 2 && parts[0].Trim().Equals("realm"))                          realm = parts[1].Trim(new char[] {' '''\"'}); // trim space and quotes                      else if (parts.Count() >= 2 && parts[0].Trim().Equals("nonce"))                          nonce = parts[1].Trim(new char[] {' '''\"'}); // trim space and quotes                  }                    Console.WriteLine("WWW Authorize parsed for " + realm + " " + nonce);              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.Headers.ContainsKey(RtspHeaderNames.WWWAuthenticate)) {                  String www_authenticate = message.Headers[RtspHeaderNames.WWWAuthenticate];                    // Parse www_authenticate                  // EG:   Digest realm="AXIS_WS_ACCC8E3A0A8F"' nonce="000057c3Y810622bff50b36005eb5efeae118626a161bf"' stale=FALSE                  string[] items = www_authenticate.Split(new char[] { ''' ' ' ' });                  foreach (string item in items) {                      // Split on the = symbol and load in                      string[] parts = item.Split(new char[] { '=' });                      if (parts.Count() >= 2 && parts[0].Trim().Equals("realm"))                          realm = parts[1].Trim(new char[] {' '''\"'}); // trim space and quotes                      else if (parts.Count() >= 2 && parts[0].Trim().Equals("nonce"))                          nonce = parts[1].Trim(new char[] {' '''\"'}); // trim space and quotes                  }                    Console.WriteLine("WWW Authorize parsed for " + realm + " " + nonce);              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.OriginalRequest != null && message.OriginalRequest is Rtsp.Messages.RtspRequestOptions)              {                  if (message.CSeq == 1)                  {                      // Start a Timer to send an OPTIONS command (for keepalive) every 20 seconds                      keepalive_timer = new System.Timers.Timer();                      keepalive_timer.Elapsed += Timer_Elapsed;                      keepalive_timer.Interval = 20 * 1000;                      keepalive_timer.Enabled = true;                        // send the DESCRIBE. First time around we have no WWW-Authorise                      Rtsp.Messages.RtspRequest describe_message = new Rtsp.Messages.RtspRequestDescribe();                      describe_message.RtspUri = new Uri(url);                      rtsp_client.SendMessage(describe_message);                  }                  else                  {                      // do nothing                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.OriginalRequest != null && message.OriginalRequest is Rtsp.Messages.RtspRequestOptions)              {                  if (message.CSeq == 1)                  {                      // Start a Timer to send an OPTIONS command (for keepalive) every 20 seconds                      keepalive_timer = new System.Timers.Timer();                      keepalive_timer.Elapsed += Timer_Elapsed;                      keepalive_timer.Interval = 20 * 1000;                      keepalive_timer.Enabled = true;                        // send the DESCRIBE. First time around we have no WWW-Authorise                      Rtsp.Messages.RtspRequest describe_message = new Rtsp.Messages.RtspRequestDescribe();                      describe_message.RtspUri = new Uri(url);                      rtsp_client.SendMessage(describe_message);                  }                  else                  {                      // do nothing                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.OriginalRequest != null && message.OriginalRequest is Rtsp.Messages.RtspRequestDescribe)              {                    // Got a reply for DESCRIBE                    // First time we send DESCRIBE we will not have the authorization Nonce so we                  // handle the Unauthorized 401 error here and send a new DESCRIBE message                    if (message.IsOk == false) {                      Console.WriteLine("Got Error in DESCRIBE Reply " + message.ReturnCode + " " + message.ReturnMessage);                        if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==false)) {                          // Error 401 - Unauthorized' but the request did not use Authorizarion.                            if (username == null || password == null) {                              // we do nothave a username or password. Abort                              return;                          }                          // Send a new DESCRIBE with authorization                          String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                  realm'nonce'url'"DESCRIBE");                                                    Rtsp.Messages.RtspRequest describe_message = new Rtsp.Messages.RtspRequestDescribe();                          describe_message.RtspUri = new Uri(url);                          if (digest_authorization!=null) describe_message.Headers.Add(RtspHeaderNames.Authorization'digest_authorization);                          rtsp_client.SendMessage(describe_message);                          return;                      } else if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==true)) {                          // Authorization failed                          return;                      } else {                          // some other error                          return;                      }                                                }                    // Examine the SDP                    Console.Write(System.Text.Encoding.UTF8.GetString(message.Data));                    Rtsp.Sdp.SdpFile sdp_data;                  using (StreamReader sdp_stream = new StreamReader(new MemoryStream(message.Data)))                  {                      sdp_data = Rtsp.Sdp.SdpFile.Read(sdp_stream);                  }                    // Process each 'Media' Attribute in the SDP (each sub-stream)                  // If the attribute is for Video' then carry out a SETUP and a PLAY                  // Only do this for the first Video attribute in case there is more than one in the SDP                    for (int x = 0; x < sdp_data.Medias.Count; x++)                  {                      if (sdp_data.Medias[x].MediaType == Rtsp.Sdp.Media.MediaTypes.video)                      {                            // We only want the first video sub-stream                          if (video_payload == -1)                          {                              video_payload = sdp_data.Medias[x].PayloadType;                                // search the attributes for control' fmtp and rtpmap                              String control = "";  // the "track" or "stream id"                              Rtsp.Sdp.AttributFmtp fmtp = null; // holds SPS and PPS in base64 (h264)                              Rtsp.Sdp.AttributRtpMap rtpmap = null; // custom payload (>=96) details                              foreach (Rtsp.Sdp.Attribut attrib in sdp_data.Medias[x].Attributs)                              {                                  if (attrib.Key.Equals("control")) {                                      String sdp_control = attrib.Value;                                      if (sdp_control.ToLower().StartsWith("rtsp://")) {                                          control = sdp_control; //absolute path                                      } else {                                          control = url + "/" + sdp_control; // relative path                                      }                                  }                                  if (attrib.Key.Equals("fmtp")) fmtp = attrib as Rtsp.Sdp.AttributFmtp;                                  if (attrib.Key.Equals("rtpmap")) rtpmap = attrib as Rtsp.Sdp.AttributRtpMap;                              }                                // If the rtpmap contains H264 then split the fmtp to get the sprop-parameter-sets which hold the SPS and PPS in base64                              if (rtpmap!= null && rtpmap.Value.Contains("H264") && fmtp != null)                              {                                  video_codec = "H264";                                  var param = Rtsp.Sdp.H264Parameters.Parse(fmtp.FormatParameter);                                  var sps_pps = param.SpropParameterSets;                                  if (sps_pps.Count() >= 2) {                                      byte[] sps = sps_pps[0];                                      byte[] pps = sps_pps[1];                                      Output_SPS_PPS(sps'pps); // output SPS and PPS                                  }                              }                                RtspTransport transport = null;                              if (rtp_transport == RTP_TRANSPORT.TCP)                              {                                    // Server interleaves the RTP packets over the RTSP connection                                  // Example for TCP mode (RTP over RTSP)   Transport: RTP/AVP/TCP;interleaved=0-1                                  video_data_channel = 0;  // Used in DataReceived event handler                                  video_rtcp_channel = 1;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.TCP'                                      Interleaved = new PortCouple(video_data_channel' video_rtcp_channel)' // Channel 0 for video. Channel 1 for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.UDP)                              {                                  // Server sends the RTP packets to a Pair of UDP Ports (one for data' one for rtcp control messages)                                  // Example for UDP mode                   Transport: RTP/AVP;unicast;client_port=8000-8001                                  video_data_channel = udp_pair.data_port;     // Used in DataReceived event handler                                  video_rtcp_channel = udp_pair.control_port;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = false'                                      ClientPort = new PortCouple(video_data_channel' video_rtcp_channel)' // a Channel for video. a Channel for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.MULTICAST)                              {                                  // Server sends the RTP packets to a Pair of UDP ports (one for data' one for rtcp control messages)                                  // using Multicast Address and Ports that are in the reply to the SETUP message                                  // Example for MULTICAST mode     Transport: RTP/AVP;multicast                                  video_data_channel = 0; // we get this information in the SETUP message reply                                  video_rtcp_channel = 0; // we get this information in the SETUP message reply                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = true                                  };                              }                                // Add authorization (if there is a username and password)                              String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                    realm'nonce'url'"SETUP");                                // Send SETUP                              Rtsp.Messages.RtspRequestSetup setup_message = new Rtsp.Messages.RtspRequestSetup();                              setup_message.RtspUri = new Uri(control);                              setup_message.AddTransport(transport);                              if (digest_authorization!=null) setup_message.Headers.Add("Authorization"'digest_authorization);                              rtsp_client.SendMessage(setup_message);                          }                      }                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.OriginalRequest != null && message.OriginalRequest is Rtsp.Messages.RtspRequestDescribe)              {                    // Got a reply for DESCRIBE                    // First time we send DESCRIBE we will not have the authorization Nonce so we                  // handle the Unauthorized 401 error here and send a new DESCRIBE message                    if (message.IsOk == false) {                      Console.WriteLine("Got Error in DESCRIBE Reply " + message.ReturnCode + " " + message.ReturnMessage);                        if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==false)) {                          // Error 401 - Unauthorized' but the request did not use Authorizarion.                            if (username == null || password == null) {                              // we do nothave a username or password. Abort                              return;                          }                          // Send a new DESCRIBE with authorization                          String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                  realm'nonce'url'"DESCRIBE");                                                    Rtsp.Messages.RtspRequest describe_message = new Rtsp.Messages.RtspRequestDescribe();                          describe_message.RtspUri = new Uri(url);                          if (digest_authorization!=null) describe_message.Headers.Add(RtspHeaderNames.Authorization'digest_authorization);                          rtsp_client.SendMessage(describe_message);                          return;                      } else if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==true)) {                          // Authorization failed                          return;                      } else {                          // some other error                          return;                      }                                                }                    // Examine the SDP                    Console.Write(System.Text.Encoding.UTF8.GetString(message.Data));                    Rtsp.Sdp.SdpFile sdp_data;                  using (StreamReader sdp_stream = new StreamReader(new MemoryStream(message.Data)))                  {                      sdp_data = Rtsp.Sdp.SdpFile.Read(sdp_stream);                  }                    // Process each 'Media' Attribute in the SDP (each sub-stream)                  // If the attribute is for Video' then carry out a SETUP and a PLAY                  // Only do this for the first Video attribute in case there is more than one in the SDP                    for (int x = 0; x < sdp_data.Medias.Count; x++)                  {                      if (sdp_data.Medias[x].MediaType == Rtsp.Sdp.Media.MediaTypes.video)                      {                            // We only want the first video sub-stream                          if (video_payload == -1)                          {                              video_payload = sdp_data.Medias[x].PayloadType;                                // search the attributes for control' fmtp and rtpmap                              String control = "";  // the "track" or "stream id"                              Rtsp.Sdp.AttributFmtp fmtp = null; // holds SPS and PPS in base64 (h264)                              Rtsp.Sdp.AttributRtpMap rtpmap = null; // custom payload (>=96) details                              foreach (Rtsp.Sdp.Attribut attrib in sdp_data.Medias[x].Attributs)                              {                                  if (attrib.Key.Equals("control")) {                                      String sdp_control = attrib.Value;                                      if (sdp_control.ToLower().StartsWith("rtsp://")) {                                          control = sdp_control; //absolute path                                      } else {                                          control = url + "/" + sdp_control; // relative path                                      }                                  }                                  if (attrib.Key.Equals("fmtp")) fmtp = attrib as Rtsp.Sdp.AttributFmtp;                                  if (attrib.Key.Equals("rtpmap")) rtpmap = attrib as Rtsp.Sdp.AttributRtpMap;                              }                                // If the rtpmap contains H264 then split the fmtp to get the sprop-parameter-sets which hold the SPS and PPS in base64                              if (rtpmap!= null && rtpmap.Value.Contains("H264") && fmtp != null)                              {                                  video_codec = "H264";                                  var param = Rtsp.Sdp.H264Parameters.Parse(fmtp.FormatParameter);                                  var sps_pps = param.SpropParameterSets;                                  if (sps_pps.Count() >= 2) {                                      byte[] sps = sps_pps[0];                                      byte[] pps = sps_pps[1];                                      Output_SPS_PPS(sps'pps); // output SPS and PPS                                  }                              }                                RtspTransport transport = null;                              if (rtp_transport == RTP_TRANSPORT.TCP)                              {                                    // Server interleaves the RTP packets over the RTSP connection                                  // Example for TCP mode (RTP over RTSP)   Transport: RTP/AVP/TCP;interleaved=0-1                                  video_data_channel = 0;  // Used in DataReceived event handler                                  video_rtcp_channel = 1;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.TCP'                                      Interleaved = new PortCouple(video_data_channel' video_rtcp_channel)' // Channel 0 for video. Channel 1 for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.UDP)                              {                                  // Server sends the RTP packets to a Pair of UDP Ports (one for data' one for rtcp control messages)                                  // Example for UDP mode                   Transport: RTP/AVP;unicast;client_port=8000-8001                                  video_data_channel = udp_pair.data_port;     // Used in DataReceived event handler                                  video_rtcp_channel = udp_pair.control_port;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = false'                                      ClientPort = new PortCouple(video_data_channel' video_rtcp_channel)' // a Channel for video. a Channel for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.MULTICAST)                              {                                  // Server sends the RTP packets to a Pair of UDP ports (one for data' one for rtcp control messages)                                  // using Multicast Address and Ports that are in the reply to the SETUP message                                  // Example for MULTICAST mode     Transport: RTP/AVP;multicast                                  video_data_channel = 0; // we get this information in the SETUP message reply                                  video_rtcp_channel = 0; // we get this information in the SETUP message reply                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = true                                  };                              }                                // Add authorization (if there is a username and password)                              String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                    realm'nonce'url'"SETUP");                                // Send SETUP                              Rtsp.Messages.RtspRequestSetup setup_message = new Rtsp.Messages.RtspRequestSetup();                              setup_message.RtspUri = new Uri(control);                              setup_message.AddTransport(transport);                              if (digest_authorization!=null) setup_message.Headers.Add("Authorization"'digest_authorization);                              rtsp_client.SendMessage(setup_message);                          }                      }                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Rtsp_MessageReceived,The following statement contains a magic number: if (message.OriginalRequest != null && message.OriginalRequest is Rtsp.Messages.RtspRequestDescribe)              {                    // Got a reply for DESCRIBE                    // First time we send DESCRIBE we will not have the authorization Nonce so we                  // handle the Unauthorized 401 error here and send a new DESCRIBE message                    if (message.IsOk == false) {                      Console.WriteLine("Got Error in DESCRIBE Reply " + message.ReturnCode + " " + message.ReturnMessage);                        if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==false)) {                          // Error 401 - Unauthorized' but the request did not use Authorizarion.                            if (username == null || password == null) {                              // we do nothave a username or password. Abort                              return;                          }                          // Send a new DESCRIBE with authorization                          String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                  realm'nonce'url'"DESCRIBE");                                                    Rtsp.Messages.RtspRequest describe_message = new Rtsp.Messages.RtspRequestDescribe();                          describe_message.RtspUri = new Uri(url);                          if (digest_authorization!=null) describe_message.Headers.Add(RtspHeaderNames.Authorization'digest_authorization);                          rtsp_client.SendMessage(describe_message);                          return;                      } else if (message.ReturnCode == 401 && (message.OriginalRequest.Headers.ContainsKey(RtspHeaderNames.Authorization)==true)) {                          // Authorization failed                          return;                      } else {                          // some other error                          return;                      }                                                }                    // Examine the SDP                    Console.Write(System.Text.Encoding.UTF8.GetString(message.Data));                    Rtsp.Sdp.SdpFile sdp_data;                  using (StreamReader sdp_stream = new StreamReader(new MemoryStream(message.Data)))                  {                      sdp_data = Rtsp.Sdp.SdpFile.Read(sdp_stream);                  }                    // Process each 'Media' Attribute in the SDP (each sub-stream)                  // If the attribute is for Video' then carry out a SETUP and a PLAY                  // Only do this for the first Video attribute in case there is more than one in the SDP                    for (int x = 0; x < sdp_data.Medias.Count; x++)                  {                      if (sdp_data.Medias[x].MediaType == Rtsp.Sdp.Media.MediaTypes.video)                      {                            // We only want the first video sub-stream                          if (video_payload == -1)                          {                              video_payload = sdp_data.Medias[x].PayloadType;                                // search the attributes for control' fmtp and rtpmap                              String control = "";  // the "track" or "stream id"                              Rtsp.Sdp.AttributFmtp fmtp = null; // holds SPS and PPS in base64 (h264)                              Rtsp.Sdp.AttributRtpMap rtpmap = null; // custom payload (>=96) details                              foreach (Rtsp.Sdp.Attribut attrib in sdp_data.Medias[x].Attributs)                              {                                  if (attrib.Key.Equals("control")) {                                      String sdp_control = attrib.Value;                                      if (sdp_control.ToLower().StartsWith("rtsp://")) {                                          control = sdp_control; //absolute path                                      } else {                                          control = url + "/" + sdp_control; // relative path                                      }                                  }                                  if (attrib.Key.Equals("fmtp")) fmtp = attrib as Rtsp.Sdp.AttributFmtp;                                  if (attrib.Key.Equals("rtpmap")) rtpmap = attrib as Rtsp.Sdp.AttributRtpMap;                              }                                // If the rtpmap contains H264 then split the fmtp to get the sprop-parameter-sets which hold the SPS and PPS in base64                              if (rtpmap!= null && rtpmap.Value.Contains("H264") && fmtp != null)                              {                                  video_codec = "H264";                                  var param = Rtsp.Sdp.H264Parameters.Parse(fmtp.FormatParameter);                                  var sps_pps = param.SpropParameterSets;                                  if (sps_pps.Count() >= 2) {                                      byte[] sps = sps_pps[0];                                      byte[] pps = sps_pps[1];                                      Output_SPS_PPS(sps'pps); // output SPS and PPS                                  }                              }                                RtspTransport transport = null;                              if (rtp_transport == RTP_TRANSPORT.TCP)                              {                                    // Server interleaves the RTP packets over the RTSP connection                                  // Example for TCP mode (RTP over RTSP)   Transport: RTP/AVP/TCP;interleaved=0-1                                  video_data_channel = 0;  // Used in DataReceived event handler                                  video_rtcp_channel = 1;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.TCP'                                      Interleaved = new PortCouple(video_data_channel' video_rtcp_channel)' // Channel 0 for video. Channel 1 for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.UDP)                              {                                  // Server sends the RTP packets to a Pair of UDP Ports (one for data' one for rtcp control messages)                                  // Example for UDP mode                   Transport: RTP/AVP;unicast;client_port=8000-8001                                  video_data_channel = udp_pair.data_port;     // Used in DataReceived event handler                                  video_rtcp_channel = udp_pair.control_port;  // Used in DataReceived event handler                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = false'                                      ClientPort = new PortCouple(video_data_channel' video_rtcp_channel)' // a Channel for video. a Channel for RTCP status reports                                  };                              }                              if (rtp_transport == RTP_TRANSPORT.MULTICAST)                              {                                  // Server sends the RTP packets to a Pair of UDP ports (one for data' one for rtcp control messages)                                  // using Multicast Address and Ports that are in the reply to the SETUP message                                  // Example for MULTICAST mode     Transport: RTP/AVP;multicast                                  video_data_channel = 0; // we get this information in the SETUP message reply                                  video_rtcp_channel = 0; // we get this information in the SETUP message reply                                  transport = new RtspTransport()                                  {                                      LowerTransport = RtspTransport.LowerTransportType.UDP'                                      IsMulticast = true                                  };                              }                                // Add authorization (if there is a username and password)                              String digest_authorization = GenerateDigestAuthorization(username'password'                                                                                    realm'nonce'url'"SETUP");                                // Send SETUP                              Rtsp.Messages.RtspRequestSetup setup_message = new Rtsp.Messages.RtspRequestSetup();                              setup_message.RtspUri = new Uri(control);                              setup_message.AddTransport(transport);                              if (digest_authorization!=null) setup_message.Headers.Add("Authorization"'digest_authorization);                              rtsp_client.SendMessage(setup_message);                          }                      }                  }              }
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Output_SPS_PPS,The following statement contains a magic number: fs.Write(new byte[] { 0x00' 0x00' 0x00' 0x01 }' 0' 4);
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Output_SPS_PPS,The following statement contains a magic number: fs.Write(new byte[] { 0x00' 0x00' 0x00' 0x01 }' 0' 4);
Magic Number,RtspClientExample,RTSPClient,C:\repos\ngraziano_SharpRTSP\RtspClientExample\Program.cs,Output_NAL,The following statement contains a magic number: foreach (byte[] nal_unit in nal_units)              {                  fs.Write(new byte[] { 0x00' 0x00' 0x00' 0x01 }' 0' 4);  // Write Start Code                  fs.Write(nal_unit' 0' nal_unit.Length);           // Write NAL              }
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: while (ok == false && (control_port < end_port))              {                  // Video/Audio port must be odd and command even (next one)                  try                  {                      data_socket = new UdpClient(data_port);                      control_socket = new UdpClient(control_port);                      ok = true;                  }                  catch (SocketException)                  {                      // Fail to allocate port' try again                      if (data_socket != null)                          data_socket.Close();                      if (control_socket != null)                          control_socket.Close();                        // try next data or control port                      data_port += 2;                      control_port += 2;                  }              }
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: while (ok == false && (control_port < end_port))              {                  // Video/Audio port must be odd and command even (next one)                  try                  {                      data_socket = new UdpClient(data_port);                      control_socket = new UdpClient(control_port);                      ok = true;                  }                  catch (SocketException)                  {                      // Fail to allocate port' try again                      if (data_socket != null)                          data_socket.Close();                      if (control_socket != null)                          control_socket.Close();                        // try next data or control port                      data_port += 2;                      control_port += 2;                  }              }
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: data_socket.Client.ReceiveBufferSize = 100 * 1024;
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: data_socket.Client.ReceiveBufferSize = 100 * 1024;
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: try              {                  IPEndPoint data_ep = new IPEndPoint(IPAddress.Any' data_port);                  IPEndPoint control_ep = new IPEndPoint(IPAddress.Any' control_port);                    data_mcast_addr = IPAddress.Parse(data_multicast_address);                  control_mcast_addr = IPAddress.Parse(control_multicast_address);                    data_socket = new UdpClient();                  data_socket.Client.Bind(data_ep);                  data_socket.JoinMulticastGroup(data_mcast_addr);                    control_socket = new UdpClient();                  control_socket.Client.Bind(control_ep);                  control_socket.JoinMulticastGroup(control_mcast_addr);                      data_socket.Client.ReceiveBufferSize = 100 * 1024;                    control_socket.Client.DontFragment = false;                }              catch (SocketException)              {                  // Fail to allocate port' try again                  if (data_socket != null)                      data_socket.Close();                  if (control_socket != null)                      control_socket.Close();                    return;              }
Magic Number,RtspClientExample,UDPSocket,C:\repos\ngraziano_SharpRTSP\RtspClientExample\UdpSocket.cs,UDPSocket,The following statement contains a magic number: try              {                  IPEndPoint data_ep = new IPEndPoint(IPAddress.Any' data_port);                  IPEndPoint control_ep = new IPEndPoint(IPAddress.Any' control_port);                    data_mcast_addr = IPAddress.Parse(data_multicast_address);                  control_mcast_addr = IPAddress.Parse(control_multicast_address);                    data_socket = new UdpClient();                  data_socket.Client.Bind(data_ep);                  data_socket.JoinMulticastGroup(data_mcast_addr);                    control_socket = new UdpClient();                  control_socket.Client.Bind(control_ep);                  control_socket.JoinMulticastGroup(control_mcast_addr);                      data_socket.Client.ReceiveBufferSize = 100 * 1024;                    control_socket.Client.DontFragment = false;                }              catch (SocketException)              {                  // Fail to allocate port' try again                  if (data_socket != null)                      data_socket.Close();                  if (control_socket != null)                      control_socket.Close();                    return;              }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
Magic Number,RtspClientExample,H264Payload,C:\repos\ngraziano_SharpRTSP\RtspClientExample\H264Payload.cs,Process_H264_RTP_Frame,The following statement contains a magic number: for (int payload_index = 0; payload_index < rtp_payloads.Count; payload_index++)              {                  // Examine the first rtp_payload and the first byte (the NAL header)                  int nal_header_f_bit = (rtp_payloads[payload_index][0] >> 7) & 0x01;                  int nal_header_nri = (rtp_payloads[payload_index][0] >> 5) & 0x03;                  int nal_header_type = (rtp_payloads[payload_index][0] >> 0) & 0x1F;                    // If the Nal Header Type is in the range 1..23 this is a normal NAL (not fragmented)                  // So write the NAL to the file                  if (nal_header_type >= 1 && nal_header_type <= 23)                  {                      Console.WriteLine("Normal NAL");                      norm++;                      nal_units.Add(rtp_payloads[payload_index]);                  }                  // There are 4 types of Aggregation Packet (split over RTP payloads)                  else if (nal_header_type == 24)                  {                      Console.WriteLine("Agg STAP-A");                      stap_a++;                        // RTP packet contains multiple NALs' each with a 16 bit header                      //   Read 16 byte size                      //   Read NAL                      try                      {                          int ptr = 1; // start after the nal_header_type which was '24'                          // if we have at least 2 more bytes (the 16 bit size) then consume more data                          while (ptr + 2 < (rtp_payloads[payload_index].Length - 1))                          {                              int size = (rtp_payloads[payload_index][ptr] << 8) + (rtp_payloads[payload_index][ptr + 1] << 0);                              ptr = ptr + 2;                              byte[] nal = new byte[size];                              System.Array.Copy(rtp_payloads[payload_index]' ptr' nal' 0' size); // copy the NAL                              nal_units.Add(nal); // Add to list of NALs for this RTP frame. Start Codes like 00 00 00 01 get added later                              ptr = ptr + size;                          }                      }                      catch                      {                          // do nothing                      }                  }                  else if (nal_header_type == 25)                  {                      Console.WriteLine("Agg STAP-B not supported");                      stap_b++;                  }                  else if (nal_header_type == 26)                  {                      Console.WriteLine("Agg MTAP16 not supported");                      mtap16++;                  }                  else if (nal_header_type == 27)                  {                      Console.WriteLine("Agg MTAP24 not supported");                      mtap24++;                  }                  else if (nal_header_type == 28)                  {                      Console.WriteLine("Frag FU-A");                      fu_a++;                        // Parse Fragmentation Unit Header                      int fu_header_s = (rtp_payloads[payload_index][1] >> 7) & 0x01;  // start marker                      int fu_header_e = (rtp_payloads[payload_index][1] >> 6) & 0x01;  // end marker                      int fu_header_r = (rtp_payloads[payload_index][1] >> 5) & 0x01;  // reserved. should be 0                      int fu_header_type = (rtp_payloads[payload_index][1] >> 0) & 0x1F; // Original NAL unit header                        Console.WriteLine("Frag FU-A s=" + fu_header_s + "e=" + fu_header_e);                        // Check Start and End flags                      if (fu_header_s == 1 && fu_header_e == 0)                      {                          // Start of Fragment.                          // Initiise the fragmented_nal byte array                          // Build the NAL header with the original F and NRI flags but use the the Type field from the fu_header_type                          byte reconstructed_nal_type = (byte)((nal_header_f_bit << 7) + (nal_header_nri << 5) + fu_header_type);                            // Empty the stream                          fragmented_nal.SetLength(0);                            // Add reconstructed_nal_type byte to the memory stream                          fragmented_nal.WriteByte(reconstructed_nal_type);                            // copy the rest of the RTP payload to the memory stream                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 0)                      {                          // Middle part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                      }                        if (fu_header_s == 0 && fu_header_e == 1)                      {                          // End part of Fragment                          // Append this payload to the fragmented_nal                          // Data starts after the NAL Unit Type byte and the FU Header byte                          fragmented_nal.Write(rtp_payloads[payload_index]' 2' rtp_payloads[payload_index].Length - 2);                            // Add the NAL to the array of NAL units                          nal_units.Add(fragmented_nal.ToArray());                      }                  }                    else if (nal_header_type == 29)                  {                      Console.WriteLine("Frag FU-B not supported");                      fu_b++;                  }                  else                  {                      Console.WriteLine("Unknown NAL header " + nal_header_type + " not supported");                  }                }
