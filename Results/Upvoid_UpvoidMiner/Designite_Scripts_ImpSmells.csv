Implementation smell,Namespace,Class,File,Method,Description
Long Method,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The method has 105 lines of code.
Long Method,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The method has 168 lines of code.
Long Method,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,HandleInput,The method has 111 lines of code.
Long Method,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The method has 113 lines of code.
Long Method,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,Update,The method has 115 lines of code.
Long Method,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The method has 131 lines of code.
Long Method,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The method has 106 lines of code.
Long Method,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The method has 102 lines of code.
Complex Method,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,HandleInput,Cyclomatic complexity of the method is 12
Complex Method,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCraft,Cyclomatic complexity of the method is 9
Complex Method,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,Cyclomatic complexity of the method is 17
Complex Method,UpvoidMiner,RecipeUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\RecipeUI.cs,BtnCraft,Cyclomatic complexity of the method is 10
Complex Method,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,Cyclomatic complexity of the method is 9
Complex Method,UpvoidMiner,ItemSave,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,DeserializeItem,Cyclomatic complexity of the method is 8
Complex Method,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,Cyclomatic complexity of the method is 10
Complex Method,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,Cyclomatic complexity of the method is 11
Complex Method,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,Cyclomatic complexity of the method is 9
Complex Method,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,Init,Cyclomatic complexity of the method is 9
Long Parameter List,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,VolumeCallback,The method has 5 parameters. Parameters: x' y' z' lod' size
Long Parameter List,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,CharacterController,The method has 6 parameters. Parameters: _camera' _containingWorld' _godMode' _characterHeight' _bodyDiameter' _bodyMass
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The method has 5 parameters. Parameters: shape' shapeBoundary' digMode' materialFilter' allowAirChange
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DigSphere,The method has 7 parameters. Parameters: worldNormal' position' radius' filterMaterials' terrainMaterialId' digMode' allowAirChange
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DigBox,The method has 7 parameters. Parameters: worldNormal' position' radius' filterMaterials' terrainMaterialId' digMode' allowAirChange
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DigCylinder,The method has 7 parameters. Parameters: worldNormal' position' radius' filterMaterials' terrainMaterialId' digMode' allowAirChange
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DigCone,The method has 7 parameters. Parameters: worldNormal' position' radius' filterMaterials' terrainMaterialId' digMode' allowAirChange
Long Parameter List,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,PointCallback,The method has 6 parameters. Parameters: x' y' z' matPrev' matNow' lod
Long Parameter List,UpvoidMiner,DiscreteItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\DiscreteItem.cs,DiscreteItem,The method has 5 parameters. Parameters: name' description' weight' category' stackSize
Long Parameter List,UpvoidMiner,VolumeItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\VolumeItem.cs,VolumeItem,The method has 5 parameters. Parameters: name' description' weight' category' volume
Long Parameter List,UpvoidMiner,SolidTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\SolidTerrainResource.cs,SolidTerrainResource,The method has 5 parameters. Parameters: substance' renderMaterial' particleMaterial' massDensity' defaultPipeline
Long Parameter List,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,CreateLog,The method has 8 parameters. Parameters: t' start' dir' front' height' radius' material' meshName
Long Identifier,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,,The length of the parameter resourceDownloadProgressSocket is 30.
Long Identifier,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,,The length of the parameter previewShapeIndicatorRenderComp is 31.
Long Identifier,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,,The length of the parameter materialAlignmentGridRenderComp is 31.
Long Identifier,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,,The length of the parameter previewMaterialPlacedIndicator is 30.
Long Identifier,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,,The length of the parameter materialAlignmentGridRenderComp is 31.
Long Identifier,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,,The length of the parameter previewShapeIndicatorRenderComp is 31.
Long Identifier,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,,The length of the parameter materialAlignmentGridRenderComp is 31.
Long Identifier,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,,The length of the parameter settingInternalResolutionWidth is 30.
Long Identifier,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,,The length of the parameter settingInternalResolutionHeight is 31.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgBasicRecipeCraftingWoodCylinder is 34.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedBuildingTerrainAligned is 33.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedBuildingReplaceMaterial is 34.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedBuildingPlaceConstrained is 35.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedBuildingCollectDrone is 31.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedCraftingCollectAllDynamic is 36.
Long Identifier,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,,The length of the parameter MsgAdvancedCraftingCollectAllStatic is 35.
Long Statement,UpvoidMiner,PipetteItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\PipetteItem.cs,OnUse,The length of the statement  "                TerrainMaterial mat = player.ContainingWorld.Terrain.QueryMaterialAtPosition(_worldPos - _worldNormal.Normalized * .05f' true); " is 127.
Long Statement,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,UpdateTorchSound,The length of the statement  "                throw new InvalidOperationException("Too many torch positions (" + positions.Count + " total' but only 3 are allowed!). This must not happen."); " is 144.
Long Statement,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,OnRayPreview,The length of the statement  "            var _worldPos = rayHit == null ? vec3.Zero : rayHit.Position + rayHit.Normal.Normalized * (0.01f / 7f) /* small security offset */; " is 131.
Long Statement,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,SetupItemEntity,The length of the statement  "                    mat4.Identity)' mat4.Translate(-0.25f * new vec3(entity.Transform.col2).Normalized) * mountTrans * mat4.Scale(new vec3(.05f' .2f' .05f)))); " is 139.
Long Statement,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,SetupItemEntity,The length of the statement  "            itemEntity.RegisterLightRenderComponent(rcTorchLight' 6.0f + 1.0f * randomValue' 0.3f + 0.1f * randomValue' 5.5f + randomValue * 5.0f); " is 135.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Webserver.DefaultWebserver.RegisterWebSocketHandler(UpvoidMiner.ModDomain' "GenerationProgressSocket"' generationProgressSocket); " is 129.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "ActivatePlayer"' (request' response) => ActivatePlayer(request.GetQuery("GodMode") == "true")); " is 169.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "IsPlayerActivated"' (request' response) => response.AppendBody((player != null).ToString())); " is 167.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "GenerationProgressQuery"' webGenerationProgress); " is 123.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "OpenSiteInBrowser"' (request' response) => Scripting.OpenUrlExternal(request.GetQuery("url"))); " is 169.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "            Webserver.DefaultWebserver.RegisterWebSocketHandler(UpvoidMiner.ModDomain' "ResourceDownloadProgress"' resourceDownloadProgressSocket); " is 135.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Resources.UseSound("Mods/Upvoid/Resources.Music/1.0.0::Miscellaneous/_ghost_-_Reverie_(small_theme)"' UpvoidMiner.ModDomain)' " is 125.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Resources.UseSound("Mods/Upvoid/Resources.Music/1.0.0::Miscellaneous/AlexBeroza_-_Improvisation_On_Friday"' UpvoidMiner.ModDomain)' " is 131.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Resources.UseSound("Mods/Upvoid/Resources.Music/1.0.0::Miscellaneous/Frank_Nora_-_New_Midnight_Cassette_27_Ambient01"' UpvoidMiner.ModDomain)' " is 142.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Resources.UseSound("Mods/Upvoid/Resources.Music/1.0.0::Miscellaneous/Pitx_-_Writing_the_future"' UpvoidMiner.ModDomain)' " is 120.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The length of the statement  "                Resources.UseSound("Mods/Upvoid/Resources.Music/1.0.0::Miscellaneous/zeos_-_Photo_theme_Window_like"' UpvoidMiner.ModDomain)' " is 125.
Long Statement,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,ActivatePlayer,The length of the statement  "            world.AddEntity(player' mat4.Translate(Player.SpawnPosition)' /*Network.GCManager.CurrentUserID*/0); //TODO(MS):refactor " is 120.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                    // Use the forward and right directions of the camera. When not in god mode' remove the y component' and we have our walking direction. " is 135.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                    vec3 moveDir = camera.ForwardDirection * walkDirForward * forwardSpeed + camera.RightDirection * walkDirRight * strafeSpeed; " is 124.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                    vec3 moveDir = camera.ForwardDirection * walkDirForward * forwardSpeed + camera.RightDirection * walkDirRight * strafeSpeed; " is 124.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                // Let the character hover over the ground by applying a custom gravity. We apply the custom gravity when the body is below the desired height plus 0.1 meters. " is 159.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                // Our custom gravity pushes the body to its desired height and becomes smaller the closer it gets to prevent rubber band effects. " is 130.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                if (!GodMode && distanceToGround < HoverHeight + 0.1f && jumpCoolDown <= 0f && Body.GetVelocity().Length < WalkSpeedRunning * 1.5f) " is 131.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The length of the statement  "                    float customGravity = -2f * (distanceToHoverHeight + velocity.y * convergenceSpeed) / (convergenceSpeed * convergenceSpeed); " is 124.
Long Statement,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,HandleInput,The length of the statement  "                // Clamp the walking directions to [-1' 1]. The values could get out of bound' for example' when we receive two down events without an up event in between. " is 155.
Long Statement,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCraft,The length of the statement  "            if (TypeSelection == 2 && mat is WoodSubstance && Math.Abs(cylinderSettings.Size.x - 0.3f) < 0.05f && Math.Abs(cylinderSettings.Size.y - 0.5f) < 0.05f) " is 151.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The length of the statement  "            // When placing material' add a safety margin around the player to prevent it from physically glitching trough the terrain " is 122.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The length of the statement  "            finalNode.AddSimpleVolumeCallback("UpvoidMiner"' UpvoidMiner.ModDomain' "UpvoidMiner.DiggingController"' "StatCallback"); " is 121.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The length of the statement  "                finalNode.AddVolumeChangePointCallback("UpvoidMiner"' UpvoidMiner.ModDomain' "UpvoidMiner.DiggingController"' "PointCallback"); " is 127.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The length of the statement  "                else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs)) " is 122.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The length of the statement  "                else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs)) " is 122.
Long Statement,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The length of the statement  "                else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs)) " is 123.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,Init,The length of the statement  "            /*thisEntity.AddComponent(rcTorsoShadow = new RenderComponent(new MeshRenderJob(Renderer.Shadow.Mesh' Resources.UseMaterial("::Shadow"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/Torso"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 232.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,Update,The length of the statement  "                    RayHit hit = ContainingWorld.Physics.RayTest(camera.Position' camera.Position + camera.ForwardDirection * maxRayQueryRange' character.Body); " is 140.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,TriggerItemUse,The length of the statement  "            RayHit hit = ContainingWorld.Physics.RayTest(camera.Position' camera.Position + camera.ForwardDirection * maxRayQueryRange' Character.Body); " is 140.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,TriggerInteraction,The length of the statement  "            RayHit hit = ContainingWorld.Physics.RayTest(camera.Position' camera.Position + camera.ForwardDirection * maxRayQueryRange' Character.Body); " is 140.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,DropItem,The length of the statement  "                var entity = ItemManager.InstantiateItem(droppedItem' mat4.Translate(Position + vec3.UnitY * 1f + CameraDirection * 1f)' false); " is 128.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The length of the statement  "            var drones = Inventory.Items.Sum(i => i is ToolItem && (i as ToolItem).ToolType == ToolType.DroneChain ? (i as ToolItem).StackSize : 0); " is 136.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,PlaceMaterial,The length of the statement  "                    digging.DigSphere(worldNormal' position' radius' filterMats' material.Index' DiggingController.DigMode.Add' allowAirChange); " is 124.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,PlaceMaterial,The length of the statement  "                    digging.DigBox(worldNormal' position' radius' filterMats' material.Index' DiggingController.DigMode.Add' allowAirChange); " is 121.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,PlaceMaterial,The length of the statement  "                    digging.DigCylinder(worldNormal' position' radius' filterMats' material.Index' DiggingController.DigMode.Add' allowAirChange); " is 126.
Long Statement,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,PlaceMaterial,The length of the statement  "                    digging.DigCone(worldNormal' position' radius' filterMats' material.Index' DiggingController.DigMode.Add' allowAirChange); " is 122.
Long Statement,UpvoidMiner,ItemSave,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,DeserializeItem,The length of the statement  "                    return new ToolItem(ToolItem.Type' Substance.Deserialize(ToolItem.Substance)' ToolItem.StackSize) { Durability = ToolItem.Durability }; " is 135.
Long Statement,UpvoidMiner,ItemSave,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,DeserializeItem,The length of the statement  "                    return new MaterialItem(Substance.Deserialize(MaterialItem.Substance)' MaterialItem.Shape' new vec3(MaterialItem.SizeX' MaterialItem.SizeY' MaterialItem.SizeZ)' MaterialItem.StackSize); " is 185.
Long Statement,UpvoidMiner,ItemSave,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,DeserializeItem,The length of the statement  "                    return new RecipeItem(RecipeItem.ResultSave.DeserializeItem()' RecipeItem.IngredientItemSaves.Select(ingredient => ingredient.DeserializeItem()).ToList()); " is 155.
Long Statement,UpvoidMiner,ItemEntity,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemEntity.cs,RegisterLightRenderComponent,The length of the statement  "                throw new InvalidOperationException("You need to add the RenderComponent to the list of RenderComponents first! Call AddRenderComponent before calling RegisterLightRenderComponent!"); " is 183.
Long Statement,UpvoidMiner,ItemEntity,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemEntity.cs,RegisterLightRenderComponent,The length of the statement  "            lightConfigurations.Add(new LightConfiguration { lightRenderComp = lightRenderComp' initalLightRadius = initalLightRadius' lightRadiusDeviation = lightRadiusDeviation' flickerSpeed = flickerSpeed }); " is 199.
Long Statement,UpvoidMiner,ItemEntity,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemEntity.cs,Update,The length of the statement  "                    lightConf.lightRenderComp.Transform = mat4.Translate(new vec3(lightConf.lightRenderComp.Transform.col3)) * mat4.Scale(lightConf.initalLightRadius + 0.5f * (float)Math.Sin(lightConf.flickerSpeed * accumulatedTime) * lightConf.lightRadiusDeviation); " is 247.
Long Statement,UpvoidMiner,PlayerGui,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\PlayerGui.cs,webSelectQuickAccessSlot,The length of the statement  "            // The GUI client calls this when a quick access slot is selected. Get the selected index and pass it to the player inventory. " is 126.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Update,The length of the statement  "            renderComponentWing1Opaque.Transform = renderComponentWing1Shadow.Transform = mat4.Scale(DroneScale) * mat4.RotateY(-360 * RotationSpeed * lifetime); " is 149.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Update,The length of the statement  "            renderComponentWing2Opaque.Transform = renderComponentWing2Shadow.Transform = mat4.Scale(DroneScale) * mat4.RotateY(360 * RotationSpeed * lifetime); " is 148.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Opaque.Mesh' Resources.UseMaterial("Miner/Torso"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneBody"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 177.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Shadow.Mesh' Resources.UseMaterial("::Shadow"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneBody"' UpvoidMiner.ModDomain)' mat4.Identity)'                                                         " is 174.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Opaque.Mesh' Resources.UseMaterial("Miner/Torso"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneWing1"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 178.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Shadow.Mesh' Resources.UseMaterial("::Shadow"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneWing1"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 175.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Opaque.Mesh' Resources.UseMaterial("Miner/Torso"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneWing2"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 178.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Shadow.Mesh' Resources.UseMaterial("::Shadow"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneWing2"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 175.
Long Statement,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The length of the statement  "                new MeshRenderJob(Renderer.Transparent.Mesh' Resources.UseMaterial("Miner/DroneIndicator"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneIndicator"' UpvoidMiner.ModDomain)' mat4.Identity)' " is 196.
Long Statement,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,configureVerticalConstraint,The length of the statement  "            job1.ModelMatrix = job2.ModelMatrix = mat4.Translate(startPos) * transform * mat4.Scale(.5f) * mat4.Translate(new vec3(1' 0' 0)); " is 129.
Long Statement,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,Update,The length of the statement  "                                // Vertical drones cause a constraint by the intersection of the planes (i.e. the plane between two drones and the two shadow-planes). " is 134.
Long Statement,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,Update,The length of the statement  "                                constraintExpression.Add(new CsgExpression(1' "max((dot(plane1Normal' vec3(x' y' z)) - plane1Dis)' max( (dot(plane2Normal' vec3(x' y' z)) - plane2Dis)' (dot(plane3Normal' vec3(x' y' z)) - plane3Dis)) )"'  " is 203.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnSelect,The length of the statement  "            previewShapeIndicator = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/ResourcePreviewIndicator"' UpvoidMiner.ModDomain)' shapeMesh' mat4.Scale(0f)); " is 172.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnSelect,The length of the statement  "            materialAlignmentGrid = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/GridAlignment"' UpvoidMiner.ModDomain)' Resources.UseMesh("Triplequad"' UpvoidMiner.ModDomain)' mat4.Scale(0f)); " is 206.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The length of the statement  "            var _worldPos = rayHit == null ? vec3.Zero : rayHit.Position + rayHit.Normal.Normalized * (0.01f / 7f) /* small security offset */; " is 131.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The length of the statement  "            previewShapeRenderComp.Transform = _visible ? mat4.Translate(_worldPos) * mat4.Scale(useRadius) * rotMat : mat4.Scale(0f); " is 122.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The length of the statement  "            materialAlignmentGridRenderComp.Transform = gridAlignmentVisible ? mat4.Translate(_worldPos) * mat4.Scale(2f * _player.DiggingGridSize) * rotMat : mat4.Scale(0f); " is 162.
Long Statement,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The length of the statement  "            previewShapeIndicatorRenderComp.Transform = _visible ? mat4.Translate(indPos) * mat4.Scale(.1f) * rotMat : mat4.Scale(0f); " is 122.
Long Statement,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnSelect,The length of the statement  "            previewMaterialPlaced = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/ResourcePreview"' UpvoidMiner.ModDomain)' mesh' mat4.Scale(0f)); " is 158.
Long Statement,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnSelect,The length of the statement  "            previewMaterialPlacedIndicator = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/ResourcePreviewIndicator"' UpvoidMiner.ModDomain)' Resources.UseMesh("::Debug/Sphere"' null)' mat4.Scale(0f)); " is 213.
Long Statement,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnSelect,The length of the statement  "            materialAlignmentGrid = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/GridAlignment"' UpvoidMiner.ModDomain)' Resources.UseMesh("Triplequad"' UpvoidMiner.ModDomain)' mat4.Scale(0f)); " is 206.
Long Statement,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnRayPreview,The length of the statement  "            var _worldPos = rayHit == null ? vec3.Zero : rayHit.Position + rayHit.Normal.Normalized * (0.01f / 7f) /* small security offset */; " is 131.
Long Statement,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnRayPreview,The length of the statement  "            materialAlignmentGridRenderComp.Transform = gridAlignmentVisible ? mat4.Translate(_worldPos) * mat4.Scale(2f * _player.DiggingGridSize) * rotMat : mat4.Scale(0f); " is 162.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnSelect,The length of the statement  "            previewShapeIndicator = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/ResourcePreviewIndicator"' UpvoidMiner.ModDomain)' shapeMesh' mat4.Scale(0f)); " is 172.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnSelect,The length of the statement  "            materialAlignmentGrid = new MeshRenderJob(Renderer.Overlay.Mesh' Resources.UseMaterial("Items/GridAlignment"' UpvoidMiner.ModDomain)' Resources.UseMesh("Triplequad"' UpvoidMiner.ModDomain)' mat4.Scale(0f)); " is 206.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "            var _worldPos = rayHit == null ? vec3.Zero : rayHit.Position + rayHit.Normal.Normalized * (0.01f / 7f) /* small security offset */; " is 131.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "                if (digRadiusShovel > digRadiusShovelInitial * digRadiusMaxFactor) digRadiusShovel = digRadiusShovelInitial * digRadiusMaxFactor; " is 129.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "                if (digRadiusShovel < digRadiusShovelInitial * digRadiusMinFactor) digRadiusShovel = digRadiusShovelInitial * digRadiusMinFactor; " is 129.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "                if (digRadiusPickaxe > digRadiusPickaxeInitial * digRadiusMaxFactor) digRadiusPickaxe = digRadiusPickaxeInitial * digRadiusMaxFactor; " is 133.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "                if (digRadiusPickaxe < digRadiusPickaxeInitial * digRadiusMinFactor) digRadiusPickaxe = digRadiusPickaxeInitial * digRadiusMinFactor; " is 133.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "            previewShapeRenderComp.Transform = _visible ? mat4.Translate(_worldPos) * mat4.Scale(useRadius) * rotMat : mat4.Scale(0f); " is 122.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "            materialAlignmentGridRenderComp.Transform = gridAlignmentVisible ? mat4.Translate(_worldPos) * mat4.Scale(2f * _player.DiggingGridSize) * rotMat : mat4.Scale(0f); " is 162.
Long Statement,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The length of the statement  "            previewShapeIndicatorRenderComp.Transform = _visible ? mat4.Translate(_worldPos) * mat4.Scale(.1f) * rotMat : mat4.Scale(0f); " is 125.
Long Statement,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The length of the statement  "                            player.CurrentDiggingAlignment = (DiggingController.DigAlignment)(((uint)player.CurrentDiggingAlignment - 1 + offset) % vals + 1); " is 130.
Long Statement,UpvoidMiner,Substance,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\Substance.cs,QueryResource,The length of the statement  "            if (!GetType().IsSealed) throw new InvalidOperationException("Non-Leaf Substances do not have any terrain resources assigned to them!"); " is 136.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            SolidTerrainResource desertResource = new SolidTerrainResource(new SandSubstance()' "Terrain/Desert"' "Particles/Terrain/Desert"' 1320f); " is 137.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "                int pipeline = desertResource.Material.AddPipeline(Resources.UseGeometryPipeline("ParvifloraField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4); " is 143.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "                desertResource.Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Parviflora"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh); " is 149.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "                desertResource.Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Parviflora.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh); " is 166.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new BirchWoodSubstance()' "Terrain/BirchWood"' "Particles/Terrain/BirchWood"' 650f)); " is 122.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new CharcoalSubstance()' "Terrain/Charcoal"' "Particles/Terrain/Charcoal"' 1300f)); " is 120.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new BlackCoalSubstance()' "Terrain/BlackCoal"' "Particles/Terrain/BlackCoal"' 1300f)); " is 123.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new BronzeSubstance()' "Terrain/Placeholder"' "Particles/Terrain/Placeholder"' -1f)); " is 122.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new SteelSubstance()' "Terrain/Placeholder"' "Particles/Terrain/Placeholder"' -1f)); " is 121.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new CopperOreSubstance()' "Terrain/CopperOre"' "Particles/Terrain/CopperOre"' 4900f)); " is 123.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new TinOreSubstance()' "Terrain/Placeholder"' "Particles/Terrain/Placeholder"' -1f)); " is 122.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new IronOreSubstance()' "Terrain/Placeholder"' "Particles/Terrain/Placeholder"' -1f)); " is 123.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new VerdaniumOreSubstance()' "Terrain/VerdaniumOre"' "Particles/Terrain/VerdaniumOre"' 2900f)); " is 132.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new AegiriumSubstance()' "Terrain/BlueCrystal"' "Particles/Terrain/BlueCrystal"' 3500f)); " is 126.
Long Statement,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The length of the statement  "            addResource(new SolidTerrainResource(new FireRockSubstance()' "Terrain/FireRock"' "Particles/Terrain/FireRock"' 2900f)); " is 120.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                //hillsDefines.Append("Hills = perlins(x / 300' 0.00001 * y' z / 300) + perlins(x / 100' 0.00001 * y' z / 100) * .5 + perlins(x / 30' 0.00001 * y' z / 30) * .25 + perlins(x / 10' 0.00001 * y' z / 10) * .05;"); " is 209.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                var dirtNodeNetwork = NodeNetworkHelper.CreateExprWithTextureSampling(hillsDef + heightmapDirt + "y + Heightmap + Hills"' UpvoidMiner.ModDomain' "texture"' texture); " is 165.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                var rockNodeNetwork = NodeNetworkHelper.CreateExprWithTextureSampling(hillsDef + heightmapRocks + "y + Heightmap + 4 + Hills*0.2"' UpvoidMiner.ModDomain' "texture"' texture); " is 174.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                //var goldNodeNetwork = NodeNetworkHelper.CreateExprWithTextureSampling(hillsDef + oreDef + "Ore + clamp(y+20' -10' 0)*0.1"' UpvoidMiner.ModDomain' "texture"' texture); " is 168.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                //union.AddNode(new CsgExpression(terrainRock.Index' hillsDef + "y + Hills + (5 + perlins(x / 5' z / 6' y / 7) * 3 + perlins(z / 45' y / 46' x / 47) * 13)"' UpvoidMiner.ModDomain)); " is 181.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                coalDefines.Append("Density = worley(x/bXZ'y/bY'z/bXZ)-bC+(worley(2*x/bXZ'2*y/bY'2*z/bXZ)-bC)*0.5+(worley(4*x/bXZ'4*y/bY'4*z/bXZ)-bC)*0.25+perlin(x/40'y/40'z/40)*bC;"); " is 168.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                copperDefines.Append("fY = y/20; pX = perlins(fY*1.23+x/20'fY'fY*0.5439+z/20)*20+x;pZ = perlins(fY*2.143+x/20'fY'-fY*0.239+z/20)*20+z;"); " is 137.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The length of the statement  "                //hillsDefines.Append("Hills = perlins(x / 300' 0.00001 * y' z / 300) + perlins(x / 100' 0.00001 * y' z / 100) * .5 + perlins(x / 30' 0.00001 * y' z / 30) * .25 + perlins(x / 10' 0.00001 * y' z / 10) * .05;"); " is 209.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,AddTree,The length of the statement  "            vec3 randXZ = ((float)random.NextDouble() * 2.0f - 1.0f) * vec3.UnitX + ((float)random.NextDouble() * 2.0f - 1.0f) * vec3.UnitZ; " is 128.
Long Statement,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,AddTree,The length of the statement  "            //world.AddEntity(TreeGenerator.Birch(8 + (float)random.NextDouble() * 10f' .3f + (float)random.NextDouble() * .1f' random)' transform); " is 136.
Long Statement,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Init,The length of the statement  "                    chopSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Chopping/Wood/Wood" + i.ToString("00")' UpvoidMiner.ModDomain); " is 143.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The length of the statement  "            vec4 colorModulation = new vec4(0.7f + (float)random.NextDouble() * 0.6f' 0.9f + (float)random.NextDouble() * 0.2f' 1' 1); " is 122.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The length of the statement  "            vec4 colorModulation = new vec4(0.7f + (float)random.NextDouble() * 0.5f' 0.7f + (float)random.NextDouble() * 0.5f' 1' 1); " is 122.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,CreateLog,The length of the statement  "            log.RenderComps.Add(new RenderComponent( new MeshRenderJob(Renderer.Opaque.Mesh' material' mesh' mat4.Identity)' transform)); " is 125.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,CreateLog,The length of the statement  "            log.RenderComps.Add(new RenderComponent( new MeshRenderJob(Renderer.Shadow.Mesh' Resources.UseMaterial("::Shadow"' null)' mesh' mat4.Identity)' transform)); " is 156.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,CreateLog,The length of the statement  "            log.RenderComps.Add(new RenderComponent( new MeshRenderJob(Renderer.zPre.Mesh' Resources.UseMaterial("::ZPre"' null)' mesh' mat4.Identity)' transform)); " is 152.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The length of the statement  "                    vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f)); " is 149.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The length of the statement  "                    vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f)); " is 220.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The length of the statement  "                vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized; " is 144.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The length of the statement  "                    vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f)); " is 149.
Long Statement,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The length of the statement  "                    vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f)); " is 220.
Long Statement,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The length of the statement  "            Audio.SetVolumeForSpecificAudioType(settingMuteMusic.value ? 0.0f : (float)settingMusicVolume.value / 100f' (int)AudioType.Music); " is 130.
Long Statement,UpvoidMiner.UI,Tutorials,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,ShowNextNonClearedOnDemand,The length of the statement  "            var msg = AllMessages.Values.FirstOrDefault(m => !m.Visible && !m.Cleared && (m.Mode == Modes.Both || (m.Mode == Modes.God) == godMode)); " is 137.
Complex Conditional,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The conditional expression  "TouchesGround && Body.GetVelocity().LengthSqr > 0.1f && !GodMode && !LocalScript.NoclipEnabled"  is complex.
Complex Conditional,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The conditional expression  "!GodMode && distanceToGround < HoverHeight + 0.1f && jumpCoolDown <= 0f && Body.GetVelocity().Length < WalkSpeedRunning * 1.5f"  is complex.
Complex Conditional,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,HandleInput,The conditional expression  "walkDirRight == 0 && walkDirForward == 0 && TouchesGround && e.PressType == InputPressArgs.KeyPressType.Up"  is complex.
Complex Conditional,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCraft,The conditional expression  "TypeSelection == 2 && mat is WoodSubstance && Math.Abs(cylinderSettings.Size.x - 0.3f) < 0.05f && Math.Abs(cylinderSettings.Size.y - 0.5f) < 0.05f"  is complex.
Complex Conditional,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The conditional expression  "instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center"  is complex.
Complex Conditional,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The conditional expression  "instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5"  is complex.
Complex Conditional,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The conditional expression  "instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2"  is complex.
Complex Conditional,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,Settings,The conditional expression  "mode.Width > 0 && mode.Height > 0 &&                      (mode.Width < 1100 || mode.Height < 700)"  is complex.
Complex Conditional,UpvoidMiner.UI,TutorialMessage,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,TriggerShow,The conditional expression  "(Mode == Modes.Adventure && godMode)                      || (Mode == Modes.God && !godMode)"  is complex.
Virtual Method Call from Constructor,UpvoidMiner,ItemCollection,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemCollection.cs,ItemCollection,The constructor "ItemCollection" calls a virtual method "Clone".
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,UpdateTorchSound,The following statement contains a magic number: if(positions.Count > 3)              {                  throw new InvalidOperationException("Too many torch positions (" + positions.Count + " total' but only 3 are allowed!). This must not happen.");              }
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,UpdateTorchSound,The following statement contains a magic number: for (int i = 0; i < 3; ++i)              {                  if(i >= positions.Count)                  {                      // "Invalidate" sound                      fireSound[i].Volume = 0.0f;                        // Go on with next sound                      continue;                  }                    vec4 curr = positions[i];                  float disToCam = curr.w;                    if(disToCam < 20.0f)                  {                      fireSound[i].Position = new vec3(curr);                      fireSound[i].Volume = TorchFireVolume;                  }                  else                  {                      fireSound[i].Volume = 0.0f;                  }              }
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,TorchItem,The following statement contains a magic number: if(fireSoundRes == null)              {                  fireSoundRes = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Miscellaneous/Fire"' UpvoidMiner.ModDomain);                    // 3 sounds (max.)                  fireSound = new Sound[3];                    for (int i = 0; i < 3; ++i)                  {                      // Start with zero volume' we adapt that later                      fireSound[i] = new Sound(fireSoundRes' vec3.Zero' true' 1.0f' 0.6f' (int)AudioType.SFX' true); // Pitch: 0.6                      fireSound[i].ReferenceDistance = 2.0f;                        // Play it all the time. Volume is zero if no torch exists.                      fireSound[i].Play();                  }              }
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,TorchItem,The following statement contains a magic number: if(fireSoundRes == null)              {                  fireSoundRes = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Miscellaneous/Fire"' UpvoidMiner.ModDomain);                    // 3 sounds (max.)                  fireSound = new Sound[3];                    for (int i = 0; i < 3; ++i)                  {                      // Start with zero volume' we adapt that later                      fireSound[i] = new Sound(fireSoundRes' vec3.Zero' true' 1.0f' 0.6f' (int)AudioType.SFX' true); // Pitch: 0.6                      fireSound[i].ReferenceDistance = 2.0f;                        // Play it all the time. Volume is zero if no torch exists.                      fireSound[i].Play();                  }              }
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,SetupItemEntity,The following statement contains a magic number: float fadeOutMin = 100;
Magic Number,UpvoidMiner,TorchItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\TorchItem.cs,SetupItemEntity,The following statement contains a magic number: float fadeOutMax = 105;
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: window.SetMinimumWidth(1100);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: window.SetMinimumHeight(700);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Register a callback for the terrain generation so the GUI can be notified when the world is ready.                  world.Terrain.AddVolumeUpdateCallback(VolumeCallback' false' 0' 4);                    // Show a splash screen in the GUI client.                  if (Scripting.IsDeploy)                      Gui.DefaultUI.LoadURL(UpvoidMiner.ModDomain' "SplashScreen.html");                  else                      Gui.DefaultUI.LoadURL(UpvoidMiner.ModDomain' "MainMenu.html?Debug");                    // Register a socket for sending progress updates to the loading screen                  generationProgressSocket = new WebSocketHandler();                  Webserver.DefaultWebserver.RegisterWebSocketHandler(UpvoidMiner.ModDomain' "GenerationProgressSocket"' generationProgressSocket);                    Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "ActivatePlayer"' (request' response) => ActivatePlayer(request.GetQuery("GodMode") == "true"));                  Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "IsPlayerActivated"' (request' response) => response.AppendBody((player != null).ToString()));                  Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "GenerationProgressQuery"' webGenerationProgress);                  Webserver.DefaultWebserver.RegisterDynamicContent(UpvoidMiner.ModDomain' "OpenSiteInBrowser"' (request' response) => Scripting.OpenUrlExternal(request.GetQuery("url")));              }
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: camera.Position = new vec3(150' 40' 150);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: camera.Position = new vec3(150' 40' 150);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: camera.Position = new vec3(150' 40' 150);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: camera.FarClippingPlane = 1750.0;
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: musicQueue = new MusicQueue(4' 8' true);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Startup,The following statement contains a magic number: musicQueue = new MusicQueue(4' 8' true);
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,VolumeCallback,The following statement contains a magic number: if (lod <= 4)              {                  generatedChunks++;              }
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,VolumeCallback,The following statement contains a magic number: if (generatedChunks >= 20)              {                  generationDone = true;              }
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Update,The following statement contains a magic number: using (new ProfileAction("LocalScript::Update"' UpvoidMiner.Mod))              {                  if (NoclipEnabled && cameraControl != null)                  {                      // Bezier Path                      if (PathPlaying && PathPositions.Count >= 2)                      {                          PathCurrPos += _elapsedSeconds;                          while (PathCurrPos > PathPositions.Count)                              PathCurrPos -= PathPositions.Count;                          vec3 pos = bezierOf(PathPositions' PathTmps' PathCurrPos / (float)PathPositions.Count);                          vec3 dir = bezierOf(PathDirections' PathTmps' PathCurrPos / (float)PathPositions.Count);                          camera.Position = pos;                          camera.SetTarget(pos + dir' vec3.UnitY);                      }                      cameraControl.Update(_elapsedSeconds);                  }                    if (player != null)                  {                      player.Update(_elapsedSeconds);                  }                    UpdateResourceDownloadProgress();                    if ((DateTime.Now - lastSave).TotalSeconds > 10)                  {                      lastSave = DateTime.Now;                        if (player != null)                      {                          player.Save();                          Tutorials.SaveState();                      }                      UpvoidMinerWorldGenerator.SaveEntities();                  }                    // update items                  ItemManager.Update(_elapsedSeconds);                    // Update all trees and keep position of closest tree' if any                  vec3 closestTree = UpvoidMinerWorldGenerator.UpdateTrees(camera.Position);                    // Handle bird sound volume (depending on distance to closest tree)                  if (birdSound != null)                  {                      float distToTrees = Math.Max(0.01f' vec3.distance(closestTree' camera.Position));                        if (distToTrees < 50.0f)                      {                          // Set bird sound position to position of the closest tree                          birdSound.Position = closestTree + new vec3(0' 2' 0);                            // Attenuation (by distance) will be handled by Audio-Engine automatically                          birdSound.Volume = birdVolume;                      }                      else                      {                          // No close tree / birds at all...                          birdSound.Volume = 0.0f;                      }                  }              }
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Update,The following statement contains a magic number: using (new ProfileAction("LocalScript::Update"' UpvoidMiner.Mod))              {                  if (NoclipEnabled && cameraControl != null)                  {                      // Bezier Path                      if (PathPlaying && PathPositions.Count >= 2)                      {                          PathCurrPos += _elapsedSeconds;                          while (PathCurrPos > PathPositions.Count)                              PathCurrPos -= PathPositions.Count;                          vec3 pos = bezierOf(PathPositions' PathTmps' PathCurrPos / (float)PathPositions.Count);                          vec3 dir = bezierOf(PathDirections' PathTmps' PathCurrPos / (float)PathPositions.Count);                          camera.Position = pos;                          camera.SetTarget(pos + dir' vec3.UnitY);                      }                      cameraControl.Update(_elapsedSeconds);                  }                    if (player != null)                  {                      player.Update(_elapsedSeconds);                  }                    UpdateResourceDownloadProgress();                    if ((DateTime.Now - lastSave).TotalSeconds > 10)                  {                      lastSave = DateTime.Now;                        if (player != null)                      {                          player.Save();                          Tutorials.SaveState();                      }                      UpvoidMinerWorldGenerator.SaveEntities();                  }                    // update items                  ItemManager.Update(_elapsedSeconds);                    // Update all trees and keep position of closest tree' if any                  vec3 closestTree = UpvoidMinerWorldGenerator.UpdateTrees(camera.Position);                    // Handle bird sound volume (depending on distance to closest tree)                  if (birdSound != null)                  {                      float distToTrees = Math.Max(0.01f' vec3.distance(closestTree' camera.Position));                        if (distToTrees < 50.0f)                      {                          // Set bird sound position to position of the closest tree                          birdSound.Position = closestTree + new vec3(0' 2' 0);                            // Attenuation (by distance) will be handled by Audio-Engine automatically                          birdSound.Volume = birdVolume;                      }                      else                      {                          // No close tree / birds at all...                          birdSound.Volume = 0.0f;                      }                  }              }
Magic Number,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,Update,The following statement contains a magic number: using (new ProfileAction("LocalScript::Update"' UpvoidMiner.Mod))              {                  if (NoclipEnabled && cameraControl != null)                  {                      // Bezier Path                      if (PathPlaying && PathPositions.Count >= 2)                      {                          PathCurrPos += _elapsedSeconds;                          while (PathCurrPos > PathPositions.Count)                              PathCurrPos -= PathPositions.Count;                          vec3 pos = bezierOf(PathPositions' PathTmps' PathCurrPos / (float)PathPositions.Count);                          vec3 dir = bezierOf(PathDirections' PathTmps' PathCurrPos / (float)PathPositions.Count);                          camera.Position = pos;                          camera.SetTarget(pos + dir' vec3.UnitY);                      }                      cameraControl.Update(_elapsedSeconds);                  }                    if (player != null)                  {                      player.Update(_elapsedSeconds);                  }                    UpdateResourceDownloadProgress();                    if ((DateTime.Now - lastSave).TotalSeconds > 10)                  {                      lastSave = DateTime.Now;                        if (player != null)                      {                          player.Save();                          Tutorials.SaveState();                      }                      UpvoidMinerWorldGenerator.SaveEntities();                  }                    // update items                  ItemManager.Update(_elapsedSeconds);                    // Update all trees and keep position of closest tree' if any                  vec3 closestTree = UpvoidMinerWorldGenerator.UpdateTrees(camera.Position);                    // Handle bird sound volume (depending on distance to closest tree)                  if (birdSound != null)                  {                      float distToTrees = Math.Max(0.01f' vec3.distance(closestTree' camera.Position));                        if (distToTrees < 50.0f)                      {                          // Set bird sound position to position of the closest tree                          birdSound.Position = closestTree + new vec3(0' 2' 0);                            // Attenuation (by distance) will be handled by Audio-Engine automatically                          birdSound.Volume = birdVolume;                      }                      else                      {                          // No close tree / birds at all...                          birdSound.Volume = 0.0f;                      }                  }              }
Magic Number,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,CharacterController,The following statement contains a magic number: if (GodMode)              {                  WalkSpeed *= 3;                  WalkSpeedRunning *= 3;              }              else              {                  WalkSpeed *= 1.5f;                  WalkSpeedRunning *= 1.5f;              }
Magic Number,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,CharacterController,The following statement contains a magic number: if (GodMode)              {                  WalkSpeed *= 3;                  WalkSpeedRunning *= 3;              }              else              {                  WalkSpeed *= 1.5f;                  WalkSpeedRunning *= 1.5f;              }
Magic Number,UpvoidMiner,CharacterController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CharacterController.cs,Update,The following statement contains a magic number: using (new ProfileAction("CharacterController::Update"' UpvoidMiner.Mod))              {                    // When falling' clamp maximum player speed to 55m/s (air friction)                  if (!GodMode && !TouchesGround)                  {                      const float maxSpeed = 55.0f;                      vec3 curVel = Body.GetVelocity();                      float speed = curVel.Length;                      if (speed > maxSpeed)                      {                          Body.SetVelocity(maxSpeed * curVel.Normalized);                      }                  }                    // Movement noise                  if (TouchesGround && Body.GetVelocity().LengthSqr > 0.1f && !GodMode && !LocalScript.NoclipEnabled)                  {                      // Resume movement noise (This is a no-op if sound is already playing)                      // Note that changing sound attributes is a no-op when old and new value are equal'                      // So no unnecessary openal calls will be executed                        if (IsRunning)                      {                          movementNoiseSound.Pitch = 1.5f;                      }                      else                      {                          movementNoiseSound.Pitch = 1.0f;                      }                        movementNoiseSound.Resume();                      movementNoiseSound.Position = camera.Position + new vec3(0' -2' 0);                  }                  else                  {                      // Pause movement noise                      movementNoiseSound.Pause();                  }                    // Don't do anything when noclip is enabled                  if (LocalScript.NoclipEnabled)                  {                      walkDirRight = 0;                      walkDirForward = 0;                      IsRunning = false;                      Body.SetVelocity(vec3.Zero);                      Body.SetGravity(new vec3(0' -9.807f' 0));                      return;                  }                  else if (GodMode)                  {                      Body.SetGravity(vec3.Zero);                  }                    // Security: if in non-air chunk' teleport to next all-air one                  {                      mat4 transformation = Body.GetTransformation();                      vec3 pos = new vec3(transformation.col3);                      WorldTreeNode node = ContainingWorld.QueryWorldTreeNode(pos);                      if (node != null && node.IsMinLod)                      {                          HermiteData volumeData = node.CurrentVolume;                          if (volumeData != null)                          {                              if (!volumeData.HasAir)                              {                                  // we are definitely in a non-air chunk here                                  // teleport one node size above                                  Body.SetTransformation(mat4.Translate(new vec3(0' node.Size' 0)) * Body.GetTransformation());                                                                    // Reset player velocity                                  Body.SetVelocity(vec3.Zero);                              }                              else if (!volumeData.HasAirAt(pos))                              {                                  // we are in a mixed chunk' advance pos until air                                  float offset = 0f;                                  do                                  {                                      pos.y += 0.5f;                                      offset += 0.5f;                                  } while (!volumeData.HasAirAt(pos) || !volumeData.HasAirAt(pos + new vec3(0' 1.5f' 0)));                                    // another 1.5m to ensure good ground                                  offset += 1.5f;                                    Body.SetTransformation(mat4.Translate(new vec3(0' offset' 0)) * Body.GetTransformation());                                    // Reset player velocity                                  Body.SetVelocity(vec3.Zero);                              }                          }                      }                  }                    jumpCoolDown -= _elapsedSeconds;                    // Jumping cooldown is reset instantly when moving down in any way.                  if (Body.GetVelocity().y <= 0f)                      jumpCoolDown = 0f;                    if (jumpCoolDown < 0f)                      jumpCoolDown = 0f;                    // When touching the ground' we can walk around with full control over our velocity. In Godmode' we can always 'walk'.                  if ((TouchesGround && jumpCoolDown <= 0f) || GodMode)                  {                        float forwardSpeed = IsRunning ? WalkSpeedRunning : WalkSpeed;                      float strafeSpeed = IsRunning ? StrafeSpeedRunning : StrafeSpeed;                        // Use the forward and right directions of the camera. When not in god mode' remove the y component' and we have our walking direction.                      vec3 moveDir = camera.ForwardDirection * walkDirForward * forwardSpeed + camera.RightDirection * walkDirRight * strafeSpeed;                      vec3 velocity = Body.GetVelocity();                        if (!GodMode)                      {                          moveDir.y = 0;                          velocity.y = 0;                      }                        Body.ApplyImpulse((moveDir - velocity) * CharacterMass' vec3.Zero);                        Tutorials.MsgMovementMove.Report(moveDir.Length * _elapsedSeconds);                      if (IsRunning)                          Tutorials.MsgMovementSprint.Report(moveDir.Length * _elapsedSeconds);                  }                  else // Otherwise' we can do some subtile acceleration in air                  {                      float forwardSpeed = StrafeSpeed * 0.25f;                      float strafeSpeed = StrafeSpeed * 0.25f;                        // Use the forward and right directions of the camera. Remove the y component' and we have our walking direction.                      vec3 moveDir = camera.ForwardDirection * walkDirForward * forwardSpeed + camera.RightDirection * walkDirRight * strafeSpeed;                      moveDir.y = 0;                        vec3 oldVelocity = Body.GetVelocity();                      oldVelocity.y = 0;                        float oldVelocityLength = oldVelocity.Length;                      vec3 newVelocity = oldVelocity + moveDir;                      float newVelocityLength = newVelocity.Length;                      if (oldVelocityLength > 1f && newVelocityLength > oldVelocityLength)                          newVelocity *= oldVelocityLength / newVelocityLength;                        newVelocity.y = Body.GetVelocity().y;                        Body.ApplyImpulse((newVelocity - Body.GetVelocity()) * CharacterMass' vec3.Zero);                        Tutorials.MsgMovementMove.Report(moveDir.Length * _elapsedSeconds);                      if (IsRunning)                          Tutorials.MsgMovementSprint.Report(moveDir.Length * _elapsedSeconds);                  }                    // Let the character hover over the ground by applying a custom gravity. We apply the custom gravity when the body is below the desired height plus 0.1 meters.                  // Our custom gravity pushes the body to its desired height and becomes smaller the closer it gets to prevent rubber band effects.                  // Also' only tinker with the gravcity if the player is moving relatively slow                  if (!GodMode && distanceToGround < HoverHeight + 0.1f && jumpCoolDown <= 0f && Body.GetVelocity().Length < WalkSpeedRunning * 1.5f)                  {                      vec3 velocity = Body.GetVelocity();                        // Never move down when more than 10cm below the desired height.                      if (distanceToGround < HoverHeight - 0.1f && velocity.y < 0f)                      {                          Body.ApplyImpulse(Body.Mass * new vec3(0' -velocity.y' 0)' vec3.Zero);                          velocity.y = 0f;                      }                        float convergenceSpeed = Math.Max(0.1f' _elapsedSeconds * 1.2f);                      float distanceToHoverHeight = distanceToGround - HoverHeight;                        float customGravity = -2f * (distanceToHoverHeight + velocity.y * convergenceSpeed) / (convergenceSpeed * convergenceSpeed);                        if (customGravity < -20f)                          customGravity = -20f;                      else if (customGravity > 20f)                          customGravity = 20f;                        Body.SetGravity(new vec3(0' customGravity' 0));                    }                  else if (!GodMode)                      Body.SetGravity(new vec3(0' -9.807f' 0));                    // Recalc distance to ground                  if (!GodMode)                  {                      RayHit hit = ContainingWorld.Physics.RayTest(Position' Position - new vec3(0' 50f' 0)' Body);                        if (hit != null)                      {                          distanceToGround = Position.y - BodyHeight * 0.5f - hit.Position.y;                      }                      else                          distanceToGround = 5f;                        TouchesGround = (jumpCoolDown <= 0f) && (Math.Abs(distanceToGround) < HoverHeight + 0.3f);                  }              }
Magic Number,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCylinder,The following statement contains a magic number: TypeSelection = 2;
Magic Number,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCraft,The following statement contains a magic number: switch (TypeSelection)              {                  case 0:                      item = new MaterialItem(mat' MaterialShape.Cube' boxSettings.Size);                      break;                  case 1:                      item = new MaterialItem(mat' MaterialShape.Sphere' sphereSettings.Size);                      break;                  case 2:                      item = new MaterialItem(mat' MaterialShape.Cylinder' cylinderSettings.Size);                      break;                  default:                      return;              }
Magic Number,UpvoidMiner,CraftingUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BtnCraft,The following statement contains a magic number: if (TypeSelection == 2 && mat is WoodSubstance && Math.Abs(cylinderSettings.Size.x - 0.3f) < 0.05f && Math.Abs(cylinderSettings.Size.y - 0.5f) < 0.05f)                  Tutorials.MsgBasicRecipeCraftingWoodCylinder.Report(1);
Magic Number,UpvoidMiner,BoxSettingsUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,BoxSettingsUI,The following statement contains a magic number: Width = Height = Depth = 10;
Magic Number,UpvoidMiner,SphereSettingsUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,SphereSettingsUI,The following statement contains a magic number: Radius = 10;
Magic Number,UpvoidMiner,CylinderSettingsUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\CraftingUI.cs,CylinderSettingsUI,The following statement contains a magic number: Radius = Height = 10;
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DiggingController,The following statement contains a magic number: dirtSoundResource = new SoundResource[6];
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DiggingController,The following statement contains a magic number: stoneSoundResource = new SoundResource[5];
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DiggingController,The following statement contains a magic number: for (int i = 1; i <= 6; ++i)              {                  dirtSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Digging/Dirt/Dirt" + i.ToString("00")' UpvoidMiner.ModDomain);                }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,DiggingController,The following statement contains a magic number: for (int i = 1; i <= 5; ++i)              {                  stoneSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Digging/Stone/Stone" + i.ToString("00")' UpvoidMiner.ModDomain);              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The following statement contains a magic number: CsgStatCallback finalNode = new CsgStatCallback(collapser' 4' 4);
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,Dig,The following statement contains a magic number: CsgStatCallback finalNode = new CsgStatCallback(collapser' 4' 4);
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,DiggingController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StatCallback,The following statement contains a magic number: if (mat != 0)              {                    // Resolve terrain material.                  TerrainResource material = TerrainResource.FromIndex(mat);                  Substance substance = material.Substance;                  Debug.Assert(material != null' "Invalid terrain material");                      DateTime currentTime = DateTime.Now;                  const int soundCooldownMs = 100;                    // Depending on whether we dig dirt or stone' play a random digging sound                    Sound digSound = null;                  if (substance is LooseSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Dirt material                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is RockSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is PlantSubstance && currentTime > instance.timeDirtSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Fallback' i.e. all other materials                      instance.timeDirtSound = currentTime;                      digSound = new Sound(dirtSoundResource[random.Next(0' 5)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                  else if (substance is MetalSubstance && currentTime > instance.timeStoneSound + TimeSpan.FromMilliseconds(soundCooldownMs))                  {                      // Any material beginning with "Stone"                      instance.timeStoneSound = currentTime;                      digSound = new Sound(stoneSoundResource[random.Next(0' 4)]' vec3.Zero' false' 1' 1' (int)AudioType.SFX' true);                  }                    // +/- 15% pitching                  if (digSound != null)                  {                      digSound.Pitch = 1.0f + (0.3f * (float)random.NextDouble() - 0.15f);                      digSound.Position = diggingPosition;                      digSound.Play();                  }                      // Add proper amount of material to player inventory.                  // If the material changed by a negative volume we want to collect a positive amount.                  // only do if non-god                  if (!instance.player.GodMode)                      instance.player.Inventory.AddResource(substance' -volume);                    if (instance.player.Inventory.Selection is ToolItem && volume < 0)                      (instance.player.Inventory.Selection as ToolItem).RemoveDurability(instance.player' -volume);                    // Tutorial                  if (volume < 0)                  {                      if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Shovel &&                          substance is DirtSubstance)                          Tutorials.MsgBasicDiggingDirt.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.Pickaxe &&                          substance is StoneSubstance)                          Tutorials.MsgBasicDiggingStone.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          (instance.player.Inventory.Selection as ToolItem).ToolType == ToolType.GodsShovel)                          Tutorials.MsgBasicDiggingGod.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          ((instance.player.Inventory.Selection as ToolItem).DigRadiusShovel < 0.6 ||                          (instance.player.Inventory.Selection as ToolItem).DigRadiusPickaxe < 0.6))                          Tutorials.MsgAdvancedDiggingSmall.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape != DigShape.Sphere)                          Tutorials.MsgAdvancedDiggingNonSphere.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingPivot == DigPivot.Bottom)                          Tutorials.MsgAdvancedDiggingBottom.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder &&                          instance.player.CurrentDiggingAlignment == DigAlignment.View &&                          instance.player.CurrentDiggingPivot == DigPivot.Center)                          Tutorials.MsgAdvancedDiggingView.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Box &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingAlignmentAxisRotation == 45 / 5)                          Tutorials.MsgAdvancedDiggingAngle.Report(-volume);                        if (instance.player.Inventory.Selection is ToolItem &&                          instance.player.CurrentDiggingShape == DigShape.Sphere &&                          instance.player.CurrentDiggingAlignment == DigAlignment.GridAligned &&                          instance.player.DiggingGridSize == 2 * 2)                          Tutorials.MsgAdvancedDiggingGridSize.Report(-volume);                        if (instance.player.Inventory.Selection is ResourceItem &&                          instance.player.CurrentDiggingAddMode == AddMode.NonAirOnly &&                          material.Name == "Dirt")                          Tutorials.MsgAdvancedBuildingReplaceMaterial.Report(-volume);                  }                  else if (volume > 0)                  {                      if (substance is StoneSubstance)                          Tutorials.MsgBasicBuildingStone.Report(volume);                        if (substance is DirtSubstance)                          Tutorials.MsgBasicBuildingDirt.Report(volume);                        if (instance.player.CurrentDiggingAlignment == DigAlignment.Terrain &&                          instance.player.CurrentDiggingShape == DigShape.Cylinder)                          Tutorials.MsgAdvancedBuildingTerrainAligned.Report(volume);                        if (instance.player.CurrentDiggingAddMode == AddMode.Overwrite)                          Tutorials.MsgAdvancedBuildingReplaceAll.Report(volume);                        if (substance is DirtSubstance &&                          instance.player.DroneConstraints.Any(dc => dc.Drones.Count >= 2))                          Tutorials.MsgAdvancedBuildingPlaceConstrained.Report(volume);                  }              }
Magic Number,UpvoidMiner,StoneParticles,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StoneParticles,The following statement contains a magic number: particlesStones = new CpuParticleSystem(2' 0.05);
Magic Number,UpvoidMiner,StoneParticles,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DiggingController.cs,StoneParticles,The following statement contains a magic number: particlesStones = new CpuParticleSystem(2' 0.05);
Magic Number,UpvoidMiner,RecipeUI,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\RecipeUI.cs,BtnCraft,The following statement contains a magic number: if (recipeItem.Result.Name == "Handle")                  Tutorials.MsgBasicRecipeCraftingHandle.Report(4);
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,Player,The following statement contains a magic number: DiggingGridSize = 2;
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,Update,The following statement contains a magic number: using (new ProfileAction("Player::Update"' UpvoidMiner.Mod))              {                  // Tell AudioEngine where the listener is at the moment                  Audio.SetListenerPosition(camera);                    // Use current item?                  if (isUsingItem && (DateTime.Now - lastItemUse).TotalMilliseconds > millisecondsBetweenItemUsages)                  {                      TriggerItemUse();                      lastItemUse = DateTime.Now;                  }                    // Update drones.                  foreach (var drone in Drones)                      drone.Update(elapsedSeconds);                  foreach (var dc in DroneConstraints)                      dc.Update(elapsedSeconds);                    bool menuOrInventoryOpen = Gui.IsInventoryOpen || Gui.IsMenuOpen;                    if (!LocalScript.NoclipEnabled)                  {                      // Update camera when no menu/inventory is open                      if (!menuOrInventoryOpen)                      {                          // Update direction.                          vec3 camDir = CameraDirection;                          vec3 camLeft = vec3.cross(vec3.UnitY' camDir).Normalized;                          vec3 camUp = vec3.cross(camDir' camLeft);                            float mix = (float)Math.Pow(0.01' elapsedSeconds);                          vec3 targetDir = camDir;                          vec3 dir = Direction;                          dir.x = dir.x * mix + targetDir.x * (1 - mix);                          dir.z = dir.z * mix + targetDir.z * (1 - mix);                          Direction = dir.Normalized;                            // Update player model.                          vec3 up = new vec3(0' 1' 0);                          vec3 left = vec3.cross(up' Direction);                          mat4 viewMat = new mat4(left' up' Direction' new vec3());                          /*rcTorsoShadow.Transform =                         viewMat * torsoTransform;*/                            // Update camera component.                          cameraComponent.Camera = camera;                            // Also add 10cm of forward.xz direction for a "head offset"                          vec3 forward = Direction;                          forward.y = 0;                          cameraComponent.Transform = new mat4(-camLeft' camUp' -camDir' new vec3()) * mat4.Translate(forward * .1f);                            // Re-Center mouse if UI is not open.                          Rendering.MainViewport.SetMouseVisibility(false);                          Rendering.MainViewport.SetMouseGrab(true);                      }                      else                      {                          // UI is open. Show mouse.                          Rendering.MainViewport.SetMouseVisibility(true);                          Rendering.MainViewport.SetMouseGrab(false);                      }                  }                  else                  {                      cameraComponent.Camera = null;                      Rendering.MainViewport.SetMouseVisibility(true);                      Rendering.MainViewport.SetMouseGrab(false);                  }                    /*mat4 steamTransform = thisEntity.Transform * rcTorsoShadow.Transform * torsoSteamOffset;              vec3 steamOrigin = new vec3(steamTransform * new vec4(0' 0' 0' 1));              vec3 steamVeloMin = new vec3(steamTransform * new vec4(.13f' 0.05f' 0' 0));              vec3 steamVeloMax = new vec3(steamTransform * new vec4(.16f' 0.07f' 0' 0));*/                  /*psTorsoSteam.SetSpawner2D(.03f' new BoundingSphere(steamOrigin' .01f)'                                         steamVeloMin' steamVeloMax'                                        new vec4(new vec3(.9f)' .8f)' new vec4(new vec3(.99f)' .9f)'                                        2.0f' 3.4f'                                        .1f' .2f'                                        0' 360'                                        -.2f' .2f);*/                    // Update item preview.                  if (Inventory.Selection != null && Inventory.Selection.HasRayPreview)                  {                      float maxRayQueryRange;                      if (!LocalScript.NoclipEnabled && !GodMode)                      {                          maxRayQueryRange = maxRayQueryDistancePlayer;                      }                      else                      {                          maxRayQueryRange = maxRayQueryDistanceNoClip;                      }                        // Send a ray query to find the position on the terrain we are looking at.                      RayHit hit = ContainingWorld.Physics.RayTest(camera.Position' camera.Position + camera.ForwardDirection * maxRayQueryRange' character.Body);                      Item selection = Inventory.Selection;                      if (hit != null)                      {                          /// Subtract a few cm toward camera to increase stability near constraints.                          vec3 pos = hit.Position - camera.ForwardDirection * .04f;                            if (selection != null)                          {                              Crosshair.Reset();                              selection.OnRayPreview(this' hit' Crosshair);                          }                      }                      else if (selection != null)                      {                          Crosshair.Reset();                          selection.OnRayPreview(this' null' Crosshair);                      }                  }                  if (Inventory.Selection != null && Inventory.Selection.HasUpdatePreview)                      Inventory.Selection.OnUpdatePreview(this' elapsedSeconds' Crosshair);                    if (Inventory.Selection == null)                      Crosshair.Reset();                    // Notify the gui if the player freezing status has changed since the last update frame.                  if (WasFrozen != IsFrozen)                      Gui.OnUpdate();                  WasFrozen = IsFrozen;              }
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The following statement contains a magic number: if (GodMode)              {                  Inventory.AddItem(new ToolItem(ToolType.GodsShovel' new AegiriumSubstance()));                  Inventory.AddItem(new ToolItem(ToolType.Shovel' new CopperSubstance()));                  Inventory.AddItem(new ToolItem(ToolType.Axe' new CopperSubstance()));                  Inventory.AddItem(new ToolItem(ToolType.DroneChain' new IronSubstance()' 5));                  Inventory.AddItem(new PipetteItem());                  Inventory.AddItem(new TorchItem(1));                  foreach (var resource in TerrainResource.ListResources().Where(resource => resource.MassDensity > 0.0f))                      Inventory.AddResource(resource.Substance' 1e9f);                  genDefault = false;              }              else if (!File.Exists(UpvoidMiner.SavePathInventory))              {                  genDefault = true;              }              else // Load inventory              {                  var save = JsonConvert.DeserializeObject<InventorySave>(File.ReadAllText(UpvoidMiner.SavePathInventory));                  if (save.Version == InventorySave.SaveVersion)                  {                        var id2item = new Dictionary<long' Item>();                      foreach (var item in save.items)                      {                          id2item.Add(item.Id()' item.DeserializeItem());                          Inventory.AddItem(id2item[item.Id()]);                      }                        Inventory.ClearQuickAccess();                      for (int i = 0; i < Inventory.QuickAccessSlotCount; ++i)                          if (id2item.ContainsKey(save.quickAccess[i]))                              Inventory.SetQuickAccess(id2item[save.quickAccess[i]]' i);                      Inventory.SelectQuickAccessSlot(save.currentQuickAccess);                        genDefault = false;                  }                  else                      genDefault = true;              }
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The following statement contains a magic number: if (genDefault)              {                  // Tools                  Inventory.AddItem(new ToolItem(ToolType.Shovel' new BirchWoodSubstance()));                  Inventory.AddItem(new ToolItem(ToolType.Axe' new BirchWoodSubstance()));                  //Inventory.AddItem(new ToolItem(ToolType.Hammer));                  Inventory.AddItem(new ToolItem(ToolType.DroneChain' new IronSubstance()' 5));                    // Testing resource/material items.                  /*TerrainResource dirt = ContainingWorld.Terrain.QueryMaterialFromName("Dirt");                  TerrainResource stone06 = ContainingWorld.Terrain.QueryMaterialFromName("Stone.06");                   Inventory.AddResource(dirt' 10);                  Inventory.AddItem(new ResourceItem(dirt' 3f));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Sphere' new vec3(1)));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Sphere' new vec3(1)' 2));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Cylinder' new vec3(1'2'2)));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Sphere' new vec3(2)));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Cube' new vec3(2)));                  Inventory.AddItem(new MaterialItem(stone06' MaterialShape.Cylinder' new vec3(1'2'2)));                  Inventory.AddItem(new MaterialItem(dirt' MaterialShape.Sphere' new vec3(1)));*/                  /*Inventory.AddItem(new MaterialItem(TerrainResource.FromName("BlueCrystal")' MaterialShape.Sphere' new vec3(1)' 10));                  Inventory.AddItem(new MaterialItem(TerrainResource.FromName("FireRock")' MaterialShape.Cube' new vec3(1)' 10));                  Inventory.AddItem(new MaterialItem(TerrainResource.FromName("AlienRock")' MaterialShape.Cylinder' new vec3(1)' 10));*/              }
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The following statement contains a magic number: if (drones < 5)                  Inventory.AddItem(new ToolItem(ToolType.DroneChain' new IronSubstance()' 5 - drones));
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The following statement contains a magic number: if (drones < 5)                  Inventory.AddItem(new ToolItem(ToolType.DroneChain' new IronSubstance()' 5 - drones));
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,generateInitialItems,The following statement contains a magic number: Inventory.AddItem(new RecipeItem(new CraftingItem(CraftingItem.ItemType.Handle' new WoodSubstance()' 20)'                  new List<Item>                      {                          new MaterialItem(new WoodSubstance()' MaterialShape.Cylinder' new vec3(0.3f'0.5f'0.3f))                      }));
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,AlignmentSystem,The following statement contains a magic number: switch (CurrentDiggingAlignment)              {                  case DiggingController.DigAlignment.GridAligned: // fall-through intended                  case DiggingController.DigAlignment.Axis:                      float alpha = (float)(DiggingAlignmentAxisRotation * 5 * Math.PI / 180);                      dirX = new vec3((float)Math.Cos(alpha)' 0' (float)-Math.Sin(alpha));                      dirY = vec3.UnitY;                      dirZ = new vec3((float)Math.Sin(alpha)' 0' (float)Math.Cos(alpha));                      break;                  case DiggingController.DigAlignment.View:                      dirX = -camera.RightDirection.Normalized;                      dirZ = camera.UpDirection.Normalized;                      dirY = -camera.ForwardDirection.Normalized;                      break;                  case DiggingController.DigAlignment.Terrain:                      dirY = worldNormal.Normalized;                      dirX = vec3.cross(camera.ForwardDirection' dirY).Normalized;                      dirZ = vec3.cross(dirX' dirY).Normalized;                      break;                  default:                      throw new InvalidOperationException("Unknown alignment");              }
Magic Number,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,AlignmentSystem,The following statement contains a magic number: switch (CurrentDiggingAlignment)              {                  case DiggingController.DigAlignment.GridAligned: // fall-through intended                  case DiggingController.DigAlignment.Axis:                      float alpha = (float)(DiggingAlignmentAxisRotation * 5 * Math.PI / 180);                      dirX = new vec3((float)Math.Cos(alpha)' 0' (float)-Math.Sin(alpha));                      dirY = vec3.UnitY;                      dirZ = new vec3((float)Math.Sin(alpha)' 0' (float)Math.Cos(alpha));                      break;                  case DiggingController.DigAlignment.View:                      dirX = -camera.RightDirection.Normalized;                      dirZ = camera.UpDirection.Normalized;                      dirY = -camera.ForwardDirection.Normalized;                      break;                  case DiggingController.DigAlignment.Terrain:                      dirY = worldNormal.Normalized;                      dirX = vec3.cross(camera.ForwardDirection' dirY).Normalized;                      dirZ = vec3.cross(dirX' dirY).Normalized;                      break;                  default:                      throw new InvalidOperationException("Unknown alignment");              }
Magic Number,UpvoidMiner,ItemEntity,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemEntity.cs,UpdatePhysics,The following statement contains a magic number: foreach (var pc in physicsComponents)              {                  var body = pc.RigidBody;                    // Security: if in non-air chunk' teleport to next all-air one                  mat4 transformation = body.GetTransformation();                  vec3 pos = new vec3(transformation.col3);                  if (vec3.distance(lastPhysicsPos' pos) < 0.01)                      return; // early abort                    lastPhysicsPos = pos;                  WorldTreeNode node = ContainingWorld.QueryWorldTreeNode(pos);                  if (node != null && node.IsMinLod)                  {                      HermiteData volumeData = node.CurrentVolume;                      if (volumeData != null)                      {                          if (!volumeData.HasAir)                          {                              // we are definitely in a non-air chunk here                              // teleport one node size above                              body.SetTransformation(mat4.Translate(new vec3(0' node.Size' 0)) * body.GetTransformation());                          }                          else if (!volumeData.HasAirAt(pos))                          {                              // we are in a mixed chunk' advance pos until air                              float offset = 0f;                              do                              {                                  pos.y += 0.5f;                                  offset += 0.5f;                              } while (!volumeData.HasAirAt(pos) || !volumeData.HasAirAt(pos + new vec3(0' 1.5f' 0)));                                // another 1.5m to ensure good ground                              offset += 1.5f;                                body.SetTransformation(mat4.Translate(new vec3(0' offset' 0)) * body.GetTransformation());                          }                      }                  }                    break; // only one RB supported              }
Magic Number,UpvoidMiner,PlayerGui,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\PlayerGui.cs,webSelectItem,The following statement contains a magic number: player.Inventory.SetQuickAccess(item' 9);
Magic Number,UpvoidMiner,PlayerGui,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\PlayerGui.cs,webSelectItem,The following statement contains a magic number: player.Inventory.SelectQuickAccessSlot(9);
Magic Number,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Update,The following statement contains a magic number: if ((realTarget - CurrentPosition).Length > .001)              {                  float dis = elapsedSeconds * Speed;                  if ((realTarget - CurrentPosition).Length < dis)                      CurrentPosition = realTarget;                  else                      CurrentPosition += (realTarget - CurrentPosition).Normalized * dis;                    thisEntity.Transform = mat4.Translate(CurrentPosition);              }              else if(rb == null) // Only create its rigid body once the drone found its final position.              {                  // Add a RigidBody                  rb = new RigidBody(0.0f' thisEntity.Transform' new SphereShape(0.25f));                  this.ContainingWorld.Physics.AddRigidBody(rb);                  thisEntity.AddComponent(new PhysicsComponent(rb' mat4.Identity));              }
Magic Number,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Update,The following statement contains a magic number: renderComponentWing1Opaque.Transform = renderComponentWing1Shadow.Transform = mat4.Scale(DroneScale) * mat4.RotateY(-360 * RotationSpeed * lifetime);
Magic Number,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Update,The following statement contains a magic number: renderComponentWing2Opaque.Transform = renderComponentWing2Shadow.Transform = mat4.Scale(DroneScale) * mat4.RotateY(360 * RotationSpeed * lifetime);
Magic Number,UpvoidMiner,Drone,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Drone.cs,Init,The following statement contains a magic number: thisEntity.AddComponent(new RenderComponent(                  new MeshRenderJob(Renderer.Transparent.Mesh' Resources.UseMaterial("Miner/DroneIndicator"' UpvoidMiner.ModDomain)' Resources.UseMesh("Miner/DroneIndicator"' UpvoidMiner.ModDomain)' mat4.Identity)'                  mat4.Scale(new vec3(.03f'7'.03f))'                  true));
Magic Number,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,configureVerticalConstraint,The following statement contains a magic number: vec3 up = new vec3(0' 14 * 2 * 100' 0);
Magic Number,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,configureVerticalConstraint,The following statement contains a magic number: vec3 up = new vec3(0' 14 * 2 * 100' 0);
Magic Number,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,configureVerticalConstraint,The following statement contains a magic number: vec3 up = new vec3(0' 14 * 2 * 100' 0);
Magic Number,UpvoidMiner,DroneConstraint,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\DroneConstraint.cs,Update,The following statement contains a magic number: if (Drones.Count > 0)              {                    Drone refDrone = ReferenceDrone;                    switch (refDrone.Type)                  {                      case DroneType.Chain:                          for (int i = 0; i < Drones.Count - 1; ++i)                          {                              Drone first = Drones[i];                              Drone second = Drones[i + 1];                                // Swap every other drone.                              if (i % 2 == 1)                              {                                  Drone tmp = first;                                  first = second;                                  second = tmp;                              }                                bool addJob = false;                              if (boundaryIndicators.Count <= i)                              {                                  boundaryIndicators.Add(new MeshRenderJob(Renderer.Transparent.Mesh'                                                                            Resources.UseMaterial("Miner/DroneConstraintVertical"' UpvoidMiner.ModDomain)'                                                                           Resources.UseMesh("::Debug/Quad"' UpvoidMiner.ModDomain)'                                                                           mat4.Identity));                                  boundaryIndicatorsDistort.Add(new MeshRenderJob(Renderer.Distortion.Mesh'                                                                                   Resources.UseMaterial("Miner/DroneConstraintVerticalDistort"' UpvoidMiner.ModDomain)'                                                                                  Resources.UseMesh("::Debug/Quad"' UpvoidMiner.ModDomain)'                                                                                  mat4.Identity));                                    // Vertical drones cause a constraint by the intersection of the planes (i.e. the plane between two drones and the two shadow-planes).                                  constraintExpression.Add(new CsgExpression(1' "max((dot(plane1Normal' vec3(x' y' z)) - plane1Dis)' max( (dot(plane2Normal' vec3(x' y' z)) - plane2Dis)' (dot(plane3Normal' vec3(x' y' z)) - plane3Dis)) )"'                                                                              UpvoidMiner.ModDomain'                                                                              "plane1Normal:vec3' plane1Dis:float' plane2Normal:vec3' plane2Dis:float' plane3Normal:vec3' plane3Dis:float"));                                  addJob = true;                              }                                                            MeshRenderJob job1 = boundaryIndicators[i];                              MeshRenderJob job2 = boundaryIndicatorsDistort[i];                                configureVerticalConstraint(first' second' job1' job2);                                if (addJob)                              {                                  LocalScript.world.AddRenderJob(job1);                                  LocalScript.world.AddRenderJob(job2);                              }                          }                                                      break;                      default:                          Debug.Fail("Not implemented/Invalid");                          break;                  }              }
Magic Number,UpvoidMiner,Inventory,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\Inventory.cs,SetQuickAccess,The following statement contains a magic number: Debug.Assert(0 <= idx && idx <= 9);
Magic Number,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnUse,The following statement contains a magic number: switch (player.CurrentDiggingShape)              {                  case DiggingController.DigShape.Box:                      useVolume = 8 * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / 8' 1 / 3f);                      break;                  case DiggingController.DigShape.Cylinder:                      useVolume = 2f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (2f * (float)Math.PI)' 1 / 3f);                      break;                  case DiggingController.DigShape.Sphere:                      useVolume = 4f / 3f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (4f / 3f * (float)Math.PI)' 1 / 3f);                      break;                  case DiggingController.DigShape.Cone:                      useVolume = 1f / 3f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (1f / 3f * (float)Math.PI)' 1 / 3f);                      break;                  default:                      throw new InvalidOperationException("Unknown digging shape");              }
Magic Number,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnUse,The following statement contains a magic number: switch (player.CurrentDiggingShape)              {                  case DiggingController.DigShape.Box:                      useVolume = 8 * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / 8' 1 / 3f);                      break;                  case DiggingController.DigShape.Cylinder:                      useVolume = 2f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (2f * (float)Math.PI)' 1 / 3f);                      break;                  case DiggingController.DigShape.Sphere:                      useVolume = 4f / 3f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (4f / 3f * (float)Math.PI)' 1 / 3f);                      break;                  case DiggingController.DigShape.Cone:                      useVolume = 1f / 3f * (float)Math.PI * useRadius * useRadius * useRadius;                      if (useVolume > Volume)                          radius = (float)Math.Pow(Volume / (1f / 3f * (float)Math.PI)' 1 / 3f);                      break;                  default:                      throw new InvalidOperationException("Unknown digging shape");              }
Magic Number,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The following statement contains a magic number: switch (_player.CurrentDiggingShape)              {                  case DiggingController.DigShape.Box:                      volumeFactor = 8;                      break;                  case DiggingController.DigShape.Cylinder:                      volumeFactor = 2 * (float)Math.PI;                      break;                  case DiggingController.DigShape.Sphere:                      volumeFactor = 4f / 3f * (float)Math.PI;                      break;                  case DiggingController.DigShape.Cone:                      volumeFactor = 1f / 3f * (float)Math.PI;                      break;                  default:                      throw new InvalidOperationException("Unknown digging shape");              }
Magic Number,UpvoidMiner,ResourceItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ResourceItem.cs,OnRayPreview,The following statement contains a magic number: switch (_player.CurrentDiggingShape)              {                  case DiggingController.DigShape.Box:                      volumeFactor = 8;                      break;                  case DiggingController.DigShape.Cylinder:                      volumeFactor = 2 * (float)Math.PI;                      break;                  case DiggingController.DigShape.Sphere:                      volumeFactor = 4f / 3f * (float)Math.PI;                      break;                  case DiggingController.DigShape.Cone:                      volumeFactor = 1f / 3f * (float)Math.PI;                      break;                  default:                      throw new InvalidOperationException("Unknown digging shape");              }
Magic Number,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,VolumeOf,The following statement contains a magic number: switch (shape)              {                  case MaterialShape.Cube: return size.x * size.y * size.z;                  case MaterialShape.Cylinder: return 2 * (float)Math.PI * size.x * size.y * size.z;                  case MaterialShape.Sphere: return 4f / 3f * (float)Math.PI * size.x * size.y * size.z;                  case MaterialShape.Cone: return 1f / 3f * (float)Math.PI * size.x * size.y * size.z;                  default: Debug.Fail("Invalid shape"); return -1;              }
Magic Number,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,TryMerge,The following statement contains a magic number: if (Math.Abs(Durability - item.Durability) > 0.01) return false;
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandleAxisInput,The following statement contains a magic number: if (e.Axis == AxisType.MouseWheelY)              {                  float delta = e.RelativeChange / 100;                  // Control + Wheel to change 'use-parameter'.                  if (keyModifierControl)                  {                      Item selection = player.Inventory.Selection;                      if (selection != null)                          selection.OnUseParameterChange(player' delta);                  }                  else // Otherwise used to cycle through quick access.                  {                      int newIdx = player.Inventory.SelectionIndex - (int)(delta);                      while (newIdx < 0)                          newIdx += Inventory.QuickAccessSlotCount;                        player.Inventory.SelectQuickAccessSlot(newIdx % Inventory.QuickAccessSlotCount);                  }              }              else if (e.Axis == AxisType.MouseX)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenX > 0)                      {                          --wasMenuOpenX;                          return;                      }                        float rotAzimuthSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotAzimuthSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(e.RelativeChange * rotAzimuthSpeed' 0));                  }                  else wasMenuOpenX = 3;              }              else if (e.Axis == AxisType.MouseY)              {                  if (!player.Gui.IsInventoryOpen && !player.Gui.IsMenuOpen)                  {                      if (wasMenuOpenY > 0)                      {                          --wasMenuOpenY;                          return;                      }                        float rotElevationSpeed = -.4f;                      float sensitivity = Settings.settings.MouseSensitivityF;                      rotElevationSpeed *= (float)Math.Pow(2' sensitivity * 10 - 7);                      player.Lookaround(new vec2(0' e.RelativeChange * rotElevationSpeed));                  }                  else wasMenuOpenY = 3;              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The following statement contains a magic number: if (e.PressType == InputPressArgs.KeyPressType.Down)              {                    switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = true;                          break;                      case InputKey.Control:                          keyModifierControl = true;                          break;                      case InputKey.Alt:                          //keyModifierAlt = true;                          break;                        case InputKey.F8:                          Renderer.Opaque.Mesh.DebugWireframe = !Renderer.Opaque.Mesh.DebugWireframe;                          break;                        case InputKey.F12:                          string screenshotName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss") + ".png";                          Console.WriteLine("Writing screenshot to " + screenshotName);                          shutterSound.Play();                          Rendering.WriteNextFrameToFile("Screenshots/" + screenshotName' 1920' 1080);                          break;                        case InputKey.Q:                          if (player.Inventory.Selection != null)                          {                              // Tutorial: Important! before: dropping                              if (player.Inventory.Selection is MaterialItem)                                  Tutorials.MsgAdvancedCraftingThrowQ.Report(1);                                player.DropItem(player.Inventory.Selection);                          }                          break;                        case InputKey.Period:                          if (LocalScript.musicQueue != null)                              LocalScript.musicQueue.SkipCurrentSong();                          break;                        // F1 resets the player position                      case InputKey.F1:                          player.SetPosition(Player.SpawnPosition);                          break;                        // Tab and shift-Tab cycle between digging shapes                      case InputKey.Tab:                            if (!keyModifierControl)                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigShape)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingShape = (DiggingController.DigShape)(((uint)player.CurrentDiggingShape - 1 + offset) % vals + 1);                          }                          else                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigAlignment)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingAlignment = (DiggingController.DigAlignment)(((uint)player.CurrentDiggingAlignment - 1 + offset) % vals + 1);                          }                            player.RefreshSelection();                            break;                        default:                          break;                  }                    // Quickaccess items.                  if (InputKey.Key1 <= e.Key && e.Key <= InputKey.Key9)                      player.Inventory.SelectQuickAccessSlot((int)e.Key - (int)InputKey.Key1);                  if (e.Key == InputKey.Key0)                      player.Inventory.SelectQuickAccessSlot(9); // Special '0'.              }              else if (e.PressType == InputPressArgs.KeyPressType.Up)              {                  switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = false;                          break;                      case InputKey.Control:                          keyModifierControl = false;                          break;                      case InputKey.Alt:                          //keyModifierAlt = false;                          break;                  }              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The following statement contains a magic number: if (e.PressType == InputPressArgs.KeyPressType.Down)              {                    switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = true;                          break;                      case InputKey.Control:                          keyModifierControl = true;                          break;                      case InputKey.Alt:                          //keyModifierAlt = true;                          break;                        case InputKey.F8:                          Renderer.Opaque.Mesh.DebugWireframe = !Renderer.Opaque.Mesh.DebugWireframe;                          break;                        case InputKey.F12:                          string screenshotName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss") + ".png";                          Console.WriteLine("Writing screenshot to " + screenshotName);                          shutterSound.Play();                          Rendering.WriteNextFrameToFile("Screenshots/" + screenshotName' 1920' 1080);                          break;                        case InputKey.Q:                          if (player.Inventory.Selection != null)                          {                              // Tutorial: Important! before: dropping                              if (player.Inventory.Selection is MaterialItem)                                  Tutorials.MsgAdvancedCraftingThrowQ.Report(1);                                player.DropItem(player.Inventory.Selection);                          }                          break;                        case InputKey.Period:                          if (LocalScript.musicQueue != null)                              LocalScript.musicQueue.SkipCurrentSong();                          break;                        // F1 resets the player position                      case InputKey.F1:                          player.SetPosition(Player.SpawnPosition);                          break;                        // Tab and shift-Tab cycle between digging shapes                      case InputKey.Tab:                            if (!keyModifierControl)                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigShape)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingShape = (DiggingController.DigShape)(((uint)player.CurrentDiggingShape - 1 + offset) % vals + 1);                          }                          else                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigAlignment)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingAlignment = (DiggingController.DigAlignment)(((uint)player.CurrentDiggingAlignment - 1 + offset) % vals + 1);                          }                            player.RefreshSelection();                            break;                        default:                          break;                  }                    // Quickaccess items.                  if (InputKey.Key1 <= e.Key && e.Key <= InputKey.Key9)                      player.Inventory.SelectQuickAccessSlot((int)e.Key - (int)InputKey.Key1);                  if (e.Key == InputKey.Key0)                      player.Inventory.SelectQuickAccessSlot(9); // Special '0'.              }              else if (e.PressType == InputPressArgs.KeyPressType.Up)              {                  switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = false;                          break;                      case InputKey.Control:                          keyModifierControl = false;                          break;                      case InputKey.Alt:                          //keyModifierAlt = false;                          break;                  }              }
Magic Number,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The following statement contains a magic number: if (e.PressType == InputPressArgs.KeyPressType.Down)              {                    switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = true;                          break;                      case InputKey.Control:                          keyModifierControl = true;                          break;                      case InputKey.Alt:                          //keyModifierAlt = true;                          break;                        case InputKey.F8:                          Renderer.Opaque.Mesh.DebugWireframe = !Renderer.Opaque.Mesh.DebugWireframe;                          break;                        case InputKey.F12:                          string screenshotName = DateTime.Now.ToString("yyyy-MM-dd_HH-mm-ss") + ".png";                          Console.WriteLine("Writing screenshot to " + screenshotName);                          shutterSound.Play();                          Rendering.WriteNextFrameToFile("Screenshots/" + screenshotName' 1920' 1080);                          break;                        case InputKey.Q:                          if (player.Inventory.Selection != null)                          {                              // Tutorial: Important! before: dropping                              if (player.Inventory.Selection is MaterialItem)                                  Tutorials.MsgAdvancedCraftingThrowQ.Report(1);                                player.DropItem(player.Inventory.Selection);                          }                          break;                        case InputKey.Period:                          if (LocalScript.musicQueue != null)                              LocalScript.musicQueue.SkipCurrentSong();                          break;                        // F1 resets the player position                      case InputKey.F1:                          player.SetPosition(Player.SpawnPosition);                          break;                        // Tab and shift-Tab cycle between digging shapes                      case InputKey.Tab:                            if (!keyModifierControl)                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigShape)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingShape = (DiggingController.DigShape)(((uint)player.CurrentDiggingShape - 1 + offset) % vals + 1);                          }                          else                          {                              int vals = Enum.GetValues(typeof(DiggingController.DigAlignment)).Length;                              int offset = keyModifierShift ? vals - 1 : 1;                              player.CurrentDiggingAlignment = (DiggingController.DigAlignment)(((uint)player.CurrentDiggingAlignment - 1 + offset) % vals + 1);                          }                            player.RefreshSelection();                            break;                        default:                          break;                  }                    // Quickaccess items.                  if (InputKey.Key1 <= e.Key && e.Key <= InputKey.Key9)                      player.Inventory.SelectQuickAccessSlot((int)e.Key - (int)InputKey.Key1);                  if (e.Key == InputKey.Key0)                      player.Inventory.SelectQuickAccessSlot(9); // Special '0'.              }              else if (e.PressType == InputPressArgs.KeyPressType.Up)              {                  switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = false;                          break;                      case InputKey.Control:                          keyModifierControl = false;                          break;                      case InputKey.Alt:                          //keyModifierAlt = false;                          break;                  }              }
Magic Number,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The following statement contains a magic number: desertResource.Material.AddAttributeFloat("aParviflora"' 0' 0' 4);
Magic Number,UpvoidMiner,TerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\TerrainResource.cs,RegisterResources,The following statement contains a magic number: {                  int pipeline = desertResource.Material.AddPipeline(Resources.UseGeometryPipeline("ParvifloraField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                  desertResource.Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Parviflora"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  desertResource.Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Parviflora.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);              }
Magic Number,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The following statement contains a magic number: concat.AddNode(new CsgAutomatonNode(Resources.UseAutomaton("Trees"' UpvoidMiner.ModDomain)' world' 4));
Magic Number,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,createTerrain,The following statement contains a magic number: concat.AddNode(new CsgAutomatonNode(Resources.UseAutomaton("Surface"' UpvoidMiner.ModDomain)' world' 4));
Magic Number,UpvoidMiner,SolidTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\SolidTerrainResource.cs,SolidTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add a default pipeline. (Solid material with zPre and Shadow pass)                  if (defaultPipeline)                  {                      { // LoD 0-4                          int pipe = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredRock"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                          Material.AddDefaultShadowAndZPre(pipe);                          Material.AddMeshMaterial(pipe' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                      }                        { // LoD 5-max                          int pipe = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredRockLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                          Material.AddDefaultShadowAndZPre(pipe);                          Material.AddMeshMaterial(pipe' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                      }                  }              }
Magic Number,UpvoidMiner,SolidTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\SolidTerrainResource.cs,SolidTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add a default pipeline. (Solid material with zPre and Shadow pass)                  if (defaultPipeline)                  {                      { // LoD 0-4                          int pipe = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredRock"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                          Material.AddDefaultShadowAndZPre(pipe);                          Material.AddMeshMaterial(pipe' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                      }                        { // LoD 5-max                          int pipe = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredRockLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                          Material.AddDefaultShadowAndZPre(pipe);                          Material.AddMeshMaterial(pipe' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                      }                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,VegetatedTerrainResource,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\VegetatedTerrainResource.cs,VegetatedTerrainResource,The following statement contains a magic number: if (Scripting.IsHost)              {                  // Add Gras attribute for LoD 4 (= MinLoD).                  Material.AddAttributeFloat("aGrass"' 0' 0' 4);                    // Lod 0-4                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrain"' UpvoidMiner.ModDomain)' "Input"' "Input"' 0' 4);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' Resources.UseMaterial("Terrain/DirtVegetated"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Lod 5-max                  // Color modulated geometry pipeline for more variance.                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("ColoredTerrainLow"' UpvoidMiner.ModDomain)' "Input"' "Input"' 5);                      Material.AddDefaultShadowAndZPre(pipeline);                      Material.AddMeshMaterial(pipeline' "Output"' RenderMaterial' Renderer.Opaque.Mesh);                  }                      // Spawn Grass                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("GrassField"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.Transparent"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("SimpleGrass.zPre"' UpvoidMiner.ModDomain)' Renderer.zPre.Mesh);                        var materialIdx = Material.AddMeshMaterial(pipeline' "GrassBlades"' Resources.UseMaterial("Vegetation/GrassBlades"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                        GrassPipelineIndex = pipeline;                      GrassMaterialIndex = materialIdx;                        Material.SetPipelineActive(pipeline' Settings.settings.Grass);                  }                    // Spawn Flowers                  {                      //int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower01"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn more Flowers                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Flowers2"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      //Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower02.ShadowDecal"' UpvoidMiner.ModDomain)' Renderer.Transparent.Mesh);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Flower"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }                    // Spawn fern                  {                      int pipeline = Material.AddPipeline(Resources.UseGeometryPipeline("Fern"' UpvoidMiner.ModDomain)' "Input"' ""' 0' 4);                      Material.AddMeshMaterial(pipeline' "ColoredSpawns"' Resources.UseMaterial("Fern"' UpvoidMiner.ModDomain)' Renderer.Opaque.Mesh);                  }              }
Magic Number,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Init,The following statement contains a magic number: if (chopSoundResource == null && chopSound == null)              {                  chopSoundResource = new SoundResource[5];                  chopSound = new Sound[5];                    // Add dirt digging sounds                  for (int i = 1; i <= 5; ++i)                  {                      chopSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Chopping/Wood/Wood" + i.ToString("00")' UpvoidMiner.ModDomain);                      chopSound[i - 1] = new Sound(chopSoundResource[i - 1]' vec3.Zero' false' 1' 1);                  }              }
Magic Number,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Init,The following statement contains a magic number: if (chopSoundResource == null && chopSound == null)              {                  chopSoundResource = new SoundResource[5];                  chopSound = new Sound[5];                    // Add dirt digging sounds                  for (int i = 1; i <= 5; ++i)                  {                      chopSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Chopping/Wood/Wood" + i.ToString("00")' UpvoidMiner.ModDomain);                      chopSound[i - 1] = new Sound(chopSoundResource[i - 1]' vec3.Zero' false' 1' 1);                  }              }
Magic Number,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Init,The following statement contains a magic number: if (chopSoundResource == null && chopSound == null)              {                  chopSoundResource = new SoundResource[5];                  chopSound = new Sound[5];                    // Add dirt digging sounds                  for (int i = 1; i <= 5; ++i)                  {                      chopSoundResource[i - 1] = Resources.UseSound("Mods/Upvoid/Resources.SFX/1.0.0::Chopping/Wood/Wood" + i.ToString("00")' UpvoidMiner.ModDomain);                      chopSound[i - 1] = new Sound(chopSoundResource[i - 1]' vec3.Zero' false' 1' 1);                  }              }
Magic Number,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Hit,The following statement contains a magic number: Sound woodSound = chopSound[random.Next(0' 4)];
Magic Number,UpvoidMiner,Tree,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\Tree.cs,Hit,The following statement contains a magic number: int numberOfWoodCylinders = (int)(3 * amountOfWood + 1.0f);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: int type = (int)(random.NextDouble()*6.0);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: if(type > 5) type = 5;
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: if(type > 5) type = 5;
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: RigidBody b = new RigidBody(0f' transform1 * mat4.Translate(new vec3(0'5'0))' new CylinderShape(.5f' 10));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: RigidBody b = new RigidBody(0f' transform1 * mat4.Translate(new vec3(0'5'0))' new CylinderShape(.5f' 10));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Cactus,The following statement contains a magic number: l.PhysicsComps.Add(new PhysicsComponent(b' mat4.Translate(new vec3(0'-5'0))));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: if(randy < 0.34)              {                  trunkMesh = "Vegetation/Tree01/Trunk";                  leavesMesh = "Vegetation/Tree01/Leaves_medium";              }              else if(randy < 0.67)              {                  trunkMesh = "Vegetation/Tree02/Trunk";                  leavesMesh = "Vegetation/Tree02/Leaves_low";              }              else              {                  trunkMesh = "Vegetation/Tree03/Trunk";                  leavesMesh = "Vegetation/Tree03/Leaves_medium";              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: if(randy < 0.34)              {                  trunkMesh = "Vegetation/Tree01/Trunk";                  leavesMesh = "Vegetation/Tree01/Leaves_medium";              }              else if(randy < 0.67)              {                  trunkMesh = "Vegetation/Tree02/Trunk";                  leavesMesh = "Vegetation/Tree02/Leaves_low";              }              else              {                  trunkMesh = "Vegetation/Tree03/Trunk";                  leavesMesh = "Vegetation/Tree03/Leaves_medium";              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: RigidBody b = new RigidBody(0f' transform1 * mat4.Translate(new vec3(0'5'0))' new CylinderShape(.5f' 10));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: RigidBody b = new RigidBody(0f' transform1 * mat4.Translate(new vec3(0'5'0))' new CylinderShape(.5f' 10));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: l.PhysicsComps.Add(new PhysicsComponent(b' mat4.Translate(new vec3(0'-5'0))));
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: float fadeOutMin = Math.Max(5' maxTreeDistanceSetting - 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: float fadeOutMin = Math.Max(5' maxTreeDistanceSetting - 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: float fadeOutMax = Math.Max(10' maxTreeDistanceSetting + 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,OldTree,The following statement contains a magic number: float fadeOutMax = Math.Max(10' maxTreeDistanceSetting + 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: float unitHeight = radius * 2 * (float)Math.PI * 2 * .6f;
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: float unitHeight = radius * 2 * (float)Math.PI * 2 * .6f;
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: while (hsum < height)              {                  float h = unitHeight * (.8f + (float)random.NextDouble() * .4f);                  t.Logs.Add(CreateLog(t' new vec3(0' hsum' 0)' vec3.UnitY' vec3.UnitZ' h' radius' mat' "Vegetation/Trunk-1.0"));                    int leaves = (int)(0 + (hsum / height) * (8 + random.Next(0' 3)));                  for (int i = 0; i < leaves * 4; ++i)                  {                      vec3 rad = new vec3((float)random.NextDouble() - .5f' 0' (float)random.NextDouble() - .5f).Normalized;                        vec3 pos = new vec3(0' hsum + (float)random.NextDouble() * h' 0) + rad * radius * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                                            foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }                                    hsum += h;               }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: while (hsum < height)              {                  float h = unitHeight * (.8f + (float)random.NextDouble() * .4f);                  t.Logs.Add(CreateLog(t' new vec3(0' hsum' 0)' vec3.UnitY' vec3.UnitZ' h' radius' mat' "Vegetation/Trunk-1.0"));                    int leaves = (int)(0 + (hsum / height) * (8 + random.Next(0' 3)));                  for (int i = 0; i < leaves * 4; ++i)                  {                      vec3 rad = new vec3((float)random.NextDouble() - .5f' 0' (float)random.NextDouble() - .5f).Normalized;                        vec3 pos = new vec3(0' hsum + (float)random.NextDouble() * h' 0) + rad * radius * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                                            foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }                                    hsum += h;               }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: while (hsum < height)              {                  float h = unitHeight * (.8f + (float)random.NextDouble() * .4f);                  t.Logs.Add(CreateLog(t' new vec3(0' hsum' 0)' vec3.UnitY' vec3.UnitZ' h' radius' mat' "Vegetation/Trunk-1.0"));                    int leaves = (int)(0 + (hsum / height) * (8 + random.Next(0' 3)));                  for (int i = 0; i < leaves * 4; ++i)                  {                      vec3 rad = new vec3((float)random.NextDouble() - .5f' 0' (float)random.NextDouble() - .5f).Normalized;                        vec3 pos = new vec3(0' hsum + (float)random.NextDouble() * h' 0) + rad * radius * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                                            foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }                                    hsum += h;               }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: int branches = random.Next(3' 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: int branches = random.Next(3' 5);
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: for (int i = 0; i < branches; ++i)              {                  float h = (float)((1 - random.NextDouble() * random.NextDouble()) * hsum) * .8f + .1f;                  vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized;                  vec3 front = vec3.cross(dir' vec3.UnitY).Normalized;                  vec3 left = vec3.cross(front' dir);                  float r = radius * (0.2f + (float)random.NextDouble() * .4f);                  vec3 basePos = new vec3(0' h' 0);                  float branchLength = unitHeight * (.8f + (float)random.NextDouble() * .4f + .1f) * .7f;                  t.Logs.Add(CreateLog(t' basePos' dir' front' branchLength' r' mat' "Vegetation/Trunk-0.8"));                                     int leaves = (int)(4 + random.Next(0' 3));                  for (int j = 0; j < leaves * 4; ++j)                  {                      vec3 rad = (((float)random.NextDouble() - .5f) * left + ((float)random.NextDouble() - .5f) * front).Normalized;                        vec3 pos = basePos + dir * branchLength * (float)random.NextDouble() + rad * r * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                        foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: for (int i = 0; i < branches; ++i)              {                  float h = (float)((1 - random.NextDouble() * random.NextDouble()) * hsum) * .8f + .1f;                  vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized;                  vec3 front = vec3.cross(dir' vec3.UnitY).Normalized;                  vec3 left = vec3.cross(front' dir);                  float r = radius * (0.2f + (float)random.NextDouble() * .4f);                  vec3 basePos = new vec3(0' h' 0);                  float branchLength = unitHeight * (.8f + (float)random.NextDouble() * .4f + .1f) * .7f;                  t.Logs.Add(CreateLog(t' basePos' dir' front' branchLength' r' mat' "Vegetation/Trunk-0.8"));                                     int leaves = (int)(4 + random.Next(0' 3));                  for (int j = 0; j < leaves * 4; ++j)                  {                      vec3 rad = (((float)random.NextDouble() - .5f) * left + ((float)random.NextDouble() - .5f) * front).Normalized;                        vec3 pos = basePos + dir * branchLength * (float)random.NextDouble() + rad * r * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                        foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: for (int i = 0; i < branches; ++i)              {                  float h = (float)((1 - random.NextDouble() * random.NextDouble()) * hsum) * .8f + .1f;                  vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized;                  vec3 front = vec3.cross(dir' vec3.UnitY).Normalized;                  vec3 left = vec3.cross(front' dir);                  float r = radius * (0.2f + (float)random.NextDouble() * .4f);                  vec3 basePos = new vec3(0' h' 0);                  float branchLength = unitHeight * (.8f + (float)random.NextDouble() * .4f + .1f) * .7f;                  t.Logs.Add(CreateLog(t' basePos' dir' front' branchLength' r' mat' "Vegetation/Trunk-0.8"));                                     int leaves = (int)(4 + random.Next(0' 3));                  for (int j = 0; j < leaves * 4; ++j)                  {                      vec3 rad = (((float)random.NextDouble() - .5f) * left + ((float)random.NextDouble() - .5f) * front).Normalized;                        vec3 pos = basePos + dir * branchLength * (float)random.NextDouble() + rad * r * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                        foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: for (int i = 0; i < branches; ++i)              {                  float h = (float)((1 - random.NextDouble() * random.NextDouble()) * hsum) * .8f + .1f;                  vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized;                  vec3 front = vec3.cross(dir' vec3.UnitY).Normalized;                  vec3 left = vec3.cross(front' dir);                  float r = radius * (0.2f + (float)random.NextDouble() * .4f);                  vec3 basePos = new vec3(0' h' 0);                  float branchLength = unitHeight * (.8f + (float)random.NextDouble() * .4f + .1f) * .7f;                  t.Logs.Add(CreateLog(t' basePos' dir' front' branchLength' r' mat' "Vegetation/Trunk-0.8"));                                     int leaves = (int)(4 + random.Next(0' 3));                  for (int j = 0; j < leaves * 4; ++j)                  {                      vec3 rad = (((float)random.NextDouble() - .5f) * left + ((float)random.NextDouble() - .5f) * front).Normalized;                        vec3 pos = basePos + dir * branchLength * (float)random.NextDouble() + rad * r * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                        foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }              }
Magic Number,UpvoidMiner,TreeGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Vegetation\TreeGenerator.cs,Birch,The following statement contains a magic number: for (int i = 0; i < branches; ++i)              {                  float h = (float)((1 - random.NextDouble() * random.NextDouble()) * hsum) * .8f + .1f;                  vec3 dir = new vec3((float)random.NextDouble() * 2  - 1' .3f + (float)random.NextDouble() * .6f' (float)random.NextDouble() * 2 - 1).Normalized;                  vec3 front = vec3.cross(dir' vec3.UnitY).Normalized;                  vec3 left = vec3.cross(front' dir);                  float r = radius * (0.2f + (float)random.NextDouble() * .4f);                  vec3 basePos = new vec3(0' h' 0);                  float branchLength = unitHeight * (.8f + (float)random.NextDouble() * .4f + .1f) * .7f;                  t.Logs.Add(CreateLog(t' basePos' dir' front' branchLength' r' mat' "Vegetation/Trunk-0.8"));                                     int leaves = (int)(4 + random.Next(0' 3));                  for (int j = 0; j < leaves * 4; ++j)                  {                      vec3 rad = (((float)random.NextDouble() - .5f) * left + ((float)random.NextDouble() - .5f) * front).Normalized;                        vec3 pos = basePos + dir * branchLength * (float)random.NextDouble() + rad * r * .9f;                      vec3 normal = (rad + new vec3(0'.3f - (float)random.NextDouble() * .6f'0)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 tangent = vec3.cross(normal' new vec3((float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f' (float)random.NextDouble() - .5f)).Normalized * (1 + (float)random.NextDouble() * (.2f + hsum/height * .3f));                      vec3 color = new vec3(.9f + (float)random.NextDouble() * .4f' 1' 1);                        foliageJob.AddSeed(pos' normal' tangent' color);                      foliageJob2.AddSeed(pos' normal' tangent' color);                      foliageJob3.AddSeed(pos' normal' tangent' color);                  }              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,StringToVideoMode,The following statement contains a magic number: Debug.Assert(curMode.Count() == 2);
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,StringToVideoMode,The following statement contains a magic number: if (curMode.Count() == 2)              {                  return new VideoMode(int.Parse(curMode[0])' int.Parse(curMode[1]));              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,StringToVideoMode,The following statement contains a magic number: return new VideoMode(-2' -2);
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,StringToVideoMode,The following statement contains a magic number: return new VideoMode(-2' -2);
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,Settings,The following statement contains a magic number: foreach (string vidMode in modes)              {                  var mode = StringToVideoMode(vidMode);                  if (mode.Width > 0 && mode.Height > 0 &&                      (mode.Width < 1100 || mode.Height < 700))                      continue;                  supportedVideoModes.Add(mode);              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,Settings,The following statement contains a magic number: foreach (string vidMode in modes)              {                  var mode = StringToVideoMode(vidMode);                  if (mode.Width > 0 && mode.Height > 0 &&                      (mode.Width < 1100 || mode.Height < 700))                      continue;                  supportedVideoModes.Add(mode);              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMin,The following statement contains a magic number: LodFalloff = 10;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMin,The following statement contains a magic number: MaxTreeDistance = 30;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetLow,The following statement contains a magic number: MinLodDistance = 10;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetLow,The following statement contains a magic number: LodFalloff = 20;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetLow,The following statement contains a magic number: MaxTreeDistance = 50;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: AnisotropicFiltering = 2;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: TextureResolution = 2;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: ShadowResolution = 2;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: MinLodDistance = 20;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: LodFalloff = 30;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMedium,The following statement contains a magic number: MaxTreeDistance = 100;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: AnisotropicFiltering = 3;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: TextureResolution = 3;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: ShadowResolution = 3;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: MinLodDistance = 30;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: LodFalloff = 40;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetHigh,The following statement contains a magic number: MaxTreeDistance = 200;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: AnisotropicFiltering = 4;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: TextureResolution = 4;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: ShadowResolution = 4;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: MinLodDistance = 50;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: LodFalloff = 50;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,SettingsPresetMax,The following statement contains a magic number: MaxTreeDistance = 300;
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The following statement contains a magic number: {                  int maxTreeDist = (int)settingMaxTreeDistance.value;                  float fadeOutMin = Math.Max(5' maxTreeDist - 5);     // >= 5                  float fadeOutMax = Math.Max(10' maxTreeDist + 5);    // >= 10                  float fadeTime = 1.0f; // 1 second                  UpvoidMinerWorldGenerator.setTreeLodSettings(fadeOutMin' fadeOutMax' fadeTime);              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The following statement contains a magic number: {                  int maxTreeDist = (int)settingMaxTreeDistance.value;                  float fadeOutMin = Math.Max(5' maxTreeDist - 5);     // >= 5                  float fadeOutMax = Math.Max(10' maxTreeDist + 5);    // >= 10                  float fadeTime = 1.0f; // 1 second                  UpvoidMinerWorldGenerator.setTreeLodSettings(fadeOutMin' fadeOutMax' fadeTime);              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The following statement contains a magic number: {                  int maxTreeDist = (int)settingMaxTreeDistance.value;                  float fadeOutMin = Math.Max(5' maxTreeDist - 5);     // >= 5                  float fadeOutMax = Math.Max(10' maxTreeDist + 5);    // >= 10                  float fadeTime = 1.0f; // 1 second                  UpvoidMinerWorldGenerator.setTreeLodSettings(fadeOutMin' fadeOutMax' fadeTime);              }
Magic Number,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The following statement contains a magic number: {                  int maxTreeDist = (int)settingMaxTreeDistance.value;                  float fadeOutMin = Math.Max(5' maxTreeDist - 5);     // >= 5                  float fadeOutMax = Math.Max(10' maxTreeDist + 5);    // >= 10                  float fadeTime = 1.0f; // 1 second                  UpvoidMinerWorldGenerator.setTreeLodSettings(fadeOutMin' fadeOutMax' fadeTime);              }
Magic Number,UpvoidMiner.Items,ItemManager,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemManager.cs,Update,The following statement contains a magic number: foreach (var entity in Item2Entity.Values)              {                  entity.UpdatePhysics();                  entity.Update(_elapsedSeconds);                    if(entity.RepresentedItem is TorchItem)                  {                      vec3 torchPos = new vec3(entity.thisEntity.Transform.col3);                      float dis = vec3.distance(refPos' torchPos);                        if (dis < torchPositions[0].w)                      {                          // Closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = torchPositions[0]; // Move down the line...                          torchPositions[0] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[1].w)                      {                          // Second-closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[2].w)                      {                          // Third-closest torch (of those known)                          torchPositions[2] = new vec4(torchPos' dis);                      }                      // Otherwise: Further away than at least three other torches                  }              }
Magic Number,UpvoidMiner.Items,ItemManager,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemManager.cs,Update,The following statement contains a magic number: foreach (var entity in Item2Entity.Values)              {                  entity.UpdatePhysics();                  entity.Update(_elapsedSeconds);                    if(entity.RepresentedItem is TorchItem)                  {                      vec3 torchPos = new vec3(entity.thisEntity.Transform.col3);                      float dis = vec3.distance(refPos' torchPos);                        if (dis < torchPositions[0].w)                      {                          // Closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = torchPositions[0]; // Move down the line...                          torchPositions[0] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[1].w)                      {                          // Second-closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[2].w)                      {                          // Third-closest torch (of those known)                          torchPositions[2] = new vec4(torchPos' dis);                      }                      // Otherwise: Further away than at least three other torches                  }              }
Magic Number,UpvoidMiner.Items,ItemManager,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemManager.cs,Update,The following statement contains a magic number: foreach (var entity in Item2Entity.Values)              {                  entity.UpdatePhysics();                  entity.Update(_elapsedSeconds);                    if(entity.RepresentedItem is TorchItem)                  {                      vec3 torchPos = new vec3(entity.thisEntity.Transform.col3);                      float dis = vec3.distance(refPos' torchPos);                        if (dis < torchPositions[0].w)                      {                          // Closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = torchPositions[0]; // Move down the line...                          torchPositions[0] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[1].w)                      {                          // Second-closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[2].w)                      {                          // Third-closest torch (of those known)                          torchPositions[2] = new vec4(torchPos' dis);                      }                      // Otherwise: Further away than at least three other torches                  }              }
Magic Number,UpvoidMiner.Items,ItemManager,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ItemManager.cs,Update,The following statement contains a magic number: foreach (var entity in Item2Entity.Values)              {                  entity.UpdatePhysics();                  entity.Update(_elapsedSeconds);                    if(entity.RepresentedItem is TorchItem)                  {                      vec3 torchPos = new vec3(entity.thisEntity.Transform.col3);                      float dis = vec3.distance(refPos' torchPos);                        if (dis < torchPositions[0].w)                      {                          // Closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = torchPositions[0]; // Move down the line...                          torchPositions[0] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[1].w)                      {                          // Second-closest torch (of those known)                          torchPositions[2] = torchPositions[1]; // Move down the line...                          torchPositions[1] = new vec4(torchPos' dis);                      }                      else if (dis < torchPositions[2].w)                      {                          // Third-closest torch (of those known)                          torchPositions[2] = new vec4(torchPos' dis);                      }                      // Otherwise: Further away than at least three other torches                  }              }
Magic Number,UpvoidMiner.UI,TutorialMessage,C:\repos\Upvoid_UpvoidMiner\Scripts\UI\Tutorials.cs,Report,The following statement contains a magic number: TutorialUI.Msgs[Name].ProgressPercentage = (Current / Target * 100).ToString("0") + "%";
Missing Default,UpvoidMiner,CraftingItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\CraftingItem.cs,ItemName,The following switch statement is missing a default case: switch (type)              {                  case ItemType.Handle:                      return "Handle";                  case ItemType.ShovelBlade:                      return substance.Name + " Shovel Blade";                  case ItemType.PickaxeHead:                      return substance.Name + " Pickaxe Head";                  case ItemType.AxeHead:                      return substance.Name + " Axe Head";              }
Missing Default,UpvoidMiner,CraftingItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\CraftingItem.cs,MakeDescription,The following switch statement is missing a default case: switch (type)              {                  case ItemType.Handle:                      return "A wooden handle.";                  case ItemType.ShovelBlade:                      return "A shovel blade made from " + substance.Name + ".";                  case ItemType.PickaxeHead:                      return "A pickaxe head made from " + substance.Name + ".";                  case ItemType.AxeHead:                      return "An axe head made from " + substance.Name + ".";              }
Missing Default,UpvoidMiner,CraftingItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\CraftingItem.cs,MakeWeight,The following switch statement is missing a default case: switch (type)              {                  case ItemType.Handle:                      return 0.3f;                  case ItemType.ShovelBlade:                      return 1.0f;                  case ItemType.PickaxeHead:                      return 1.0f;                  case ItemType.AxeHead:                      return 1.0f;              }
Missing Default,UpvoidMiner,CraftingItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\CraftingItem.cs,IconName,The following switch statement is missing a default case: switch (type)              {                  case ItemType.Handle:                      return "Handle" + suffix;                  case ItemType.ShovelBlade:                      return "ShovelBlade" + suffix;                  case ItemType.PickaxeHead:                      return "PickaxeHead" + suffix;                  case ItemType.AxeHead:                      return "AxeHead" + suffix;              }
Missing Default,UpvoidMiner,LocalScript,C:\repos\Upvoid_UpvoidMiner\Scripts\LocalScript.cs,HandlePressInput,The following switch statement is missing a default case: switch (e.Key)                  {                      case InputKey.F9:                          PathPositions.Add(camera.Position);                          PathDirections.Add(camera.ForwardDirection);                          PathTmps.Add(vec3.Zero);                          Console.WriteLine("Point recorded");                          break;                      case InputKey.F11:                          PathPositions.Clear();                          PathTmps.Clear();                          PathDirections.Clear();                          Console.WriteLine("Path deleted");                          break;                      case InputKey.F10:                          PathPlaying = !PathPlaying;                          break;                  }
Missing Default,UpvoidMiner,Player,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\Player.cs,AlignPlacementPosition,The following switch statement is missing a default case: switch (CurrentDiggingPivot)              {                  case DiggingController.DigPivot.Top:                      offset = -dirY * height;                      break;                  case DiggingController.DigPivot.Center:                      offset = vec3.Zero;                      break;                  case DiggingController.DigPivot.Bottom:                      offset = dirY * height;                      break;              }
Missing Default,UpvoidMiner,MaterialItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\MaterialItem.cs,OnUse,The following switch statement is missing a default case: switch (player.CurrentPhysicsMode)              {                  case DiggingController.PhysicsMode.Dynamic:                      if (!player.GodMode) // don't remove in godmode                          player.Inventory.RemoveItem(droppedItem);                      ItemManager.InstantiateItem(droppedItem' previewPlaceMatrix' false);                      break;                    case DiggingController.PhysicsMode.Static:                      if (!player.GodMode) // don't remove in godmode                          player.Inventory.RemoveItem(droppedItem);                      ItemManager.InstantiateItem(droppedItem' previewPlaceMatrix' true);                        // Tutorial                      Tutorials.MsgAdvancedCraftingStaticUse.Report(1);                      break;                    case DiggingController.PhysicsMode.Thrown:                      player.DropItem(droppedItem' _worldPos);                        // Tutorial                      Tutorials.MsgAdvancedCraftingThrowUse.Report(1);                      break;              }
Missing Default,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnSelect,The following switch statement is missing a default case: switch (ToolType)              {                  case ToolType.Hammer:                  case ToolType.DroneChain:                      return;              }
Missing Default,UpvoidMiner,ToolItem,C:\repos\Upvoid_UpvoidMiner\Scripts\Items\ToolItem.cs,OnRayPreview,The following switch statement is missing a default case: switch (ToolType)              {                  case ToolType.Hammer:                  case ToolType.DroneChain:                  case ToolType.Axe:                      return;              }
Missing Default,UpvoidMiner,InputController,C:\repos\Upvoid_UpvoidMiner\Scripts\Player\InputController.cs,HandlePressInput,The following switch statement is missing a default case: switch (e.Key)                  {                      case InputKey.Shift:                          keyModifierShift = false;                          break;                      case InputKey.Control:                          keyModifierControl = false;                          break;                      case InputKey.Alt:                          //keyModifierAlt = false;                          break;                  }
Missing Default,UpvoidMiner,UpvoidMinerWorldGenerator,C:\repos\Upvoid_UpvoidMiner\Scripts\Terrain\UpvoidMinerWorldGenerator.cs,AddTree,The following switch statement is missing a default case: switch (type)              {                  case Tree.TreeType.Birch:                      t = TreeGenerator.OldTree(random' transform1' transform2' world);                      break;                  case Tree.TreeType.Cactus:                      t = TreeGenerator.Cactus(random' transform1' transform2' world);                      break;              }
Missing Default,UpvoidMiner,Settings,C:\repos\Upvoid_UpvoidMiner\Scripts\Settings.cs,ResetSettings,The following switch statement is missing a default case: switch (Profile.ToLower())              {                  case "lowest":                      SettingsPresetMin();                      break;                  case "low":                      SettingsPresetLow();                      break;                  case "medium":                      SettingsPresetMedium();                      break;                  case "high":                      SettingsPresetHigh();                      break;                  case "max":                      SettingsPresetMax();                      break;              }
