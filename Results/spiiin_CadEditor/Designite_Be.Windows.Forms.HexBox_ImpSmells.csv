Implementation smell,Namespace,Class,File,Method,Description
Long Method,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The method has 148 lines of code.
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\DynamicFileByteProvider.cs,WriteByte,Cyclomatic complexity of the method is 12
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\DynamicFileByteProvider.cs,InsertBytes,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\DynamicFileByteProvider.cs,ApplyChanges,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,Find,Cyclomatic complexity of the method is 8
Complex Method,Be.Windows.Forms,KeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,Cyclomatic complexity of the method is 12
Complex Method,Be.Windows.Forms,StringKeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,Cyclomatic complexity of the method is 8
Long Parameter List,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintHexStringSelected,The method has 5 parameters. Parameters: g' b' brush' brushBack' gridPoint
Long Statement,Be.Windows.Forms,BuiltInContextMenu,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "                _cutToolStripMenuItem = new ToolStripMenuItem(CutMenuItemTextInternal' CutMenuItemImage' new EventHandler(CutMenuItem_Click)); " is 126.
Long Statement,Be.Windows.Forms,BuiltInContextMenu,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "                _copyToolStripMenuItem = new ToolStripMenuItem(CopyMenuItemTextInternal' CopyMenuItemImage' new EventHandler(CopyMenuItem_Click)); " is 130.
Long Statement,Be.Windows.Forms,BuiltInContextMenu,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "                _pasteToolStripMenuItem = new ToolStripMenuItem(PasteMenuItemTextInternal' PasteMenuItemImage' new EventHandler(PasteMenuItem_Click)); " is 134.
Long Statement,Be.Windows.Forms,BuiltInContextMenu,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\BuiltInContextMenu.cs,CheckBuiltInContextMenu,The length of the statement  "                _selectAllToolStripMenuItem = new ToolStripMenuItem(SelectAllMenuItemTextInternal' SelectAllMenuItemImage' new EventHandler(SelectAllMenuItem_Click)); " is 150.
Long Statement,Be.Windows.Forms,DynamicFileByteProvider,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\DynamicFileByteProvider.cs,InsertBytes,The length of the statement  "                // If the insertion point is at the start of a file block' and the previous block is a memory block' append it to that block. " is 125.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateScrollSize,The length of the statement  "				long scrollmax = (long)Math.Ceiling((double)(_byteProvider.Length + 1) / (double)_iHexMaxHBytes - (double)_iHexMaxVBytes); " is 122.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,Find,The length of the statement  "					throw new ArgumentException("FindBufferUpperCase and FindBufferUpperCase must have the same size when Type is Text and MatchCase is true"); " is 139.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintColumnSeparator,The length of the statement  "					g.DrawLine(pen' new PointF(byteStringPointF.X' byteStringPointF.Y)' new PointF(byteStringPointF.X' byteStringPointF.Y + _recHex.Height)); " is 137.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintHexAndStringView,The length of the statement  "			bool isStringKeyInterpreterActive = _keyInterpreter != null && _keyInterpreter.GetType() == typeof(StringKeyInterpreter); " is 121.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The length of the statement  "			_recColumnInfo = new Rectangle(_recLineInfo.X + _recLineInfo.Width' _recContent.Y' _recContent.Width - _recLineInfo.Width' (int)charSize.Height + 4); " is 149.
Long Statement,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,ConvertHexToByte,The length of the statement  "			bool isByte = byte.TryParse(hex' System.Globalization.NumberStyles.HexNumber' System.Threading.Thread.CurrentThread.CurrentCulture' out b); " is 139.
Long Statement,Be.Windows.Forms,KeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,The length of the statement  "					byte newcb = byte.Parse(sNewCb' System.Globalization.NumberStyles.AllowHexSpecifier' System.Threading.Thread.CurrentThread.CurrentCulture); " is 139.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateScrollSize,The conditional expression  "VScrollBarVisible && _byteProvider != null && _byteProvider.Length > 0 && _iHexMaxHBytes != 0"  is complex.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,CreateCaret,The conditional expression  "_byteProvider == null || _keyInterpreter == null || _caretVisible || !this.Focused"  is complex.
Complex Conditional,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentByteSign,The conditional expression  "rec.Top < 0 || rec.Left < 0 || rec.Width <= 0 || rec.Height <= 0"  is complex.
Complex Conditional,Be.Windows.Forms,KeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,The conditional expression  "(!sw && pos != _hexBox._byteProvider.Length) ||  					(!si && pos == _hexBox._byteProvider.Length)"  is complex.
Complex Conditional,Be.Windows.Forms,KeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,The conditional expression  "!isInsertMode && si && _hexBox.InsertActive && cp == 0"  is complex.
Complex Conditional,Be.Windows.Forms,StringKeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmChar,The conditional expression  "(!sw && pos != _hexBox._byteProvider.Length) ||  					(!si && pos == _hexBox._byteProvider.Length)"  is complex.
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,HexBox,The following statement contains a magic number: _thumbTrackTimer.Interval = 50;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,ToScrollPos,The following statement contains a magic number: int max = 65535;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  				return (int)value;  			else  			{  				double valperc = (double)value / (double)_scrollVmax * (double)100;  				int res = (int)Math.Floor((double)max / (double)100 * valperc);  				res = (int)Math.Max(_scrollVmin' res);  				res = (int)Math.Min(_scrollVmax' res);  				return res;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,ToScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  				return (int)value;  			else  			{  				double valperc = (double)value / (double)_scrollVmax * (double)100;  				int res = (int)Math.Floor((double)max / (double)100 * valperc);  				res = (int)Math.Max(_scrollVmin' res);  				res = (int)Math.Min(_scrollVmax' res);  				return res;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,FromScrollPos,The following statement contains a magic number: int max = 65535;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  			{  				return (long)value;  			}  			else  			{  				double valperc = (double)value / (double)max * (double)100;  				long res = (int)Math.Floor((double)_scrollVmax / (double)100 * valperc);  				return res;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,FromScrollPos,The following statement contains a magic number: if (_scrollVmax < max)  			{  				return (long)value;  			}  			else  			{  				double valperc = (double)value / (double)max * (double)100;  				long res = (int)Math.Floor((double)_scrollVmax / (double)100 * valperc);  				return res;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,ToScrollMax,The following statement contains a magic number: long max = 65535;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PerformScrollThumpPosition,The following statement contains a magic number: int difference = (_scrollVmax > 65535) ? 10 : 9;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PerformScrollThumpPosition,The following statement contains a magic number: int difference = (_scrollVmax > 65535) ? 10 : 9;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PerformScrollThumpPosition,The following statement contains a magic number: int difference = (_scrollVmax > 65535) ? 10 : 9;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,GetHexBytePositionInfo,The following statement contains a magic number: int hPos = (iX / 3 + 1);
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,GetHexBytePositionInfo,The following statement contains a magic number: byteCharaterPos = (iX % 3);
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++)  			{  				if (_abortFind)  					return -2;    				if (pos % 1000 == 0) // for performance reasons: DoEvents only 1 times per 1000 loops  					Application.DoEvents();    				byte compareByte = _byteProvider.ReadByte(pos);  				bool buffer1Match = compareByte == buffer1[match];  				bool hasBuffer2 = buffer2 != null;  				bool buffer2Match = hasBuffer2 ? compareByte == buffer2[match] : false;  				bool isMatch = buffer1Match || buffer2Match;  				if (!isMatch)  				{  					pos -= match;  					match = 0;  					_findingPos = pos;  					continue;  				}    				match++;    				if (match == buffer1Length)  				{  					long bytePos = pos - buffer1Length + 1;  					Select(bytePos' buffer1Length);  					ScrollByteIntoView(_bytePos + _selectionLength);  					ScrollByteIntoView(_bytePos);    					return bytePos;  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,Find,The following statement contains a magic number: for (long pos = startIndex; pos < _byteProvider.Length; pos++)  			{  				if (_abortFind)  					return -2;    				if (pos % 1000 == 0) // for performance reasons: DoEvents only 1 times per 1000 loops  					Application.DoEvents();    				byte compareByte = _byteProvider.ReadByte(pos);  				bool buffer1Match = compareByte == buffer1[match];  				bool hasBuffer2 = buffer2 != null;  				bool buffer2Match = hasBuffer2 ? compareByte == buffer2[match] : false;  				bool isMatch = buffer1Match || buffer2Match;  				if (!isMatch)  				{  					pos -= match;  					match = 0;  					_findingPos = pos;  					continue;  				}    				match++;    				if (match == buffer1Length)  				{  					long bytePos = pos - buffer1Length + 1;  					Select(bytePos' buffer1Length);  					ScrollByteIntoView(_bytePos + _selectionLength);  					ScrollByteIntoView(_bytePos);    					return bytePos;  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++)  			{  				long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;    				PointF bytePointF = GetBytePointF(new Point(0' 0 + i));  				string info = firstLineByte.ToString(_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  				int nulls = 8 - info.Length;  				string formattedInfo;  				if (nulls > -1)  				{  					formattedInfo = new string('0'' 8 - info.Length) + info;  				}  				else  				{  					formattedInfo = new string('~'' 8);  				}    				g.DrawString(formattedInfo' Font' brush' new PointF(_recLineInfo.X' bytePointF.Y)' _stringFormat);  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++)  			{  				long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;    				PointF bytePointF = GetBytePointF(new Point(0' 0 + i));  				string info = firstLineByte.ToString(_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  				int nulls = 8 - info.Length;  				string formattedInfo;  				if (nulls > -1)  				{  					formattedInfo = new string('0'' 8 - info.Length) + info;  				}  				else  				{  					formattedInfo = new string('~'' 8);  				}    				g.DrawString(formattedInfo' Font' brush' new PointF(_recLineInfo.X' bytePointF.Y)' _stringFormat);  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintLineInfo,The following statement contains a magic number: for (int i = 0; i < maxLine; i++)  			{  				long firstLineByte = (startByte + (_iHexMaxHBytes) * i) + _lineInfoOffset;    				PointF bytePointF = GetBytePointF(new Point(0' 0 + i));  				string info = firstLineByte.ToString(_hexStringFormat' System.Threading.Thread.CurrentThread.CurrentCulture);  				int nulls = 8 - info.Length;  				string formattedInfo;  				if (nulls > -1)  				{  					formattedInfo = new string('0'' 8 - info.Length) + info;  				}  				else  				{  					formattedInfo = new string('~'' 8);  				}    				g.DrawString(formattedInfo' Font' brush' new PointF(_recLineInfo.X' bytePointF.Y)' _stringFormat);  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: for (int col = GroupSize; col < _iHexMaxHBytes; col += GroupSize)  			{  				var pen = new Pen(new SolidBrush(this.InfoForeColor)' 1);  				PointF headerPointF = GetColumnInfoPointF(col);  				headerPointF.X -= _charSize.Width / 2;  				g.DrawLine(pen' headerPointF' new PointF(headerPointF.X' headerPointF.Y + _recColumnInfo.Height + _recHex.Height));  				if (StringViewVisible)  				{  					PointF byteStringPointF = GetByteStringPointF(new Point(col' 0));  					headerPointF.X -= 2;  					g.DrawLine(pen' new PointF(byteStringPointF.X' byteStringPointF.Y)' new PointF(byteStringPointF.X' byteStringPointF.Y + _recHex.Height));  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintColumnSeparator,The following statement contains a magic number: for (int col = GroupSize; col < _iHexMaxHBytes; col += GroupSize)  			{  				var pen = new Pen(new SolidBrush(this.InfoForeColor)' 1);  				PointF headerPointF = GetColumnInfoPointF(col);  				headerPointF.X -= _charSize.Width / 2;  				g.DrawLine(pen' headerPointF' new PointF(headerPointF.X' headerPointF.Y + _recColumnInfo.Height + _recHex.Height));  				if (StringViewVisible)  				{  					PointF byteStringPointF = GetByteStringPointF(new Point(col' 0));  					headerPointF.X -= 2;  					g.DrawLine(pen' new PointF(byteStringPointF.X' byteStringPointF.Y)' new PointF(byteStringPointF.X' byteStringPointF.Y + _recHex.Height));  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintHexStringSelected,The following statement contains a magic number: float bcWidth = (isLastLineChar) ? _charSize.Width * 2 : _charSize.Width * 3;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintHexStringSelected,The following statement contains a magic number: float bcWidth = (isLastLineChar) ? _charSize.Width * 2 : _charSize.Width * 3;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PaintCurrentBytesSign,The following statement contains a magic number: if (_keyInterpreter != null && _bytePos != -1 && Enabled)  			{  				if (_keyInterpreter.GetType() == typeof(KeyInterpreter))  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetByteStringPointF(gp);  						Size s = new Size((int)_charSize.Width' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						if (r.IntersectsWith(_recStringView))  						{  							r.Intersect(_recStringView);  							PaintCurrentByteSign(g' r);  						}  					}  					else  					{  						int lineWidth = (int)(_recStringView.Width - _charSize.Width);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetByteStringPointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetByteStringPointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recStringView))  							{  								singleLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recStringView.X + lineWidth - startSelPointF.X + _charSize.Width)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recStringView))  							{  								firstLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recStringView.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(_recStringView.Width)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recStringView))  								{  									betweenLines.Intersect(_recStringView);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recStringView.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recStringView.X + _charSize.Width)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recStringView))  							{  								lastLine.Intersect(_recStringView);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  				else  				{  					if (_selectionLength == 0)  					{  						Point gp = GetGridBytePoint(_bytePos - _startByte);  						PointF pf = GetBytePointF(gp);  						Size s = new Size((int)_charSize.Width * 2' (int)_charSize.Height);  						Rectangle r = new Rectangle((int)pf.X' (int)pf.Y' s.Width' s.Height);  						PaintCurrentByteSign(g' r);  					}  					else  					{  						int lineWidth = (int)(_recHex.Width - _charSize.Width * 5);    						Point startSelGridPoint = GetGridBytePoint(_bytePos - _startByte);  						PointF startSelPointF = GetBytePointF(startSelGridPoint);    						Point endSelGridPoint = GetGridBytePoint(_bytePos - _startByte + _selectionLength - 1);  						PointF endSelPointF = GetBytePointF(endSelGridPoint);    						int multiLine = endSelGridPoint.Y - startSelGridPoint.Y;  						if (multiLine == 0)  						{  							Rectangle singleLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(endSelPointF.X - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (singleLine.IntersectsWith(_recHex))  							{  								singleLine.Intersect(_recHex);  								PaintCurrentByteSign(g' singleLine);  							}  						}  						else  						{  							Rectangle firstLine = new Rectangle(  								(int)startSelPointF.X'  								(int)startSelPointF.Y'  								(int)(_recHex.X + lineWidth - startSelPointF.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (firstLine.IntersectsWith(_recHex))  							{  								firstLine.Intersect(_recHex);  								PaintCurrentByteSign(g' firstLine);  							}    							if (multiLine > 1)  							{  								Rectangle betweenLines = new Rectangle(  									_recHex.X'  									(int)(startSelPointF.Y + _charSize.Height)'  									(int)(lineWidth + _charSize.Width * 2)'  									(int)(_charSize.Height * (multiLine - 1)));  								if (betweenLines.IntersectsWith(_recHex))  								{  									betweenLines.Intersect(_recHex);  									PaintCurrentByteSign(g' betweenLines);  								}    							}    							Rectangle lastLine = new Rectangle(  								_recHex.X'  								(int)endSelPointF.Y'  								(int)(endSelPointF.X - _recHex.X + _charSize.Width * 2)'  								(int)_charSize.Height);  							if (lastLine.IntersectsWith(_recHex))  							{  								lastLine.Intersect(_recHex);  								PaintCurrentByteSign(g' lastLine);  							}  						}  					}  				}  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: SizeF charSize = this.CreateGraphics().MeasureString("A"' Font' 100' _stringFormat);
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: int marginLeft = 4;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_lineInfoVisible)  			{  				_recLineInfo = new Rectangle(_recContent.X + marginLeft'  					_recContent.Y'  					(int)(_charSize.Width * 10)'  					_recContent.Height);  			}  			else  			{  				_recLineInfo = Rectangle.Empty;  				_recLineInfo.X = marginLeft;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: _recColumnInfo = new Rectangle(_recLineInfo.X + _recLineInfo.Width' _recContent.Y' _recContent.Width - _recLineInfo.Width' (int)charSize.Height + 4);
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_columnInfoVisible)  			{  				_recLineInfo.Y += (int)charSize.Height + 4;  				_recLineInfo.Height -= (int)charSize.Height + 4;  			}  			else  			{  				_recColumnInfo.Height = 0;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (_columnInfoVisible)  			{  				_recLineInfo.Y += (int)charSize.Height + 4;  				_recLineInfo.Height -= (int)charSize.Height + 4;  			}  			else  			{  				_recColumnInfo.Height = 0;  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,UpdateRectanglePositioning,The following statement contains a magic number: if (UseFixedBytesPerLine)  			{  				SetHorizontalByteCount(_bytesPerLine);  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}  			else  			{  				int hmax = (int)Math.Floor((double)_recHex.Width / (double)_charSize.Width);  				if (_stringViewVisible)  				{  					hmax -= 2;  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 4));  					else  						SetHorizontalByteCount(1);  				}  				else  				{  					if (hmax > 1)  						SetHorizontalByteCount((int)Math.Floor((double)hmax / 3));  					else  						SetHorizontalByteCount(1);  				}  				_recHex.Width = (int)Math.Floor(((double)_iHexMaxHBytes) * _charSize.Width * 3 + (2 * _charSize.Width));  			}
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,GetBytePointF,The following statement contains a magic number: float x = (3 * _charSize.Width) * gp.X + _recHex.X;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,GetColumnInfoPointF,The following statement contains a magic number: float x = (3 * _charSize.Width) * gp.X + _recColumnInfo.X;
Magic Number,Be.Windows.Forms,HexBox,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,OnMouseWheel,The following statement contains a magic number: int linesToScroll = -(e.Delta * SystemInformation.MouseWheelScrollLines / 120);
Missing Default,Be.Windows.Forms,KeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmKeyUp,The following switch statement is missing a default case: switch (keyData)  				{  					case Keys.ShiftKey:  					case Keys.Insert:  						if (RaiseKeyUp(keyData))  							return true;  						break;  				}
Missing Default,Be.Windows.Forms,StringKeyInterpreter,C:\repos\spiiin_CadEditor\libs\BeHexEditor150\HexBox.cs,PreProcessWmKeyDown,The following switch statement is missing a default case: switch (keyData)  				{  					case Keys.Tab | Keys.Shift:  					case Keys.Tab:  						if (RaiseKeyDown(keyData))  							return true;  						break;  				}
